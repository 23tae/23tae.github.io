[ { "title": "[운영 체제] 04. Thread & Concurrency", "url": "/posts/os04/", "categories": "Computer Science, Operating System", "tags": "cs, os", "date": "2022-07-28 00:00:00 +0900", "snippet": "Overview스레드 (thread) 가벼운 프로세스 CPU 활용의 기본 단위 스레드 ID, 프로그램 카운터, 레지스터 세트, 스택으로 구성됨앞에서는 프로세스가 한 개의 스레드로 실행(싱글스레딩)된다고 가정했음하지만 실제로 프로세스는 여러 개의 스레드로 실행(멀티스레딩)될 수 있음[싱글스레딩과 멀티스레딩]멀티스레딩의 등장 배경아래와 같은 클라이언트-서버 시스템(웹서버 등)을 가정하면,기존의 싱글스레딩은 서버가 클라이언트로부터 request를 수신한 뒤에 해당 request를 처리하는 동안 기존의 클라이언트로부터 수신하던 작업은 잠시 멈추게 됨.하지만 멀티스레딩을 사용하면 request를 받고(1번), 새로 생성한 스레드에 request 처리 작업을 맡긴(2번) 후, 기존의 작업을 계속해서 할 수 있음(3번).멀티스레딩의 이점 응답성(Responsiveness) 프로세스(UI 등)의 일부가 차단되는 경우에도 지속적인 실행이 가능함 리소스의 공유(Resource Sharing) 프로세스의 리소스를 스레드끼리 공유해서 스레드간 협업이 가능 리소스 공유가 IPC 메커니즘(shared-memory, message-passing)보다 용이함. 경제성(Economy) 스레드 생성이 프로세스 생성보다 경제적임 thread switching이 context switching에 비해 간접비가 적음 확장성(Scalability) 멀티프로세스 아키텍처에서 각 스레드가 다른 프로세서에서 병렬로 처리될 수 있음 Multicore Programming멀티스레딩 in 멀티코어 시스템 동시성(concurrecy) 향상을 위한 멀티 코어 사용의 효율적 방법임 4스레드의 애플리케이션이 있을 때, 싱글 코어 : 스레드들이 시간별로 배치됨 (Concurrent execution) 멀티 코어 : 몇몇 스레드는 동시에 작동할 수 있음 (Parallel execution) 멀티코어 시스템의 문제점 태스크 인식(identifying tasks) 애플리케이션을 분석해서 같은 코어(separate), 다른 코어(concurrent)에서 할 작업을 나눠야 함 균형(balance) 분리할 파트간의 균형을 맞춰야 함 데이터 분리(data spliting) 데이터도 각각의 코어에서 실행되게 분리되어야 함 데이터 종속성(data dependency) 작업을 끝내고 데이터 동기화를 해야 함 (분리된 데이터를 기존의 형태에 맞게 합쳐주는 작업 필요) 테스팅과 디버깅이 싱글스레드에 비해 어려움병렬성(Parallelism)의 종류 Data Parallelism Task Parallelism암달의 법칙 (Amdahl’s law)컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는 공식공식 S : 연속적으로 실행되어야 하는 시스템의 비율, N : 코어의 개수주요 내용 코어는 무조건 많을수록 좋을까? 실제로는 연속적으로 실행되어야 하는 시스템의 비율이 증가할수록 코어의 증가가 성능 향상에 미치는 영향은 감소함Multithreading Models스레드의 종류 user thread kernel 윗단에 제공됨 kernel의 지원 없이 관리됨 kernel thread OS의 지원을 받으며 직접적으로 관리됨 user-kernel 스레드의 관계 다대일 모델 (Many-to-One) 일대일 모델 (One-to-One) 다대다 모델 (Many-to-Many) Thread Libraries개발자에게 스레드 생성, 관리에 필요한 API를 제공함라이브러리 구현 방법 user-space에서 구현 kernel-level에서 구현주요 라이브러리 POSIX Pthread Windows thread Java threadPthreads POSIX standard(IEEE 1003.1c)가 스레드 생성, 동기화를 위해 정의한 API를 참조함 참조한 부분은 스레드 동작에 대한 명세일 뿐, 구현에 관한 내용은 아님. Java Threads Java의 프로그램 실행 기본 모델임 스레드 생성과 관리를 위한 풍부한 기능을 제공함스레드 생성 Thread 클래스를 상속 Thread 클래스로부터 나온 새 클래스를 생성함 해당 클래스에 public void run() 메소드를 override Runnable 인터페이스를 구현 Runnable 인터페이스를 제공하는 새 클래스를 정의함 해당 클래스에 public void run() 메소드를 override 람다 표현식(Lambda Expression) 사용 새 클래스를 정의하는 대신 Runnable 람다식을 사용함 람다식 : 함수를 하나의 식으로 표현한 것. 메소드의 이름을 버린 익명 함수. 스레드 대기 / 종료 부모 스레드의 대기 : wait() join 스레드의 종료 : stop interruptImplicit Threading멀티 코어 프로세싱이 성장함에 따라 수백, 수천 개의 스레드를 가진 애플리케이션이 등장함. 개발자가 이런 애플리케이션을 디자인하는 것은 상당히 어려움.이런 어려움을 해결하고 concurrent하며 parellel한 애플리케이션을 더 잘 지원할 수 있는 방법은 스레드의 생성과 관리의 역할을 앱 개발자에게서 컴파일러와 런타임 라이브러리에게로 옮기는 것임. 다른 말로 하면 암묵적 스레딩(implicit threading).암묵적 스레딩의 주요 방법 Thread Pools Fork &amp; Join OpenMP Grand Central Dispatch (GCD) Intel Thread Building Blocks스레드 풀(Thread Pools)스레드를 풀에 미리 생성한 후, 작업이 들어오면 이곳에 있는 스레드가 해당 작업을 처리함앞부분 멀티스레딩의 등장 배경 파트에서 스레드의 생성은 프로세스에 요청이 들어와도 기존의 작업을 이어갈 수 있는 장점이 있다고 했음. 이러한 스레드 생성은 프로세스 생성보다는 낫지만 여전히 잠재적인 문제가 있음.스레드 생성의 문제점 스레드를 생성하는데에 시간이 소요됨. 또한 이렇게 만든 스레드가 작업이 끝나면 버려짐 concurrent하게 동작하는 스레드의 개수에 한계치를 설정할 수 없음 → 시스템이 감당할 수 있는 범위를 넘어서면 문제가 발생할 수 있음그 해결책으로 나온 개념이 바로 스레드 풀스레드 풀에서의 동작 과정 일정한 스레드를 시작 시에 생성하여 풀(이들이 쉬면서 작업을 기다리는 곳)에 위치시킴 서버가 요청을 받으면 스레드를 생성하는 대신 해당 요청을 풀에 넘겨줌. 서버는 계속해서 추가적인 요청을 기다림. 풀에 여유 스레드가 있다면 → 스레드를 깨워서 요청을 즉시 처리함 풀에 여유 스레드가 없다면 → 여유 스레드가 생길때까지 작업을 대기함 스레드가 작업을 완료하면 풀에 돌아와서 다른 작업을 기다림스레드 풀의 장점 기존의 스레드로 요청을 처리하는 것이 새로운 스레드가 생성될 때까지 기다리는 것보다 빠름 한 시점에 존재하는 스레드의 수를 제한함. 대규모의 병렬 처리를 지원할 수 없는 시스템의 경우 이점이 특히 중요함. 수행할 작업을 작업의 생성 장소와 분리함으로서 작업 실행에 다양한 전략을 취할 수 있음. 예를 들어, 작업이 시간 딜레이를 두고 실행되거나 작업이 특정 시간에 실행되게 예약할 수 있음. OpenMP병렬로 처리되기를 원하는 부분을 지정해서 병렬적으로 실행함. 컴파일러에게 지시문을 통해 지시하면 OpenMP 런타임 라이브러리가 해당 부분을 병렬 처리함.아래 코드를 gcc -fopenmp &lt;filename&gt; 으로 컴파일해서 실행하면 병렬적으로 실행하게됨.#include &lt;stdio.h&gt;#include &lt;omp.h&gt;int main(int argc, char *argv[]){\t#pragma omp parallel // compiler directive\t{\t\tprintf(\"I am a parallel region.\\n\");\t}\treturn 0;}#pragma omp parallel : OpenMP 지시문. 여러 스레드에서 병렬로 실행할 코드인 병렬 영역을 정의함.Ref.https://www.nginx.com/blog/thread-pools-boost-performance-9x/https://docs.microsoft.com/ko-kr/cpp/parallel/openmp/reference/openmp-directives?view=msvc-170" }, { "title": "[운영 체제] 03. Processes", "url": "/posts/os03/", "categories": "Computer Science, Operating System", "tags": "cs, os", "date": "2022-07-26 12:30:00 +0900", "snippet": "Process Concept프로세스란? 프로세스는 실행되는 프로그램을 의미함 프로세스는 OS에서의 작업 단위 프로세스가 작업을 마치기 위해서는 다음과 같은 리소스를 필요로 함 CPU 타임 메모리 파일 I/O 디바이스 OS가 하는 가장 중요한 일이 프로세스를 관리하는 것프로세스의 메모리 구성 Text 영역 실행가능한 코드 Data 영역 전역 변수 Heap 영역 동적할당된 메모리 Stack 영역 함수를 호출한 경우 함수 매개변수, 리턴 주소(함수 수행이 끝난 뒤 실행될 코드의 위치), 지역 변수 프로세스의 생명 주기프로세스가 실행되는 동안 상태가 바뀜 New : 프로세스가 생성된 상태 Running : 프로세스의 명령어를 CPU에 불러옴 Waiting : 어떤 이벤트의 발생을 기다리는 상태 타임쉐어링으로 다른 프로세스를 잠시 실행하면 기존의 프로세스가 waiting 상태가 됨 waiting queue에서 I/O 완료나 시그널의 수신 등을 기다림 Ready : ready queue에서 프로세서에게 할당되기를 기다림 Terminated : 모든 것이 끝나고 종료된 상태PCB / TCBPCB(Process Control Block) 또는 TCB(Task Control Block) 는 프로세스를 관리하기 쉽도록 정보들을 하나의 구조체에 모아놓은 것PCB에 담긴 정보는 다음과 같음 Process state : 프로세스의 생명 주기 중 어떤 상태인지 Program counter : 마이크로프로세서 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정함 CPU resgisters CPU-scheduling information Memory-management information : 동적할당한 메모리 관련 정보 Accounting information : 유저 관련 정보 I/O status information프로세스의 정의기존 정의 싱글스레드로 실행되는 프로그램을 말함 스레드(thread) : 가벼운 프로세스를 의미함 한번에 한 개의 작업만 할 수 있음확장된 정의 한 개 이상의 스레드로 실행되는 프로그램 한번에 여러 개의 작업을 수행할 수 있음Process Scheduling멀티 프로그래밍개념 : 한번에 여러 프로세스를 실행시키는 것목적 : CPU 활용률을 극대화시키기 위해타임 쉐어링개념 : CPU 코어를 프로세스간에 매우 빈번하게 교체하는 것목적 : 사용자에게 프로그램들이 동시에 실행된다고 느끼게 함스케줄링 큐 (Scheduling Queues) 프로세스가 시스템에 들어오면 ready queue(CPU의 코어에 실행될 준비가 되고 기다리는 곳)에 들어간다 특정한 이벤트의 발생을 기다리는 프로세스는 waiting queue에 위치한다 waiting queue에서 기다리다가 ready queue로 이동함 PCB에 연결리스트로 다음과 같이 구현되어있음Queueing Diagram 프로세스 스케줄링은 보통 다음과 같은 형태로 일어남Context Switch context 프로세스가 사용되고 있는 상태. PCB에 저장되어 있음. 보통 PCB 정보를 의미함 interrupt가 발생하면 시스템이 현재 실행되는 프로세스의 context를 저장하고 나중에 해당 context를 복구해서 프로세스가 이어지게끔 함 context switch의 과정은 아래와 같음 다른 프로세스에게 CPU 코어를 전환시킴 현재 프로세스의 상태를 저장함 다른 프로세스의 상태를 복구함 Operations on Processes 프로세스 생성 프로세스 종료프로세스 생성하나의 프로세스는 다수의 새로운 프로세스를 생성할 수 있음. parent process(부모 프로세스) : 원본 프로세스 child process(자식 프로세스) : 이것으로부터 생성된 프로세스 실행의 2가지 경우의 수 parent process가 그것의 child process와 동시에(concurrently) 실행됨 parent가 children이 종료될 때까지 기다림 주소 공간(address-space)의 2가지 경우의 수 child process가 parent의 복제품인 경우. 이 경우 같은 공간을 사용함. child가 새 프로그램으로 실행되는 경우 fork 시스템 콜 기능UNIX 계열 OS에서 새로운 프로세스를 생성하는 시스템 콜이렇게 생성된 child 프로세스는 parent 프로세스의 주소공간의 사본을 가짐. 리턴값 (pid) 0 : child process 0 이외의 값 : parent process 호출 이후parent와 child 모두 fork() 이후에 실행을 이어감.child가 실행되는 동안 parent가 할 작업이 없으면 wait() 시스템 콜을 호출한 뒤, ready queue로 가서 child의 종료를 기다릴 수 있음. child가 종료되며 인터럽트를 주면 그때부터 다시 parent가 이어서 실행됨.프로세스 종료종료되는 경우는 다음과 같다. 마지막 문장까지 실행을 완료한 경우 exit() 시스템 콜을 호출한 경우 : OS에게 프로세스를 삭제할 것을 요청함프로세스가 종료될 때 OS는 할당된 것들을 해제하고, 리소스를 되찾음 메모리 할당, 파일 오픈, I/O 버퍼 등Zombie , Orphan보통 parent는 child가 종료될 때까지 기다림 zombie process : child가 종료됐지만 parent가 아직 wait()을 호출하지 않은 경우 wait() : parent가 child 프로세스가 될 때까지 기다리기 위해 사용 orphan process : parent가 wait의 호출 없이 먼저 종료되고 child는 돌아가고 있는 경우Interprocess Communicationconcurrent한 프로세스 간의 실행 방식 독립적으로 실행 (independent process) 다른 프로세스들과 데이터를 공유하지 않음 협력해서 실행 (cooperating process) 다른 프로세스들과 데이터를 공유함 다른 프로세스에게 영향을 주거나 받음 IPC (Inter-Process Communication) Cooperating process들은 IPC 메커니즘을 필요로 함 프로세스 간에 데이터를 주고받을 수 있음 IPC 모델 (a) 메모리를 공유하는 방식 (Shared-Memory Systems) 공유하는 메모리 영역을 통해 데이터를 주고받음 (b) 메시지를 주고받는 방식 (Message-Passing Systems) message queue에 메시지를 보내면 OS가 대신 전해줌 Shared-Memory Systems 기존 문제 : 생산자-소비자 문제 (producer-consumer problem) 여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 문제. 한정 버퍼 문제라고도 함. producer : 정보 생산하는 대상, consumer : 정보 소비하는 대상) 예시 1. 컴파일러 : producer (어셈블리 코드를 생산), 어셈블러 : consumer (해당 코드를 소비) 예시 2. 웹 서버 : producer (HTML 파일을 생산), 브라우저 : consumer (해당 파일을 소비) 해결 방법 : shared-memory 생산자와 소비자 프로세스가 공유하는 메모리 영역(shared memory)을 통해 데이터 교환 생산자와 소비자를 concurrent하게 실행시킴 버퍼 개념 생산자 : 버퍼를 채움 소비자 : 버퍼를 비움 Message-Passing Systems 기존 문제 shared memory를 관리하는 것은 온전히 개발자의 몫임 생산자-소비자의 수가 늘어날 수록 개발자에게는 어려움이 존재. 해결 방법 : message-passing OS가 메시지를 전달할 수단(message-passing facility)를 제공해줌 message-passing facility의 동작 send (message) receive (message) Communication Links 두 프로세스간에 통신을 한다고 하면, 데이터를 주고 받는 데 사용되는 연결을 의미함. 형성되는 방식 direct / indirect communication synchronous / asynchronous communication automatic / explicit buffering direct / indirect communication direct 통신을 하려는 프로세스는 수신자, 발송자로 명시됨. send(P, message), receive(Q, message)의 형태로 메시지를 주고받음 (P : 수신자, Q : 발송자) 링크는 자동적으로 형성됨 (수신, 발신자가 정해져 있기 때문) 링크는 두 개의 프로세스와만 관련됨 각 프로세스 쌍 별로 한 개의 링크만 존재함 indirect mailbox (또는 port)를 통해 메시지를 주고받음. mailbox : 메시지가 각 프로세스에 의해 놓아지고 제거되는 추상적 공간 send(A, message), receive(A, message)의 형태로 메시지를 주고받음 (A : mailbox) 링크는 각 프로세스의 쌍이 공유하는 mailbox가 존재하는 경우에만 형성됨 링크는 두 개 이상의 프로세스와 관련될 수 있음 여러개의 링크가 존재할 수 있음 (각 링크는 하나의 mailbox를 가짐) OS의 역할 create / delete mailbox send / receive messages synchronous / asynchronous communication (or blocking / non-blocking) synchronous communication (동기 통신) blocking send : 발송자는 메시지가 수신되기 전까지 blocked blocking receive : 수신자는 메시지가 존재할 때 까지 blocked asynchronous communicatoin (비동기 통신) non-blocking send : 발송자는 계속해서 메시지를 보냄 (수신 여부와 상관없이) non-blocking receive : 수신자는 계속해서 메시지를 받음 (유효한 메시지 또는 null 메시지에 관계없이) 참고 : 직렬 통신 Examples of IPC Systems shared memory : POSIX Shared Memory Message Passing : PipesPOSIX shared memorymemory-mapped 파일을 이용해 메모리를 구성함 POSIX: Portable Operating System Interface (for uniX) 공유 메모리 객체를 생성 fd = shm_open(name, O_CREAT | ORDWR, 0666); 객체의 크기를 바이트 단위로 설정 ftruncate(fd, 4096); memory-mapped 파일을 생성 mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); Pipes UNIX 계열 OS의 초기 IPC 메커니즘 파이프는 두 프로세스가 통신할 수 있는 수도관 역할을 함 pipe 구현의 네 가지 이슈 통신 방향 : unidirectional / bidirectional two-way 통신의 구현 방법 : half-duplex / full-duplex (참고 : 데이터 통신) 프로세스 간 관계 존재 여부 (ex. parent-child) 네트워크를 통한 통신 여부 pipe 종류 Ordinary pipes 생성한 프로세스 외부에서 접속 불가 주로, parent 프로세스가 child와 통신하기 위해 파이프를 생성함 두 프로세스가 생산자-소비자의 방식으로 통신함 생산자는 pipe의 한 쪽 끝에다가 작성함 (write end) 소비자는 pipe의 반대쪽 끝에서부터 읽음 (read end) unidirectional : one-way 통신만 가능 (two-way 통신은 pipe 2개를 통해 구현 가능) Named pipes parent-child 관계가 아닌 프로세스도 접근 가능 Communication in Client-Server Systems Sockets RPCsSocket통신을 위한 종점socket = IP 주소 + port 번호 소켓 통신에서의 Java 쉬운 소켓 인터페이스를 제공 3가지 타입의 소켓 제공 Socket class: connection-oriented (TCP). 한 수신자. DatagramSocket class: connectionless (UDP). 여러(임의의) 수신자. 주로 방송에서 사용 MulticastSocket class: 여러(특정한) 수신자 RPC (Remote Procedure Call)네트워크 시스템에서 프로세스 간의 원격 호출을 추상화한 것원격 서비스의 흔한 형태 IPC의 확장개념 IPC : 한 개의 pc 안에서의 통신 RPC : 여러 개의 pc 사이의 원격 통신 RPC의 작동과정 클라이언트에게 stub을 제공해서 통신의 세부내역을 숨김 클라이언트측의 stub이 서버를 위치시키고 파라미터를 marshal marshal : 서버 간에 주고받을 데이터를 정렬하는 과정 서버측의 stub이 메시지를 받음 서버는 marshal된 파라미터를 unpack 서버에서 프로시저를 수행함 Ref.https://ko.wikipedia.org/wiki/생산자-소비자_문제https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/" }, { "title": "Push_swap ① Subject", "url": "/posts/push_swap1/", "categories": "42Seoul, Push_swap", "tags": "42seoul", "date": "2022-07-21 13:00:00 +0900", "snippet": "PdfSummary이 프로젝트에서는 가능한 최소 작업 수를 사용하여 제한된 명령어 집합으로 스택의 데이터를 정렬할 수 있다. 이를 성공하기 위해서는 다양한 유형의 알고리즘을 조작하고 최적화된 데이터 정렬에 가장 적합한 솔루션을 선택해야 한다.Objectives정렬 알고리즘을 작성하는 것은 개발자의 여정에서 매우 중요한 단계이다. 보통 이 때 복잡성(알고리즘 분석)의 개념을 처음 접하게 된다. 알고리즘 분석 : 알고리즘을 실행하는데 필요한 자원의 수를 결정하는 것정렬 알고리즘과 그 복잡성은 취업 면접에서 논의되는 고전적인 질문 중 하나이다. 이러한 개념은 언젠가는 직면해야 하기 때문에 지금 그 개념을 살펴보는 것은 좋은 시기일 것이다.이 프로젝트의 학습 목표는 정밀함, C의 사용 및 기본 알고리즘의 사용이다. 특히 복잡성에 초점을 맞추고 있다.값을 정렬하는 것은 간단하다. 가능한 가장 빠른 방법으로 분류하는 것은 덜 간단하다. 정수의 구성마다 가장 효율적인 정렬 솔루션이 다를 수 있기 때문이다.Mandatory partThe rules a, b라는 이름의 두 개의 스택이 있다. (스택 : 요소를 더하고 빼는게 제일 위에만 가능한 자료구조) 시작할 때: 스택 a에는 중복없는 양수 와/또는 음수가 임의의 개수만큼 있다. 스택 b는 비어있다. 목표는 스택 a에 오름차순으로 수를 배열하는 것이다. 이를 위해 아래의 작업을 원하는 대로 수행해야 한다. sa (swap a) : a의 제일 위 2개의 요소를 바꿈 sb (swap b) : b의 제일 위 2개의 요소를 바꿈 ss : sa와 sb를 동시에 진행 pa (push a) : b의 제일 위의 요소를 a의 제일 위로 이동. b가 비어있으면 아무것도 안함. pb (push b) : a의 제일 위의 요소를 b의 제일 위로 이동. a가 비어있으면 아무것도 안함. ra (rotate a) : a의 전체 요소를 위로 한 칸씩 올림. 제일 위에 있던 요소는 제일 아래로 이동. rb (rotate b) : b의 전체 요소를 위로 한 칸씩 올림. 제일 위에 있던 요소는 제일 아래로 이동. rr : ra와 rb를 동시에 진행 rra (reverse rotate a) : a의 전체 요소를 아래로 한 칸씩 내림. 제일 아래에 있던 요소는 제일 위로 이동. rrb (reverse rotate b) : b의 전체 요소를 아래로 한 칸씩 내림. 제일 아래에 있던 요소는 제일 위로 이동. rrr : rra와 rrb를 동시에 진행 The “push_swap” program 프로그램 이름 push_swap 제출 파일 Makefile, *.h, *.c 인자 stack a : 정수 리스트 외부 함수 read, write, malloc, free, exit, ft_printf를 포함해 본인이 작성한 코드 Libft 허용 여부 허용 설명 스택을 정렬함 프로젝트는 아래의 규칙을 준수해야 한다. 소스파일을 컴파일할 Makefile을 제출해야 한다. 이 Makefile은 리링크되어선 안된다. 전역변수는 금지된다. int형의 리스트로 이루어진 스택 a를 인자로 받는 push_swap이라는 프로그램을 작성해야 한다. 첫번째 인자는 제일 위에 위치하게 된다. (순서에 주의할 것) 프로그램은 스택 a를 작은 숫자가 제일 위로 가는 방식으로 만드는 가장 적은 수의 명령어 리스트를 표시해야 한다. 명령어는 '\\n' 로만 구분되어야 한다. 목표는 스택을 가장 적은 동작으로 정렬하는 것이다. 평가 과정에서 너의 프로그램이 찾은 명령어의 수는 한도(용납될 수 있는 최대의 수)와 비교될 것이다. 프로그램이 한도를 넘거나 수를 제대로 정렬하지 못한다면 0점을 받을 것이다. 인자가 주어지지 않았다면 아무것도 표시하지 않고 프롬프트를 반환해야 한다. 에러가 발생하면 “Error“와 개행문자를 표준 에러로 표시해야 한다. 에러는 다음 경우에 발생한다. 일부 인자가 int형이 아닌 경우 일부 인자가 int형보다 큰 경우 중복된 수가 있는 경우 평가 과정에서 프로그램을 체크하기 위해 바이너리가 제공된다. checker_OS가 KO를 표시하면 너의 push_swap이 수를 정렬하지 못했다는 것을 의미한다.Bonus part 프로그램 이름 checker 제출 파일 *.h, *.c 인자 stack a : 정수 리스트 외부 함수 read, write, malloc, free, exit, ft_printf를 포함해 본인이 작성한 코드 Libft 허용 여부 허용 설명 스택을 정렬함 스택 a의 수를 인자로 받는 checker라는 이름의 프로그램을 작성해라. 인자가 주어지지 않는다면 프로그램은 종료되고 아무것도 표시하지 않는다. 그 다음 프로그램은 기다린 후 표준 입력의 명령어(각 명령어 다음엔 개행문자가 옴)를 읽어들인다. 명령어를 읽고 난 후, 프로그램은 인자에 입력받은 명령어를 실행시킨다. 이 명령어들을 실행시킨 후에 스택 a가 정렬되고 스택 b가 비었다면 프로그램은 “OK“와 뒤의 개행문자를 표준 출력으로 표시한다. 이 외에 모든 경우, 뒤에 '\\n' 이 붙은 “KO“를 표준 출력으로 표시해야 한다. 에러가 발생한 경우 “Error“와 개행문자를 표준 에러로 표시해야한다. 에러는 다음의 경우 발생한다. 일부 인자가 int형이 아닌 경우 일부 인자가 int형보다 큰 경우 중복된 수가 있는 경우 명령어가 존재하지 않거나 제대로 포매팅되지 않은 경우 " }, { "title": "[운영 체제] 02. Operating-System Structures", "url": "/posts/os02/", "categories": "Computer Science, Operating System", "tags": "cs, os", "date": "2022-07-20 23:00:00 +0900", "snippet": "Operating System ServicesOS는 프로그램이 실행될 환경을 제공함 User interface Program execution I/O operation File-system manipulation Communications Error detection Resource allocation Logging Protection and securityUser and Operating-System Interface유저 인터페이스 CLI (Command Line Interface) shell로도 알려져 있음. 예시 : sh, bash, csh, tcsh, zsh 등 GUI (Graphical User Interface) 예시 : Windows, Aquia for MacOS, KDE/GNOME for Linux 등 Touch-Screen Interface 예시 : Android UI, iPhone UI 등 System Calls시스템 콜운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 API (Application Programming Interface) 정의 및 프로토콜 집합을 사용하여 두 소프트웨어 구성 요소가 서로 통신할 수 있게 하는 메커니즘 휴대폰의 날씨 앱을 예로 들면 API를 통해 기상청의 소프트웨어 시스템과 대화하여 기상 데이터를 받아와 날씨를 표시함 유저 애플리케이션을 통해 직접 open() 시스템 콜을 호출하는 경우 라이브러리를 통해 간접적으로 시스템 콜을 호출하는 경우 (위 방법에 비해 효율적임) 대표적인 시스템 콜의 종류 " }, { "title": "[운영 체제] 01. Introduction", "url": "/posts/os01/", "categories": "Computer Science, Operating System", "tags": "cs, os", "date": "2022-07-20 20:00:00 +0900", "snippet": "Operating System운영 체제컴퓨터의 하드웨어를 관리하는 소프트웨어컴퓨터 상에서 항상 가동되는 하나의 프로그램 커널 시스템 프로그램 애플리케이션 프로그램역할 애플리케이션 프로그램의 기반을 제공함 사용자와 하드웨어의 매개체 역할을 함부팅 과정 컴퓨터의 전원이 켜짐 CPU가 ROM의 부트스트랩 프로그램을 실행함 이 프로그램이 하드디스크에서 OS를 찾아 메인메모리에 가져옴컴퓨터 시스템의 구성 하드웨어 운영 체제 애플리케이션 프로그램 사용자 Computer System Organization현대 컴퓨터의 구성 한개 이상의 CPU 버스를 통해 연결된 다수의 디바이스 컨트롤러 인터럽트 (Interrupt)하드웨어가 CPU에게 신호를 보내는 것주로 시스템 버스를 통해 보낸다시스템 버스? 컴퓨터의 구성요소를 서로 연결하고 데이터를 전달하기 위한 경로 주소 버스, 데이터 버스, 제어 버스로 구성됨폰 노이만 구조명령-실행 주기 메모리에서 명령어를 fetch 해당 명령어를 명령 레지스터에 저장 명령어 decode 메모리에서 피연산자를 fetch 피연산자 (operand) : 연산의 대상. x + y 에서 + 는 연산자 (operator), x , y는 피연산자 (operands) 내부 레지스터에 저장 명령어 execute 결과값이 메모리에 다시 저장됨메모리 계층 구조 (Storage hierarchy)구성 기준 스토리지 용량 접근 속도일반적으로 스토리지의 가격&amp;접근속도와 용량은 반비례 관계임I/O 구조I/O : 입력(Input)/출력(Output)의 약자OS 코드 중 상당분이 I/O를 관리하기 위해 사용됨DMA(Direct memory access) : 입출력장치와 메모리 사이 데이터 흐름에서 CPU를 배제하기 위해 사용하는 입출력 제어 방식 (예시. 유튜브로 영상을 시청하는 경우 네트워크에서 데이터를 받아 모니터에 바로 출력하면 돼서 CPU의 개입이 필요없음)Computer System Architecture컴퓨터 시스템의 구성요소 CPU : 명령어를 실행시키는 하드웨어 프로세서 : CPU를 한개 이상 보유한 물리적 칩 코어 : CPU의 핵심 연산 장치 멀티코어 : 하나의 CPU가 여러개의 코어를 포함한 것 멀티프로세서 : 여러 프로세서를 포함한 것대칭형 다중 처리 (Symmetric multiprocessing, SMP) 2개 이상의 프로세서가 1개의 공유된 메모리를 사용하는 다중 프로세서 컴퓨터 아키텍처 데이터의 메모리 내 위치와 상관없이 프로세서가 접근 가능 여러 프로세서가 동일한 메모리에 접근시에는 1개만 접근 가능하고 나머지는 대기해야함 현재 사용되는 대부분의 다중 프로세서 시스템이 구성된 방식멀티 코어 디자인한 개의 프로세서 칩에 여러개의 코어가 들어있음Operating System Operations멀티프로그래밍한번에 다수의 프로그램을 실행해 CPU의 활용률을 높임멀티태스킹 (=멀티프로세싱)위의 멀티프로그래밍이 확장된 개념CPU가 작업을 매우 빈번하게 교체해서 사용자로 하여금 각 작업을 동시에 진행할 수 있게 하는 것. CPU 스케줄링 어떤 프로세스에 CPU를 배정할지를 결정하는 것 다수의 프로세스가 한번에 실행되려면 시스템이 각각의 프로세스마다의 실행순서를 지정해야함. 이럴 때 사용되는 것이 CPU 스케줄링. Operation mode리소스 접근 권한에 따라 크게 유저 모드와 커널 모드로 나뉘어짐 리소스 : 프로그램이 활용할 수 있는 데이터나 루틴유저 모드 사용자가 접근할 수 있는 영역을 제한적으로 두고 프로그램의 리소스에 침범하지 못하게 함 일반적으로 사용자가 작업을 하는 영역커널 모드 모든 리소스에 접근하여 명령을 할 수 있음모드 전환아래와 같이 특정 시스템 콜을 하는 경우 커널모드로 잠시 전환되었다가 유저모드로 돌아옴Virtualization가상화는 한 컴퓨터에서 다수의 실행환경을 추상화할 수 있게 함VMM (Virtual Machine Manager)VMware, XEN, WSL 등참고 : https://23tae.github.io/posts/born2beroot3/a : 한개의 OS를 실행하는 컴퓨터, b : VM을 통해 여러 OS를 실행하는 컴퓨터Computing Environments Traditional Computing Mobile Computing Client-Server Computing Peer-to-Peer Computing Cloud Computing Real-Time Embedded SystemsRef.https://www.inflearn.com/course/운영체제-공룡책-전공강의https://www.scaler.com/topics/operating-system/what-is-booting/https://ko.wikipedia.org/wiki/폰_노이만_구조" }, { "title": "[운영 체제] 00. 학습 계획", "url": "/posts/os00/", "categories": "Computer Science, Operating System", "tags": "계획", "date": "2022-07-19 00:00:00 +0900", "snippet": "학습 계획 매주 화, 목, 토 두 시간씩 학습 강의 → 교재강의 목차 섹션 0. 강의개요 실습을 위한 개발환경 구축 섹션 1. Chapter 1-2. Introduction &amp; O/S Structures 운영체제가 뭐길래? 운영체제의 개념과 구조 섹션 2. Chapter 3. Processes 프로세스의 이해 프로세스의 생성 프로세스간 통신 프로세스간 통신의 실제 섹션 3. Chapter 4. Thread &amp; Concurrency 쓰레드의 이해 멀티쓰레딩 섹션 4. Chapter 5. CPU Scheduling CPU 스케줄링 스케줄링 알고리즘 섹션 5. Chapter 6. Synchronization Tools 프로세스 동기화 동기화 문제의 해결책 뮤텍스와 세마포어 모니터와 자바 동기화 섹션 6. Chapter 7. Synchronization Examples 동시성 제어의 고전적 문제들 철학자들은 왜 굶어 죽었을까 철학자들의 저녁식사 Java qjwjs 섹션 7. Chapter 8. Deadlocks 데드락의 이해 데드락과 뱅커 알고리즘 섹션 8. Chapter 9. Main Memory 주메모리의 관리 페이징과 스와핑 섹션 9. Chapter 10. Virtual Memory 가상 메모리와 디맨드 페이징 페이지 교체 알고리즘 섹션 10. Chapter 11-15. Storage Management 스토리지와 입출력 섹션 11. Chapter 16-17. Security &amp; Protection 운영체제의 보안 교재 관련강의 : https://www.inflearn.com/course/운영체제-공룡책-전공강의교재 : Operating System Concepts" }, { "title": "Minitalk ④ 프로젝트 구현", "url": "/posts/minitalk4/", "categories": "42Seoul, Minitalk", "tags": "42seoul", "date": "2022-07-18 00:00:00 +0900", "snippet": "구현한 기능server server pid 출력 시그널 수신 메시지 출력 발송인의 pid 출력 받은 바이트 출력 메시지 수신 여부 출력client client pid 출력 연결 여부 출력 시그널 전송 보낸 바이트 출력 메시지 전송 성공 여부 출력방법 구상 server on client on client send message (str → char → bit → signal) server get message server print message server end방법 수정 3-way handshake를 활용해 연결 서버와 클라이언트가 시그널을 주고받으며 수신여부를 실시간으로 체크 메모리를 일정한 크기만큼 할당한 후 0으로 초기화해가며 사용첫 구현에서는 client가 연결 성공 여부를 확인하지 않고 바로 시그널을 전송하는 문제가 있었다. 이를 해결하기 위해 3-way handshake 방식을 활용해 연결 여부를 확인하였다.client가 server에게 시그널을 보내면 server는 받은 시그널에 1을 더해서 반송한다. client는 시그널이 제대로 수신되었는지를 확인한 후에 성공여부를 출력한다.시그널을 계속해서 보내게 되면 시그널이 잘못 수신되는 경우가 생기는데 이를 해결하기 위해 기존에는 usleep(100)과 같이 일정한 딜레이를 두어 시그널을 전송했다. 하지만 이러한 코드는 긴 메시지를 보낼 때 효율성이 떨어진다는 단점이 존재한다. 따라서 client가 매 시그널을 보낼 때마다 server도 이에 답하는 시그널을 보내 수신 여부를 체크하도록 했다.헤더 파일typedef struct s_data{\tstruct sigaction\taction_handshake;\tstruct sigaction\taction_transmission;\tpid_t\t\t\tpid;\tchar\t\t\t*message;\tint\t\t\tbyte;}\tt_data;위와 같은 구조체를 전역으로 선언해서 사용 sigaction 구조체 action_handshake : 3-way handshake를 통해 연결을 확인함 action_transmission : 들어오는 시그널을 받아서 메시지로 변환하거나 종료여부를 파악함 pid 메시지를 전송하려는 상대방의 Process ID를 저장함 PID : 운영체제가 프로세스를 식별하기 위해 부여한 번호 pid_t 자료형 pid를 저장하는 자료형 sys/types.h 에 선언됨 시스템에 따라 프로세스가 int형이 아닌 경우가 있을 수 있기 때문에 사용 message Client : 전송하려는 메시지를 저장함 Server : 수신하는 메시지를 출력하기 전까지 저장함 byte 송수신된 메시지의 바이트를 저장함 구성Serverserver.c init : 초기 설정 (각종 변수 초기화, sigaction 설정, 메모리 할당, 현재 Process ID 출력) handshake_synack : 3-way handshake 2단계. 받은 시그널에 1을 더한 시그널을 보낸 pid에게 전송server_transmit.c ft_receive_signal : 수신된 시그널을 처리할 함수를 호출 후 종료 여부 체크 signal_to_char : (수신된 시그널에 해당하는) 비트를 배열의 값에 더해줌 print_message : 메시지 출력utils.c ft_kill : kill 함수를 변형 ft_error : 에러 메시지 출력 후 종료Clientclient.c check_argument : 명령행 인자의 유효성 체크 init : 초기 설정 (각종 변수 초기화, sigaction 설정, 현재 Process ID 출력) handshake_syn : 3-way handshake 1단계. handshake_ack : 3-way handshake 3단계. 수신된 시그널을 확인해 연결의 성공여부 체크client_transmit.c ft_send_or_end : server가 보낸 시그널에 따라 종료 여부 결정 ft_send_message : 보낼 메시지를 바이트 단위로 쪼개서 함수 호출 send_signal : 해당 바이트의 각 비트 값에 따라 시그널 전송utils.c 위와 동일동작 과정Server 입력된 인자를 체크 init함수를 통해 각 변수를 초기화 sigaction 함수의 구조체를 설정(핸들러, 플래그, 마스크 등) message 포인터에 100만큼 메모리 할당한 후 0으로 채움 무한루프를 돌며 신호를 기다림 신호가 들어오면 핸들러인 handshake_synack가 실행되어 들어온 값에 1을 더해 client에 전송함 sigaction의 구조체를 변경해 메시지를 수신할 준비를 함 메시지가 들어오면 pid를 체크한 후에 이상이 있으면 들어온 시그널을 그대로 전송하거나 핸들러를 종료시킴 이상이 없으면 0번 인덱스부터 비트시프트를 통해 값을 채워나감. (이때, 시그널 하나를 받을때마다 client에 종료여부를 시그널로 보냄) 널문자를 만나면 문자를 출력한 후에 세부사항을 출력하고 sigaction의 구조체를 변경한 후 종료신호를 보냄 100칸을 다 채웠다면 문자를 출력하고 다시 입력을 받음Client 입력한 인자를 체크한 후 pid에 저장함 init함수로 변수들을 초기화해준 후 sigaction함수에 handshake 구조체를 설정함 pid에 SIGUSR1을 송신함 보내준 시그널에 1이 더해진 값이 수신되면 handshake 성공 들어온 값이 다르거나 수신된 pid가 다르면 일정횟수동안 다시 연결을 시도한 후 종료 send_message 함수를 통해 message를 비트단위로 쪼개어 시그널을 전송 (해당 자리의 비트가 1이면 USR1을, 0이면 USR2를 전송함) 보낸 pid로부터 메시지를 받았다는 시그널을 받으면 종료여부에 따라 이어서 전송하거나(SIGUSR1) 전송을 종료함(SIGUSR2) 전송을 마치면 전송한 바이트와 성공 메시지를 출력함예외 처리Server 명령행 인자가 들어옴 시그널을 보낸 발송인의 pid가 기존에 메시지를 보내던 client가 아닌 경우Client 명령행 인자가 ./client [PID] [Message] 의 형태가 아님 명령행 인자의 pid가 유효하지 않음(정수가 아닌 경우) 명령행 인자의 pid가 유효하지 않음(server의 pid가 아닌 경우)테스트 일반 메시지 (메시지에 공백이 있으면 큰따옴표로 묶어서 입력해야함) hello world 100자 메시지 LoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumd 500자 LoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdoLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdoLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdoLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdoLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumdolorsitametLoremipsumd 유니코드 1 😀🐶🍎🏀🚗💡 유니코드 2 메시지테스트 평가 후기부족한 개념 sigaction 함수와 시그널 핸들러 (세 번째 매개변수의 역할) sigemptyset, sigaddset의 사용 방법 makefile (헤더파일 include, addprefix, patsubst 등)개선할 부분 첫글자가 다르게 출력되는 케이스가 존재 kill 함수를 통해 시그널을 주고받을 때 딜레이를 전혀 주지 않아서 생기는 문제로 보임 ft_kill 함수를 정의하여 시그널을 전송하기 전에 usleep으로 10마이크로초만큼의 딜레이를 발생시킴 Ref.https://velog.io/@bahn/Minitalk" }, { "title": "Minitalk ③ 배경 지식 : 기타", "url": "/posts/minitalk3/", "categories": "42Seoul, Minitalk", "tags": "42seoul", "date": "2022-07-13 00:00:00 +0900", "snippet": "데이터 통신두개의 직접 연결된 디바이스가 데이터를 교환하는 것채널 개수로 구분데이터는 비트의 형태로 디바이스 사이를 이동함 직렬 통신 (Serial Transmission) 병렬 통신 (Parallel Transmission)직렬 통신 (Serial Transmission)한개의 채널을 사용해 한 비트씩 순서대로 이동시키는 방식비동기 직렬 통신 (Asynchronous Serial Transmission)데이터 비트가 언제든지 전송될 수 있음start bits와 stop bits가 데이터 바이트의 양 끝에 함께 보내져서 수신이 제대로 이루어졌음을 보장해줌데이터 비트를 주고받는 시간은 일정하지 않음. → 전송 시간 사이에 gaps가 사용됨 원리 통신을 하지 않는동안은 통신회선이 항상 1로 유지됨 시작비트인 0이 들어와 회선의 상태가 변하면 데이터를 수신하기 시작함 8비트를 모두 수신하면 정지비트를 수신하고 통신을 종료함 장점 송수신자 사이에 동기화가 필요 없음 비용 효율이 높음 단점 전송 속도가 느려질 수 있음(항상 그런 것은 아님) 동기 직렬 통신 (synchronous Serial Transmission)master의 clock신호에 맞춰서 연속적으로 데이터 비트가 이동함송수신자는 동기화된 clock을 사용함 → start bits, stop bits, gaps가 필요없음 동기화 : 송수신자간의 신호의 타이밍을 맞추어 정확한 송수신이 가능하도록 하는 것 장점 데이터 전송 속도가 빠르고 타이밍 에러가 적게 발생함 단점 데이터의 정확도가 동기화 정도의 영향을 받음 비용 효율이 낮음 사용되는 곳 장거리 데이터 통신 데이터의 양이 상대적으로 적은 경우 데이터의 무결성(변경 및 파괴되지 않은 상태)을 보장함병렬 통신 (Parallel Transmission)다중 채널을 사용해 여러 데이터 비트를 한번에 이동시키는 방식장단점 장점 프로그래밍하기 쉬움 데이터 전송 속도가 빠름 단점 여러 채널을 사용하기 때문에 싱크가 안맞을 수 있음 사용되는 곳 데이터의 양이 많은 경우 시급한 데이터인 경우 예시) 비디오 스트리밍통신 방향으로 구분 단방향 (Simplex) 반이중 (Half Duplex) 전이중 (Full Duplex)   단방향 (Simplex) 반이중 (Half Duplex) 전이중 (Full Duplex) 통신방향 단방향 (Unidirectional) 쌍방향 (Two-directional, One by one) 양방향 (Bi-directional, Simultaneously) Sender의 동작 Sender는 데이터만 전송할 수 있음 Sender는 데이터를 하나씩 주고받을 수 있음 Sender는 데이터를 동시에 주고받을 수 있음 성능 나쁨 보통 좋음 sigactionsigaction 함수int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);signal 함수보다 다양한 기능을 지원하는 함수 헤더 : signal.h 매개변수 sig : 시그널 번호 act : 새롭게 설정할 행동 oact : 이전에 지정했던 행동 반환값 0 : 성공 -1 : 실패 sigaction 구조체struct sigaction {\t\tunion __sigaction_u __sigaction_u; // 시그널 핸들러\t\tsigset_t sa_mask; // 시그널을 처리하는 동안 블록화할 시그널 집합의 마스크\t\tint sa_flags; // 아래 설명 참고};union __sigaction_u { void (*__sa_handler)(int); // 시그널을 처리할 핸들러 void (*__sa_sigaction)(int, siginfo_t *, void *); // sa_handler 대신에 동작할 핸들러};sigaction 함수를 사용하기 위해 해당 구조체를 선언해야함sa_handler, sa_sigaction두 멤버 모두 시그널이 들어왔을 때 해당 시그널을 처리할 핸들러를 지정sa_flags = SA_SIGINFO 일 경우 sa_handler 대신 sa_sigaction이 동작함sa_mask핸들러의 동작 중 처리를 블록할 signal_set을 지정함sa_flags다양한 옵션을 통해 sigaction의 핸들러가 동작하는 방식을 관리함flag는 signal.h에 위와 같이 정의되어있음 옵션 의미 SA_NOCLDSTOP signum이 SIGCHILD일 경우, 자식 프로세스가 멈추었을 때, 부모 프로세스에 SIGCHILD가 전달되지 않는다. SA_ONESHOT 시그널을 받으면 설정된 행도을 취하고 시스템 기본 설정인 SIG_DFL로 재설정된다. SA_RESETHAND 위와 동일 SA_RESTART 시그널 처리에 의해 방해 받은 시스템 호출은 시그널 처리가 끝나면 재시작한다. SA_NOMASK 시그널을 처리하는 동안에 전달되는 시그널은 블록되지 않는다. SA_NODEFER 위와 동일 SA_SIGINFO 이 옵션이 사용되면 sa_handler대신에 sa_sigaction이 동작되며, sa_handler 보다 더 다양한 인수를 받을 수 있습니다. sa_sigaction이 받는 인수에는 시그널 번호, 시그널이 만들어진 이유, 시그널을 받는 프로세스의 정보입니다. test_sigaction.sa_flags = SA_SIGINFO | SA_NODEFER;위와 같이 비트 OR 연산자를 사용해 여러가지 flag를 적용할 수 있음exit 함수void exit(int status); 아래의 작업을 거친 후 프로세스를 종료시킴 atexit(3) 함수에 등록된 함수를 등록된 역순으로 호출합니다. 열려 있는 모든 출력 스트림을 flush(버퍼를 비우는 것)합니다. 열려 있는 스트림을 모두 닫습니다. tmpfile(3) 함수로 작성된 모든 파일의 연결을 해제합니다. 인자로 받은 status는 운영체제에 전달함 0 : 정상 종료, 0 이외의 값 : 에러 발생 return과의 차이 return은 함수를 종료하는 키워드 exit은 프로그램을 종료하는 함수 main문에서의 동작은 동일하지만 다른 함수에서는 동작이 다름Unicode전 세계의 모든 문자를 컴퓨터에서 일관되게 다룰 수 있도록 설계된 산업 표준매핑 방식 유니코드 변환 형식 (Unicode Transformation Format, UTF) 인코딩 UTF-1 UTF-7 UTF-8 UTF-EBCDIC UTF-16 UTF-32 국제 문자 세트 (Universal Coded Character Set, UCS) 인코딩UTF-8 (Unicode)유니코드를 위한 가변 길이 문자 인코딩 방식인코딩유니코드 한 문자를 나타내기 위해 1 ~ 4 바이트를 사용함. 사용할 바이트는 코드의 범위에 따라 다름(하단 표 참고).설계 원칙 1바이트로 표시된 문자의 최상위 비트는 항상 0이다. 2바이트 이상으로 표시된 문자의 경우, 첫 바이트의 상위 비트들이 그 문자를 표시하는 데 필요한 바이트 수를 결정한다. 예를 들어서 2바이트는 110으로 시작하고, 3바이트는 1110으로 시작한다. 첫 바이트가 아닌 나머지 바이트들은 상위 2비트가 항상 10이다.Ref.https://www.quantil.com/content-delivery-insights/content-acceleration/data-transmission/https://m.blog.naver.com/cjsksk3113/222009286458https://codingdog.tistory.com/entry/c언어-signal-함수-선언부를-해석해-봅시다https://badayak.com/entry/C언어-시그널-처리-함수-sigactionhttps://ko.wikipedia.org/wiki/UTF-8https://en.wikipedia.org/wiki/UTF-8" }, { "title": "Minitalk ② 배경 지식 : 시그널", "url": "/posts/minitalk2/", "categories": "42Seoul, Minitalk", "tags": "42seoul", "date": "2022-07-10 00:00:00 +0900", "snippet": "시그널이란비동기적으로 발생한 이벤트를 처리하기 위한 메커니즘을 제공하기 위한 소프트웨어 인터럽트 인터럽트 : 예상하지 못한 이벤트 인터럽트 핸들링시그널의 라이프사이클 발생 프로그램에서 발생한 예외적 사항 사용자의 입력 프로세스 또는 커널에서 생성/전달 보관 시그널 전달 전까지, 커널이 보관 전달 가능해지면 해당 프로세스에게 전달 처리 지정된 방법에 따라 시그널 처리 시그널을 무시함 시그널을 캐치해서 핸들링함 디폴트 액션을 함 (정의해 놓지 않은 경우) 유닉스 계열에서의 시그널심볼릭 상수상수로 정의됨 (ex. SIGHUP : 1, SIGINT : 2, … ) signal.h 라이브러리에 정의됨 man signal에서 확인가능 시스템별로 번호가 다를 수 있음맥에서는 위와 같이 정의가 되어있음. 과제에서 허용된 시그널인 SIGUSR1, SIGUSR2의 경우 각각 30, 31로 정의되어있음.시그널 처리Signal handler 특정 시그널을 처리하기 위해 지정된 함수 Default handler을 대체할 수 있음 (단, SIGKILL, SIGSTOP은 예외)signal 함수시그널이 들어올 때 처리해줄 핸들러를 등록하는 것. 이 자체만으로는 특별한 동작을 하진 않음!typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); 매개변수 signum : 처리할 시그널의 번호 handler : 시그널 핸들러의 함수포인터 반환값 기존 핸들러의 함수포인터 SIG_ERR : 에러 handler 등록예제 코드#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sigint_handler(int signo){ printf(\"Caught SIGINT!\\n\"); psignal(signo, \"Received signal\");}int main(void){ if (signal(SIGINT, sigint_handler) == SIG_ERR) { fprintf(stderr, \"Cannot handle SIGINT!\\n\"); exit(EXIT_FAILURE); } for (;;) pause(); // pause(2) : waiting a signal (any signal) return 0;}위 코드를 실행시킨 후 ctrl + c 를 누르면 아래의 메시지가 출력됨실행 결과^CCaught SIGINT!Received signal: Interrupt이 상태에서 종료하고 싶으면 ctrl + z (SIGTSTP)로 백그라운드로 이동해서 ps로 pid를 확인해서 kill -9 &lt;pid&gt; (9 : SIGKILL)로 종료시키면 됨kill -9 87116[1] + 87116 killed ./a.outhandler, signal 상속 방법On fork() 시그널 처리 방식 상속받음 signal handler, ignore, default pending 시그널은 상속 x 해당 시그널은 부모에게 전달된 것임 pending signal : 아직 처리되지 않은 시그널 On exec() signal handler 상속 x ignore, default는 상속받음 pending signal 상속시그널 전송관련 함수int kill(pid_t pid, int signo)프로세스에 시그널을 보냄 매개변수 pid : 시그널을 보낼 대상 0 : 자신이 속한 프로세스 그룹 내 모든 프로세스 -1 : 현재 프로세스가 가진 권한으로 시그널을 보낼 수 잇는 모든 프로세스 -1보다 작은 값 : GID == pid 인 프로세스 그룹 signo : 보낼 시그널 번호 리턴값 0 : Success -1 : Fail errno = EINVAL : 유효하지 않은 signo errno = EPERM : 시그널을 보낼 권한이 없음 errno = ESRCH : 대상 프로세스가 존재하지 않음 (또는 zombie process) zombie process : 프로세스가 종료되었는데 시스템상에 해당 정보가 남아있는 경우 전송 권한다른 프로세스에게 시그널을 보내기 위해서는 적합한 권한이 필요함필요 권한 Sender’s RUID/EUID == Receiver’s RUID/SUID root는 모든 프로세스에게 시그널 전달 가능권한 체크 null signal 활용 (실제 시그널을 전달하지 않으나 error checking을 수행함)int ret;ret = kill(1722, 0);if (ret != 0)\t// 권한 없음else\t// 권한 있음시그널 차단필요한 이유 시그널은 임의의 순간 발생함 (중요 작업을 하는 중에 시그널이 들어올 수 있음) 위처럼 Critical region의 보호를 위해 시그널의 차단이 필요함Signal set 복수개의 시그널을 처리하기 위해 사용 sigset_t (=bit mask) : 각 비트가 시그널 번호와 1대 1 매핑예제 코드// initint sigemptyset(sigset_t *set); // the set to emptyint sigfillset(sigset_t *set); // the set to full// add/delete signum to the setint sigaddset(sigset_t *set, int signum);int sigdelset(sigset_t *set, int signum);// return 1 if signum is in the setint sigismember(const sigset_t *set, int signum);관련 함수int sigprocmask (int how, const sigset_t *set, sigset_t *oldset);시그널을 블록시킬지 말지를 결정함 매개변수 how : 지정방법 SIG_SETMASK : set을 blocking mask로 적용 SIG_BLOCK : blocking 대상을 추가 SIG_UNBLOCK : blocking 대상에서 제거 set : 적용할 signal set NULL : how를 무시(signal mask 유지), 현재 signal mask → oldset oldset : 적용 전 signal set을 반환 리턴값 0: 성공 -1 : 실패 pending signal은 차단이 풀리면 전달됨예제 코드#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void handler_SIGINT(int _signo){ printf(\"Received Signal : %s\\n\", strsignal(_signo));}int main(void){ sigset_t new; if (signal(SIGINT, handler_SIGINT) == SIG_ERR) { perror(\"signal SIGINT\"); exit(1); } sigemptyset(&amp;new); sigaddset(&amp;new, SIGINT); sigaddset(&amp;new, SIGQUIT); sigprocmask(SIG_BLOCK, &amp;new, (sigset_t *)NULL); sleep(5); printf(\"UnBlocking Signals\\n\"); sigprocmask(SIG_UNBLOCK, &amp;new, (sigset_t *)NULL); return 0;}위 코드를 실행한 후에 SIGINT를 주면 아래와 같이 5초간은 신호가 가지 않다가 5초 후에 신호를 받는 것을 알 수 있음.실행 결과^CUnBlocking SignalsReceived Signal : Interrupt: 2시그널 대기관련 함수int sigsuspend(const sigset_t *mask);Signal mask를 임시 교체 후, block 되지 않은 시그널이 도착할 때 까지 대기함 매개변수 mask : 교체할 signal set의 주소 반환값 항상 -1 errno = EINTR → signal에 의해 interrupt 발생 예제 코드#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;void handler(int signo) { psignal(signo, \"Received Signal:\");}int main(void) { sigset_t set; signal(SIGALRM, handler); sigfillset(&amp;set); sigdelset(&amp;set, SIGALRM); alarm(3); printf(\"Wait...\\n\"); sigsuspend(&amp;set); return 0;}실행 결과Wait...Received Signal:: Alarm clockRef.https://www.youtube.com/watch?v=ezVbjE29Lpg" }, { "title": "함수 포인터", "url": "/posts/function_pointer/", "categories": "TIL", "tags": "c", "date": "2022-07-08 00:00:00 +0900", "snippet": "개요함수를 가리키는 포인터함수를 배열 또는 구조체에 넣거나, 함수 자체를 함수의 매개변수로 넘겨주고, 반환값으로 가져오기 위해 사용됨.특징 함수 포인터도 포인터이기 때문에, 일반적인 포인터와 마찬가지로 메모리 주소를 가리킴. 하지만 일반적인 포인터와 달리, 함수 포인터는 데이터가 아닌 코드의 위치를 가리킴. 함수 포인터는 코드의 시작부분을 가리킴. (배열을 가리키는 포인터가 첫번째 값을 가리키는 것과 같음) 함수 포인터를 통해 메모리를 할당하거나 회수하는 것은 불가능. → 함수 포인터를 대상으로 malloc(), free() 함수 사용 불가.사용 예시매개변수가 없는 경우반환값자료형 (*함수포인터이름)(); void hello() 함수가 있을 때, void(*fp)(); 형태로 함수 포인터 선언 fp = hello; 형태로 포인터에 함수 주소 저장.(함수이름이 포인터이므로 이름만 쓰면 됨.) fp = hello; : hello 함수의 메모리 주소를 함수 포인터 fp에 저장 fp(); 형태로 호출매개변수가 있는 경우반환값자료형 (*함수포인터이름)(매개변수자료형1, 매개변수자료형2);int add(int a, int b) // int형 반환값, int형 매개변수 두 개{ return a + b;}int (*fp)(int, int); int형 반환값, int형 매개변수 두 개가 있는 함수 포인터 fp 선언Ref.https://dojang.io/mod/page/view.php?id=592https://aahc.tistory.com/17" }, { "title": "Minitalk ① Subject", "url": "/posts/minitalk1/", "categories": "42Seoul, Minitalk", "tags": "42seoul", "date": "2022-07-05 00:00:00 +0900", "snippet": "PdfSummary이번 프로젝트에서는 유닉스 시그널을 통해 소규모의 데이터를 교환하는 프로그램을 구현합니다.Mandatory Part 클라이언트와 서버의 형태로 통신 프로그램을 만들어야 합니다. 서버가 먼저 시작돼고 그 후에 해당 PID를 나타내야 합니다. 클라이언트는 다음과 같은 매개 변수를 사용합니다. 서버 PID 전송해야 하는 문자열 클라이언트는 매개 변수로 전달된 문자열을 서버에 전달해야 합니다. 문자열이 수신되면 서버에서 해당 문자열을 표시해야 합니다. 프로그램 간의 통신은 UNIX 신호를 통해서만 이루어져야 합니다. 서버는 문자열을 매우 빠르게 표시할 수 있어야 합니다. 즉, 너무 길다고 생각되면 너무 긴겁니다. (Hint: 100자를 보낼 때 1초가 걸린다면 엄청 긴겁니다) 서버는 재시작할 필요 없이 여러 클라이언트로부터 연속적으로 문자열을 수신할 수 있어야 합니다. SIGUSR1 과 SIGUSR2 신호만 사용할 수 있습니다.이 유형의 보류 중인 신호가 이미 있을 경우 Linux 시스템이 신호를 대기열에 넣지 않습니다! 보너스 타임?Bonus Part 서버는 클라이언트에 신호를 전송하여 수신된 모든 신호를 확인합니다. 유니코드 문자를 지원합니다!주의 사항 실행 파일의 이름은 client와 server로 지정해야 한다. 오류를 민감하게 처리해야 한다. 프로그램이 예기치 않게 종료되면 안된다. (segmentation fault, bus error, double free, 등) 프로그램에 메모리 누수가 있으면 안된다. 하나의 전역 변수를 사용할 수 있지만 이유가 합리적이어야 한다. Manadatory part 허용 함수 목록 : write ft_printf and any equivalent YOU coded signal sigemptyset : initializes a signal set to be empty sigaddset : adds the specified signal signo to the signal set. sigaction kill : send signal to a process getpid malloc free pause sleep usleep exit " }, { "title": "Born2beroot ⑥ 체크 사항", "url": "/posts/born2beroot6/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-07-04 00:00:00 +0900", "snippet": "General git clone → signature.txt가 루트에 위치해 있는지 signature.txt diff 미리 스냅샷 찍어두기(과제 제출 직전에) VM실행MandatoryOverview vm의 역할, 이점 설명 자신이 선택한 OS centos vs debian 차이점 centos 선택자 → SELinux, DNF 개념 설명 debian 선택자 → APParmor, apt vs aptitude 개념 설명Setup gui 환경이면 안됨 로그인하면 루트가 아니라 유저인가 UFW 실행여부 SSH 적용여부 OS가 centos 또는 debian인가User 유저가 sudo, user42 그룹에 속해있는지 새 유저 생성 암호 할당 암호 규칙 설정한 방법 생성과정에서 수정된 파일 1~2개 evaluating 그룹 생성 후 새 유저를 해당그룹에 할당 암호 정책의 이점. ???의 장단점.Hostname and Partitions 머신의 호스트명이 [username]42 형태인지 호스트명 변경 ([평가자명]42 형태로) 후 머신 재시작. 제대로 변경됐는지 확인 마치면 다시 복원. VM의 파티션 확인 방법 서브젝트의 예시(보너스까지 했으면 그 예시로)와 일치하는지 확인 LVM 동작방식 설명sudo VM에 sudo 설치 여부 새 유저를 sudo 그룹에 할당 sudo의 가치와 작동을 예시로 설명 /var/log/sudo/ 디렉터리의 존재여부(파일이 최소 1개 이상 존재) sudo 명령 사용 후 위 디렉터리의 업데이트 여부UFW VM에 UFW 설치 여부 UFW 작동 여부 UFW의 개념과 이점 활성화 된 규칙 확인(4242 존재여부) 새로운 포트8080을 규칙에 추가. 위의 방식으로 반영 여부 확인. 해당 규칙을 제거SSH VM에 SSH 설치 여부 SSH 작동 여부 SSH의 개념과 이점 SSH 서비스가 4242 포트만 사용하는지 확인 새 유저로 SSH 로그인(root로 SSH를 사용하면 안됨)Script monitoring 해당 코드 보여주며 작동 설명 cron 개념 매 10분마다 작동하게 설정한 방법 30초마다 작동되게 변경 중단시키고 재부팅했을때 켜지지 않아야 함(스크립트 편집하지 않은채로)Bonus 파티션 설정 여부 워드프레스 셋업 여부 free choice service(?), 서비스 작동 방식, 유용한 이유 설명" }, { "title": "Born2beroot ⑤ 프로젝트 구현 (Bonus part)", "url": "/posts/born2beroot5/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-07-02 00:00:00 +0900", "snippet": "WordPress 구축WordPress를 웹에 구축하기 위해 PHP, lighttpd, MariaDB의 설치가 필요함 PHP 대표적인 서버 사이드 스크립트 언어 웹개발에 특화됨. 서버 사이드 언어? 온라인 기반 서비스를 백엔드와 프론트엔드로 구분하였을 때, 백엔드에서 서버 동작을 정의하기 위한 언어 lighttpd 저자원 고성능의 오픈소스 웹서버 애플리케이션 속도가 빠르며 용량이 낮음. MariaDB 오픈소스 RDBMS. MySQL 출신 개발자들이 개발. 우분투, 데비안, RHEL, 페도라 등에서 기본DB로 지원.lighttpd 설정 lighttpd 웹서버 설치 sudo apt install lighttpd -y lighttpd 관련 명령어 sudo systemctl start lighttpd.service\t# 서버 시작 sudo systemctl stop lighttpd.service\t# 서버 중지 sudo systemctl enable lighttpd.service\t# 부팅시 서버 시작 PHP 설정 PHP-FPM(PHP FastCGI Process Manager)설치 sudo apt install php7.4-fpm PHP-FPM : 하나의 프로세스로 요청을 처리하여 프로세스를 생성, 제거하는 부하를 경감해줌. php.ini 파일 내용 수정 vim /etc/php/7.4/fpm/php.ini cgi.fix_pathinfo=1 부분 주석 해제 Fastcgi 파일 내용 수정 vim /etc/lighttpd/conf-available/15-fastcgi-php.conf bin-path, socket 행 주석처리 \"socket\" =&gt; \"/var/run/php/php7.4-fpm.sock\", 추가 변경사항 적용 후 lighttpd 재시작 sudo lighttpd-enable-mod fastcgi sudo lighttpd-enable-mod fastcgi-php service lighttpd force-reload ufw 방화벽의 웹서버용 포트 허용 ufw allow 80 포트포워딩 가상머신의 환경설정을 통해 포트포워딩 규칙 추가. Host Port : 8000(임의로) Guest Port : 80(위에서 허용한 포트) 이후 http://localhost:8000 (또는 http://127.0.0.1:8000)에 접속하면 아래와 같은 화면을 볼 수 있음. PHP 연동 확인 vim /var/www/html/info.php 으로 아래 내용 입력한 뒤, http://localhost:8000/info.php 접속 &lt;?php \tphpinfo(); ?&gt; 위와 같이 FPM/FastCGI가 제대로 적용되었음을 알 수 있음. MariaDB와 연동할 패키지 설치 sudo apt install php7.4-mysqlMariaDB 설정 DB 설치 sudo apt install mariadb-server mariadb-client DB 관련 명령어 sudo systemctl start mysql.service\t# DB 시작 sudo systemctl stop mysql.service\t# DB 중지 sudo systemctl enable mysql.service\t# 부팅시 DB 시작 DB 보안설정 sudo mysql_secure_installation 비밀번호 설정이 처음이면 current pw는 엔터로 넘기고 뒤에서 등록. 대부분 Y로 설정. sudo systemctl restart mysql.service 로 DB 재시작 WordPress에 연동할 DB 생성 sudo mysql -u root -p : 비밀번호 입력 후 mysql 진입 CREATE DATABASE [dbname]; -- DB 생성 CREATE USER '[username]'@'localhost' IDENTIFIED BY '[password]'; -- 계정 및 패스워드 생성 GRANT ALL ON [dbname].* TO '[username]'@'localhost' IDENTIFIED BY '[passwd]' WITH GRANT OPTION; -- 생성한 DB에 대해 생성한 계정에 full access 부여 FLUSH PRIVILEGES; -- 설정 종료 EXIT; -- 종료 위의 SQL문법을 사용해 아래와 같이 DB생성 CREATE DATABASE mydb; CREATE USER 'taehooki'@'localhost' IDENTIFIED BY 'db-pw'; GRANT ALL ON mydb.* TO 'taehooki'@'localhost' IDENTIFIED BY 'db-pw' WITH GRANT OPTION; FLUSH PRIVILEGES; EXIT; WordPress 설정 WordPress 설치 lighttpd.conf에 나와있는 경로인 /var/www/html에 wordpress를 설치. sudo apt install wget # wget 설치 sudo wget -O /tmp/wordpress.tar.gz \"http://wordpress.org/latest.tar.gz\" # WP 압축파일 다운로드 sudo tar -xvzf /tmp/wordpress.tar.gz -C /var/www/html # 해당 압축파일을 원하는 경로에 설치 wget(Web Get) : 웹 상의 파일을 받을 때 사용하는 명령어 설치를 마치고 http://localhost:8000/wordpress 에 접속하면 아래와 같이 DB를 생성하라는 화면이 보임.이 페이지에서 DB를 직접 생성하는 대신 위에서 생성한 DB를 연결. WordPress - MariaDB 연동 vim /var/www/html/wordpress/wp-config-sample.php db이름, db유저명, db암호를 위에서 설정한 대로 변경 아래에 auth key 설정하는 부분은 아래의 주소로 접속해서 키를 생성한 뒤 그대로 입력하면 됨. (주의사항 : 다시 접속하면 새로 생성됨!) https://api.wordpress.org/secret-key/1.1/salt/ 저장 후 파일명을 아래와 같이 wp-config.php로 변경 mv /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php http://localhost:8000/wordpress/ 재접속계정 설정사이트 생성 완료사이트 설정http://localhost:8000/wordpress/ 에 재접속하면 다음과 같은 화면이 나옴.FTP 설정 미완성 vsftpd 설치 sudo apt install vsftpd dpkg -l | grep vsftpd : 설치 확인 21번 포트를 통한 incoming 접속 허용 sudo ufw allow 21 포트포워딩 가상머신의 환경설정을 통해 포트포워딩 규칙 추가. Host Port : 7000(임의로) Guest Port : 21(위에서 허용한 포트) vsftpd 설정 FTP 쓰기 명령 허용 sudo vim /etc/vsftpd.conf 위와 같이 31번줄의 write_enable=YES를 주석해제. FTP 연결의 루트 폴더를 특정 유저로 설정 sudo mkdir -p /home/[username]/ftp/files 디렉토리 소유권 변경 root 계정으로 생성한 폴더는 사용자가 이미지를 업로드하는 등의 이용이 불가능하므로 권한을 root에서 nobody로 변경하는 것. sudo chown nobody:nogroup /home/[username]/ftp 모든 사용자에게서 쓰기권한 제거 sudo chmod a-w /home/[username]/ftp sudo vim /etc/vsftpd.conf 마지막에 아래 내용 추가 user_sub_token=$USER local_root=/home/$USER/ftp 유저가 파일에 접근하거나 디렉토리 트리(?) 밖에서 명령하는것을 제한. sudo vim /etc/vsftpd.conf 114번줄의 chroot_local_user=YES 주석 해제 FTP 화이트리스트 지정 sudo touch /etc/vsftpd.userlist echo &lt;username&gt; | sudo tee -a /etc/vsftpd.userlist sudo vim /etc/vsftpd.userlist 아래 내용 추가 userlist_enable=YES userlist_file=/etc/vsftpd.userlist userlist_deny=NO vsftpd.conf 수정 sudo vim /etc/vsftpd.conf 에서 마지막에 아래 내용 추가 pasv_enable=Yes pasv_max_port=11001 pasv_min_port=11050 FTP를 통해 서버 접속 로컬 cmd에서 아래와 같이 입력해서 VM에 FTP로 연결 ftp open 127.0.0.1. 7000 # open &lt;ip address&gt; &lt;port&gt; close 입력해서 세션 종료 후, bye 입력해서 ftp 종료. 파일 송수신 cd files # ~/ftp/files/ 로 파일 경로 설정 put d:\\[dirname]~\\[filename] # 파일 업로드 앞부분까지는 잘 되다가 파일 업로드를 하려고 하면 아래와 같은 에러가 발생함. 500 Illegal PORT command. 425 Use PORT or PASV first. Ref.https://velog.io/@jen133/b2br-Wordpress-구축https://github.com/hanshazairi/42-born2beroot" }, { "title": "Born2beroot ④ 프로젝트 구현 (Mandatory part)", "url": "/posts/born2beroot4/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-06-29 00:00:00 +0900", "snippet": "sudo 설정visudo를 사용해 sudoers 파일의 아래 내용 편집Defaults secure_path=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\"Defaults authfail_message=\"Authenticate failed.\"Defaults badpass_message=\"Password failed.\"Defaults log_inputDefaults log_outputDefaults requirettyDefaults iolog_dir=\"/var/log/sudo/\"Defaults passwd_tries=3 authfail_message : sudo 인증 실패 시 출력 메시지 badpads_message : sudo 인증에서 비밀번호 불일치 시 출력 메시지 log_input : log에 sudo로 사용한 input 내용 저장 log_output : log에 sudo로 출력된 output 내용 저장 requiretty : 현재 shell이 tty 인지 아닌지에 따라 sudo의 허가여부 결정 iolog_dir : sudo log 저장 경로 설정 passwd_tries : sudo 실행 횟수 설정사용자 설정유저 관리sudo useradd -m [username] # 새유저 및 해당 홈디렉토리 생성passwd [username] # 패스워드 설정grep /bin/bash /etc/passwd | cut -f1 -d:# useradd로 추가했던 유저 목록userdel [username] [groupname] # 유저를 해당 그룹에서 제거userdel -r [username] # 유저의 모든 정보 삭제그룹 관리groupadd user42 # user42그룹을 추가groupdel [groupname] # 그룹 삭제usermod -G user42,sudo [username] # 유저를 user42, sudo그룹에 추가.(나머지 그룹에서는 제거)usermod -aG user42,sudo [username] # 유저를 user42, sudo그룹에 추가. (나머지 그룹에서도 유지)usermod -g user42 [username] # user42를 유저의 primary group으로 만듦.id [username] # 유저의 그룹 정보를 보여줌 계정을 sudo그룹에 넣으면 sudo 권한이 부여됨.사용자 정보/etc/passwd 시스템 관리자가 유저를 생성할때마다 관련 정보를 저장 각 필드별로 아래와 같은 의미를 가짐[user_account]:[user_pw]:[user_id]:[group_id]:[comment]:[home_dir]:[login_shell]cut -f1 -d: /etc/passwd : 사용자 계정만 출력.내가 생성하지 않았는데 보이는 다양한 계정(daemon, bin, sys, man 등) → 시스템 계정 시스템 계정 시스템의 필요에 의해 생성된 계정 리눅스는 파일이나 프로세스 생성 시 반드시 소유자를 명시하게 되는데 모든 시스템에 대해 root 권한을 부여할 시에 생길 수 있는 시스템 손상의 문제를 시스템 계정을 통해 방지 할 수 있음.호스트 정보hostname # hostname 확인hostname [new name] # 임시 hostname 변경sudo hostnamectl set-hostname [new name] # static hostname 변경sudo systemctl reboot # 시스템 reboot패스워드 정책 설정설정 1sudo vim /etc/login.defs 로 아래 내용 수정PASS_MAX_DAYS 30 # 최대 30일까지 사용PASS_MIN_DAYS 2 # 최소 2일 이상 사용PASS_WARN_AGE 7 # 7일전부터 경고 메시지 출력설정 2sudo apt install libpam-pwquality : 비밀번호 정책 설정을 위한 패키지 설치sudo vim /etc/pam.d/common-password : 중간에 위치한 per-package modules를 아래와 같이 변경password requisite pam_pwquality.so retry=3 minlen=10 difok=7 ucredit=-1 lcredit=-1 dcredit=-1 reject_username enforce_for_root maxrepeat=3각 항목의 의미는 아래와 같음.retry=3 # 비밀번호 최대 3회까지 입력 가능minlen=10 # 최소 10자difok=7 # 이전 비밀번호와 최소 7글자는 다르게 설정ucredit=-1 # 대문자 최소 1자 이상lcredit=-1 # 소문자 최소 1자 이상(이 조건이 있는 이유?)dcredit=-1 # 숫자 최소 1자 이상reject_username # username을 그대로 or 뒤집어서 암호로 사용 불가enforce_for_root # 해당 비밀번호 정책을 root에도 적용maxrepeat=3 # 3자까지 중복 가능설정 적용위의 두가지 설정은 모두 새로 생성되는 유저에 적용됨. 따라서 아래와 같이 추가적인 설정 적용 과정을 거쳐야 함.chage -m 2 -M 30 -W 7 [username] : 비밀번호 기간 적용(2~30일 유효, 7일전 경고)passwd -e [username] : 다음 로그인시 비밀번호 변경chage -l [username] : 유저별로 설정된 내용 확인sudo vim /etc/shadow : 설정된 내용 한번에 확인위 내용 중 root와 username(taehooki)의 4, 5, 6번 필드(각각 2, 30, 7)를 보면 설정이 적용된 것을 알 수 있음.AppArmor 설정sudo apt --installed list apparmor # 설치 확인apt install apparmor apparmor-profiles apparmor-utils # 설치sudo apparmor_status # 상태 확인aa-enabled # 활성화 여부 확인sudo aa-status # 현재 상태 확인 가능(enforced, complain, unconfined)ps auxZ | grep -v '^unconfined' # apparmor가 실행제한한 파일 확인 enforce 모드 : 허가되지 않은 파일에 접근을 거부함. complain 모드 : 어플리케이션이 해야 할 일이 아닌 일을 했을 때 로그를 기록함.SSH 설정apt --installed list openssh-server # openssh 설치 확인(보통 설치되어있음)ssh -V # openssh 버전 확인apt install openssh-server # openssh 설치(없다면)sudo ufw allow 4242 # 4242 포트 ufw 허용 sudo vim /etc/ssh/sshd_config 내용 수정 Port 4242 # SSH포트를 4242로 변경 PermitRootLogin no # 외부에서 root로의 로그인 차단 설정 적용 sudo systemctl restart ssh # 수정 후, 다시 시작해서 설정 적용 systemctl status ssh # openssh 실행 상태 확인 ss -tunpl # 포트번호 확인 systemctl : 서비스 관리 명령어 systemctl start [서비스이름] # 시작 systemctl stop [서비스이름] # 종료 systemctl restart [서비스이름] # 재시작 systemctl try-restart [서비스이름] # 재시작(시작된 서비스) systemctl reload [서비스이름] # 설정 reload systemctl status [서비스이름] # 상태 확인 systemctl is-active [서비스이름] # 상태 확인(1) systemctl list-units --type service --all # 모든 서비스 상태확인 service 와 systemctl의 차이 service 명령어는 /etc/init.d 를 실행함. systemctl 명령어는 /lib/systemd 의 파일을 실행하고 만약 없으면 위의 service의 경로의 파일을 실행함. UFW 설정$ sudo apt install ufw # ufw 방화벽 설치$ sudo ufw status verbose # 상태 확인(디폴트는 inactive)$ sudo ufw enable # 부팅시 ufw 활성화 하기$ sudo ufw disable # 비활성화$ sudo ufw default deny # 기본 incoming deny$ sudo ufw default allow # 기본 incomig allow$ sudo ufw allow 4242 # 4242port로 ssh 연결 허용$ sudo ufw status numbered # 규칙번호 확인$ sudo ufw delete [규칙번호] # 해당 규칙 삭제TTY로 VM 접근tty리눅스 디바이스 드라이버 중에서 콘솔이나 터미널을 의미명칭은 과거에 사용하던 Teletypewriter에서 유래됨여러 개의 터미널이 존재할 경우 tty0, tty1, …. , tty6로 번호를 붙혀 사용함Port Forwarding로컬에서 tty를 통해 가상머신에 접근하기 위해서는 포트 포워딩 작업이 추가적으로 필요함.sudo apt-get install net-tools : 넷툴즈 설치 (ifconfig 사용을 위해)VirtualBox 설정[Settings]-[Network]-[Advanced]-[Port Forwarding] 에서 Rule 추가하기 HOST IP : 127.0.0.1 (localhost, 자기 자신) 또는 ifconfig | grep inet의 값 HOST PORT : 5000 (임의의 값) GuestIP : 10.0.2.15 (hostname -I의 값) GUEST PORT : 4242 호스트 포트 : 외부에서 연결할 때 이용하고자 하는 포트 게스트 포트 : 내가 지정한 서비스의 포트 cmd에서 아래 내용 입력해서 가상환경에 접속ssh taehooki@127.0.0.1 -p 5000 # ssh [username]@[HOST IP] -p [HOST PORT]VirtualBox의 포트 포워딩 설정에서 호스트 포트를 22(ssh 기본포트)로 지정했다면 ssh로 접속할 때 포트부분을 제외하고 ssh [username]@[HOST IP] 만 입력해도 됨exit : 가상환경 접속 종료SSH를 사용해 접속할때 root로는 접속을 막았기 때문에 연결되지 않음쉘 스크립트 작성관련 명령어 OS 아키텍쳐, 커널 버전(Architecture) uname -a 물리 프로세서 개수(CPU physical) cat /proc/cpuinfo(CPU 코어 개별적인 세부사항이 담겨있음) 파일 참고 cat /proc/cpuinfo | grep \"physical id\" | sort -u | wc -l physical id : 0은 프로세서가 0개라는 의미가 아닌, 0번 id를 갖는 프로세서라는 의미임(0, 1, 2, … 으로 증가함) 해당 line을 추출한 뒤 -u (unique) 옵션(정렬 후 중복된 내용을 제거)으로 정렬 후 행의 수를 세어 출력함 가상 프로세서 개수(vCPU) cat /proc/cpuinfo | grep processor | sort -u | wc -l 현재 서버에 여유있는 RAM과 사용률(Memory Usage) free : 메모리 사용량, 여유량과 캐싱으로 사용되는 메모리의 현황 [total] : 설치된 총 메모리 크기 / 설정된 스왑 총 크기 [used] : total에서 free, buff/cache를 뺀 사용중인 메모리. / 사용중인 스왑 크기 [free] : total에서 used와 buff/cahce를 뺀 실제 사용 가능한 여유 있는 메모리량 / 사용되지 않은 스왑 크기 [shared] : tmpfs(메모리 파일 시스템), ramfs 등으로 사용되는 메모리. 여러 프로세스에서 사용할 수 있는 공유 메모리 [buffers] : 커널 버퍼로 사용중인 메모리 [cache] : 페이지 캐시와 slab으로 사용중인 메모리 slab : 커널이 내부적으로 사용하는 영역 [buff/cache] : 버퍼와 캐시를 더한 사용중인 메모리 [available] : swapping 없이 새로운 프로세스에서 할당 가능한 메모리의 예상 크기. (예전의 -/+ buffers/cache이 사라지고 새로 생긴 컬럼) free -m | grep Mem | awk '{printf \"%d/%dMB (%.2f%%)\", $3, $2, $3/$2*100}' free의 내용을 MB단위로 받아서 Mem이 포함된 행의 내용을 [used]/[total]MB ([used]/[total]x100%) 형태로 출력 현재 서버에 여유있는 메모리와 사용률(Disk Usage) df : 디스크메모리의 전체 현황 BM, BG: MB, GB로 결과 출력 df -BM | grep /dev/map | awk '{sum+=$3}END{print sum}' | tr -d df -BM | grep /dev/map | awk '{sum+=$4}END{print sum}' | tr -d 현재 프로세서의 사용률(CPU load) mpstat: 사용가능한 CPU와 core별 사용률 현황 sudo apt-get install sysstat : mpstat 명령어가 포함된 패키지 설치 mpstat | grep all | awk '{printf \"%.2f%%\\n\", 100-$NF}' NF: 필드의 총 개수($NF=마지막 필드) 마지막 reboot 일시(Last boot) who : 호스트에 로그인한 사용자 정보를 /var/run/utmp 파일에서 가져옴 [b] : 마지막 시스템 부팅 시간 who -b | awk '{printf $3\" \"$4\"\\n\"}' LVM 활성화 여부(LVM use) lsblk : 현재 디바이스의 스토리지 정보를 출력 모든 블럭 장치에 대한 정보를 알 수 있음 lsblk | grep LVM | wc -l | awk '{if($1&gt;0) print \"yes\"; else print \"no\"}' 활성화 된 연결의 수(Connections TCP) ss : Socket Statistics. 네트워크 상태 확인 (netstat로도 가능) [a] : 모든 포트 확인 [t] : TCP 포트 확인 [u] : UDP 포트 확인 [l] : LISTEN 상태 포트 확인 [p] : 프로세스명을 표시 [n] : 호스트 / 포트 / 사용자이름을 숫자로 표시 ss -t | grep ESTAB | wc -l | tr -d '\\n' ss : socket의 상태 확인(socket statistics) ss를 옵션없이 사용하면 listening socket(서버)을 제외한 연결된 소켓만을 출력함 [t] : TCP socket 표시 tr : 문자 변환/삭제 사용법 : tr [옵션][문자열1][문자열2] [d] : 문자열1에서 특정 문자를 삭제 [s] : 문자열2에서 반복되는 문자를 삭제 [t] : 문자열 1을 문자열2의 길이로 자름 [옵션x] : 문자열1을 문자열2로 변경 서버를 사용중인 유저의 수(User log) who | wc -l 서버의 IPv4 주소와 MAC주소(Network) hostname -I : 서버의 IPv4 주소 ip link | grep link/ether | awk '{print \"(\"$2\")\"}' : 서버의 MAC 주소 ifconfig | grep ether | awk '{print \"(\"$2\")\"}'로도 MAC 주소 확인 가능 sudo를 통해 실행된 명령의 횟수(Sudo) jounalctl : systemd의 서비스 로그를 찾는데 사용되는 명령 _EXE=, _COMM=, _KERNELDEVICE= 를 활용해 argument를 입력해 원하는 파일경로를 찾을 수 있음(manpage 참고) journalctl _COMM=sudo : 이렇게만 입력하면 아래와 같이 sudo명령이 아닌 행까지 모두 출력됨 journalctl _COMM=sudo | grep COMMAND : 이렇게 COMMAND로 grep을 해야 원하는 결과를 얻을 수 있음 monitoring.sh#!/bin/bashprintf \"#Architecture: \"uname -aprintf \"#CPU physical : \"cat /proc/cpuinfo | grep \"physical id\" | sort -u | wc -lprintf \"#vCPU : \"cat /proc/cpuinfo | grep processor | wc -lprintf \"#Memory Usage: \"free -m | grep Mem |awk '{printf\"%d/%dMB (%.2f%%)\\n\", $3, $2, $3/$2 * 100}'printf \"#Disk Usage: \"df -BM | grep /dev/map | awk '{sum+=$3}END{print sum}' | tr -d '\\n'printf \"/\"df -BM | grep /dev/map | awk '{sum+=$4}END{print sum}' | tr -d '\\n'printf \"MB (\"df -BM | grep /dev/map | awk '{sum1+=$3 ; sum2+=$4 }END{printf \"%d\", sum1 / sum2 * 100}' | tr -d '\\n'printf \"%%)\\n\"printf \"#CPU load: \"mpstat | grep all | awk '{printf \"%.2f%%\\n\", 100-$NF}'printf \"#Last boot: \"who -b | awk '{printf $3\" \"$4\"\\n\"}'printf \"#LVM use: \"lsblk | grep LVM | wc -l | awk '{if($1&gt;0) print \"yes\"; else print \"no\"}'printf \"#Connections TCP : \"ss -t | grep ESTAB | wc -l | tr -d '\\n'printf \" ESTABLISHED\\n\"printf \"#User log: \"who | wc -lprintf \"#Network: IP \"hostname -I | tr -d '\\n'ip link | grep link/ether | awk '{print \"(\"$2\")\"}'printf \"#Sudo : \"journalctl _COMM=sudo | grep COMMAND | wc -l | tr -d '\\n'printf \" cmd\\n\"exit 0cron특정 시간에 특정 작업을 자동으로 수행하는 스케쥴러crontabcron 작업을 설정하고 수행하는 프로그램/etc/crontab 파일에 기록된 내용대로 작업을 수행기본 사용법sudo crontab -e # crontab 편집sudo crontab -l # crontab 작업내용 확인sudo crontab -r # crontab 전체작업 삭제사용 예시0 * * * * {실행 명령} # 매시 정각0 0 14 * * {실행 명령} # 매일 14시0 0 * * 1 {실행 명령} # 매주 월요일 자정0 0 2 * * {실행 명령} # 매달 2일 자정20,50 * * * * {실행 명령} # 매시 20분, 50분 */15 * * * * {실행 명령} # 15분 주기로0 3 * * * {실행 명령} # 매일 3시30 */6 * * * {실행 명령} # 매 6시간마다(00:30, 06:30, 12:30, 18:30)30 1-23/6 * * * {실행 명령} # 1시 반부터 매 6시간마다0 6 * * 1-5 {실행 명령} # 평일 6시0 7 * * 6 {실행 명령} # 토요일 7시crontab 설정sudo chmod +x monitoring.sh # 실행권한 부여sudo crontab -e # sudo를 사용해서 crontab 파일 수정*/10 * * * * /root/monitoring.sh | wall # 10분마다 wall 실행 cron 30초마다 실행하는 법 crontab 옵션은 최소 분단위임. 초단위로 적용하고자 한다면 sleep을 사용하면 됨. (default가 1분이라 앞부분 시간설정은 안해도 됨) * * * * * /root/monitoring.sh | wall &amp;&amp; sleep 30; /root/monitoring.sh | wall 관련 명령어sudo service cron start # 시작sudo service cron stop # 일시적 중단(재부팅하면 시작됨)sudo systemctl disable cron # 재부팅시 중단(아예 중단됨)sudo service cron restart # 재시작sudo service cron status # 작동확인Ref.https://m.blog.naver.com/snazzy79/70148845500https://bono915.tistory.com/entry/VirtualBox-Linux-포트포워딩-설정-및-ssh-연결-방법https://www.whatap.io/ko/blog/37/https://zidarn87.tistory.com/137https://www.cyberciti.biz/tips/linux-investigate-sockets-network-connections.htmlhttps://jdm.kr/blog/2" }, { "title": "Born2beroot ③ 배경 지식", "url": "/posts/born2beroot3/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-06-27 00:00:00 +0900", "snippet": "가상 머신 (Virtual Machine) 물리적 컴퓨터와 동일한 기능을 제공하는 소프트웨어 컴퓨터가상머신의 유형 프로세스 가상머신(응용 프로그램 가상머신) 호스트 머신에서 단일 프로세스를 실행할 수 있게 함. 플랫폼에 독립적인 프로그램 실행 환경을 제공함 예시 : JVM (Java Virtual Machine) 시스템 가상머신 (하드웨어 가상머신) 하드웨어 가상머신으로도 불림. 물리적 기계를 완전히 대체할 수 있음. 가상화를 제공하는 소프트웨어 : Hypervisor 예시 : VMware, VirtualBox 가상머신의 장단점 장점 사용자가 단일 하드웨어에서 다양한 OS를 실행가능. 기업은 시간, 비용, 물리적 공간 절약. 악성 소프트웨어의 전체 확산 방지. 단점 성능이 불안정해질 수 있음. (하나의 물리적 호스트에서 여러 VM을 실행할 경우) 가상화의 유형 하드웨어 가상화 소프트웨어 가상화 스토리지 가상화 네트워크 가상화 데스크톱 가상화가상머신 vs 컨테이너가상머신컨테이너공통점 둘 다 하나의 플랫폼에 독립된 어플리케이션을 동작하도록 함.차이점 가상머신이 하드웨어를 가상화해서 (가상)컴퓨터를 생성하는데에 반해 컨테이너는 하나의 앱과 그에 해당하는 의존성만을 패키지로 만듦. 가상머신은 하이퍼바이저에 의해 관리되는 반면 컨테이너는 호스트 컴퓨터의 OS를 공유하고 가상 메모리 하드웨어를 사용해 앱을 격리함.CentOS vs Debian 리눅스 배포판의 종류 중 하나인 레드햇 계열과 데비안 계열의 대표적인 OSLinuxUNIX를 기반으로 만들어진 OS. 다중 사용자, 다중 작업(멀티 태스킹, 멀티 스레딩)을 지원하는 네트워크 운영체제(NOS).주요 장점 오픈 소스 소프트웨어. 오픈소스 : 최종 사용자가 소스코드를 합법적으로 사용할 수 있도록 특별한 라이선스를 통해 릴리즈한 것. 추가 비용 없이 소스코드 형식으로 제공됨. 해당 소스코드를 새 소프트웨어에 다른 용도로 사용 가능. 다중 사용자, 다중 작업을 지원함. 강력한 보안기능을 갖춤.위와 같은 각 장점으로 인해 광범위하게 사용되어지며, 서버 운영에 적합하고, 많은 기업에서 사용됨.이러한 리눅스에는 다양한 배포판이 존재함. 대표적인 두가지 계열로는 레드햇 계열과 데비안 계열이 있음.레드햇 계열레드햇에서 개발한 RHEL에서 파생된 리눅스 계열 주요 특징오픈소스 소프트웨어 기업에서 직접 개발한 소프트웨어로 다양한 유틸리티, 높은 안정성 등의 장점이 있으나 새로운 기술의 적용이 보수적임. 주요 OS RHEL CentOS Fedora Oracle Linux 데비안 계열 주요 특징온라인 커뮤니티에서 제작해서 배포함. 많은 사용자를 기반으로 형성된 커뮤니티를 통해 다양한 정보를 쉽게 얻을 수 있어 진입장벽이 낮음. 주요 OS Debian Ubuntu CentOSRHEL과 동일한 소스코드를 기반으로 커뮤니티에서 새로 빌드해 제공함.RHEL에 비해 일부 하드웨어 플랫폼, 드라이버, 기능이 제외됨.Red Hat으로부터의 2, 3차 기술지원 불가.패키지 포맷 : rpm 형식패키지 관리 : yum/dnf 사용Debian커뮤니티에서 만들고 배포해서 사후지원과 배포가 늦음.유저 커뮤니티를 통해 매뉴얼 등의 습득이 용이함.패키지 포맷 : deb 형식패키지 관리 : dpkg/apt 사용SELinux vs AppArmor 리눅스 커널 보안 모듈AppArmor 시스템 관리자가 프로그램 프로필 별로 프로그램의 역량을 제한할 수 있게 해주는 리눅스 커널 보안 모듈 프로그램의 프로필을 통해 해당 프로그램이 취할 수 있는 아래와 같은 작업들을 제한하고 관리함 네트워크 액세스 raw 소켓 액세스 파일 읽기, 쓰기, 실행 권한 강제적 접근 통제(MAC)를 제공함으로써 전통적인 유닉스 임의적 접근 통제 모델(DAC)을 지원함 SUSE 계열, 데비안 계열(Debian, Ubuntu)에서 사용.임의적 접근통제 (DAC, Discretionary Access Control) 정보 소유자가 사용자나 사용자가 속한 그룹에 임의적 접근제어를 설정함. 대부분의 OS에서 채택. 장단점 유연성이 있음. 트로이 목마에 취약함. id가 도용되면 DAC는 파괴됨. 강제적 접근통제 (MAC, Mandatory Access Control) 관리자만 사용자에게 접근권한을 부여할 수 있음. 시스템 사용자는 자신의 정보에 대해 어떤 접근 권한도 설정할 수 없음. 정부, 군 같은 복잡한 시스템에서 주로 사용. 장단점 강력한 통제를 부여하기 때문에 DAC에 비해 안전함. 객체단위 권한설정 불가. 일반적 환경에서는 사용이 어려움. SELinux 미국 국방부 스타일의 강제 접근 제어(MAC)를 포함한 접근 제어 보안 정책을 지원하는 매커니즘을 제공하는 리눅스 커널 보안 모듈 시스템 전체에 보안 설정. 레드햇 계열(RHEL, Fedora, CentOS)에서 사용.주요 차이점 CentOS와 같은 제품 및 파생제품은 SELinux, 다른 대부분은 APPArmor를 사용 AppArmor이 갖는 설치, 관리의 용이함때문에 SELinux를 대체하는 한 부분으로 제공됨 파일관리 방식- SELinux: 파일에 라벨을 적용함 AppArmor: 파일 경로를 통해 작동함apt vs aptitude 데비안 패키지 관리 툴apt (Advanced Packaging Tool) cli용 패키지 관리 도구 low level이면서 높은 자유도 패키지 명을 입력하면 의존성 목록도 함께 설치됨(의존성 문제 없음)aptitude 사용자 인터페이스를 추가해 대화형으로 패키지 관리 대화형(텍스트 기반 인터페이스), 비대화형(cli) 모두 동작함 high level주요 차이점 기능aptitude가 apt의 기능(apt-get, apt-mark, apt-cache 등)들을 포함하여 더 폭넓은 기능을 제공함 UIapt-get은 UI가 부족한 편인 반면 aptitude는 UI도 제공하면서 cli에서도 동작함 패키지 관리 apt-get이 하는 일 외에도 aptitude는 설치된 패키지 목록, 패키지를 자동 또는 수동으로 설치하도록 표시, 업그레이드에 사용할 수 없는 패키지 보관 등을 함 패키지 삭제 시 충돌 패키지까지 자동으로 제거해주는 aptitude와는 달리 apt는 auto-remove 등의 추가옵션이 필요함 LVM (Logical Volume Manager) 리눅스의 저장공간을 효율적이고 유연하게 관리하는 기술기존 방식리눅스에서 하나의 디스크를 여러개의 파티션으로 분할해서 파일 시스템을 특정 디렉토리와 연결해서 사용. 저장공간의 크기가 고정되어 있어 이후의 증설/축소가 어려운 단점 존재.LVM 특징파티션 대신 볼륨 단위로 저장장치를 다루기 때문에 유연한 용량조절(각 볼륨에 대한)이 가능함Storage Pool(하나의 큰 스토리지 공간)의 크기 조절이 가능함장치 이름 지정이 자유로움관련 용어 물리적 볼륨(PV, Physical Volume) 실제 디스크 장치를 분할한 파티션된 상태를 의미 PV는 일정한 크기의 PE로 구성됨 볼륨 그룹(VG, Volume Group) PV가 모여서 생성되는 단위 사용자는 VG를 원하는만큼 쪼개어 LV로 만듦 논리적 볼륨(LV, Logical Volume) 사용자가 최종적으로 사용하는 단위 VG에서 필요한 크기로 할당받아 생성 물리적 확장(PE, Physical Extent) PV를 구성하는 최소단위로 일정한 크기의 블럭 1PE는 4MB의 크기를 가짐 PE와 LE는 1대1 매핑됨. 논리적 확장(LE, Logical Extent) LV를 구성하는 일정한 크기의 블럭 1LE는 4MB의 크기를 가짐. VG를 분할해 LV를 만들 때 PE와 1대1 매핑됨. 디스크, 파티션, 볼륨 디스크 : 시스템에 장착되어 있는 물리적인 저장장치 파티션 : 물리 디스크를 여러 독립적인 공간으로 구분해 놓은것 볼륨 : 단일 파일 시스템을 사용해 액세스할 수 있는 저장공간 일반적으로 디스크를 파티션으로 구분하고, 각 파티션을 파일 시스템으로 포맷해서 볼륨을 만들어 사용함 sudo vs rootsudo sudo(Super User Do 또는 substitute user do) root유저 외의 유저에게 제한적인 관리자 권한을 부여해주는 명령어 /var/log/sudo 에 사용 기록을 남김root UNIX 계열 OS에서의 슈퍼유저 계정. 시스템에 관한 모든 권한을 가짐. Ubuntu 등 특정 OS에서는 루트 계정이 기본적으로 잠겨있음sudo vs root 유저에 의한 의도치 않은 시스템 손상(핵심 루트 디렉터리나 파일의 삭제)을 방지함. 예를들어 root 계정으로 rm -rf /etc 와 같은 명령을 사용하면 메시지도 띄우지 않고 핵심 디렉터리를 삭제하게 됨. 만약 유저로 로그인한 상태였다면 거절됨. command 단위로 log를 남기기 때문에 정확한 기록을 확인할 수 있음.사용법sudo 명령어 형태로 사용/etc/sudoers 파일에 있는 유저만 사용가능. 해당 파일은 root계정에서 visudo 명령어를 통해 편집 가능sudo log/var/log/sudo 의 디렉토리 별 의미log # sudo 실행한 위치와 실행한 명령어의 위치stderr # sudo로 실행한 명령어가 오류로 인해 실행되지 않았을 경우 출력되는 내용stdin # sudo로 실행한 명령어가 표준 입력을 받은 내용stdout # sudo로 실행한 명령어가 표준 출력으로 결과를 출력한 내용timing # 세션이 실행된 시간ttyin # sudo로 실행한 명령어가 TTY로 입력받은 내용ttyout # sudo로 실행한 명령어가 TTY로 출력한 결과UFW (Uncomplicated Firewall) 리눅스 환경에서 동작하는 사용하기 쉬운 방화벽 관리 프로그램장점리눅스의 기본 방화벽인 iptables는 명령어가 직관적이지 않다는 단점 존재.반면 ufw는 쉽고 직관적인 명령어를 갖는 동시에 성능도 비슷함.방화벽 해킹에 사용되는 소프트웨어 취약점을 막는게 아니라 접근할 수 있는 경우의 수를 줄이는 역할 특정 포트, ip, 및 ssh 접근을 허용하고 거부함 리눅스 환경에서 동작하는 방화벽 : ufw, iptables, firewalldSSH (Secure Shell)개념컴퓨터간에 인터넷과 같은 Public Network를 통해서 통신을 할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 네트워크 프로토콜의 일종 프로토콜 : 서로 다른 시스템에 있는 개체 간에 데이터를 전송하는데 사용하는 통신 규약. 네트워크에 연결된 컴퓨터들끼리 미리 약속한 전송 규칙사용 이유 기존의 FTP, Telnet이 갖는 보안적인 문제(IP Spoofing, DNS Spoofing) Spoofing : 자신의 IP 및 DNS를 속여서 접속하는 공격을 총칭함 사용 방식 SSH는 일반적인 통신과정인 비밀번호 입력을 통한 접속을 하지 않음 대신 Public key, Private key라는 한쌍의 key를 활용한 인증과정을 거침 Public key 공개되어도 비교적 안전한 key 메시지를 전송하기 전에 암호화 함(복호화는 불가능) Private key 절대 외부에 노출되어선 안되는 key 본인 컴퓨터 내부에 저장하게 되어있음 암호화된 메시지를 복호화 가능 클라이언트가 통신하고자 하는 서버에 요청을 보냄 응답을 하는 서버가 저장하고 있던 Pubilc key를 보냄 클라이언트는 해당 Public key와 자신의 Private key가 한 쌍인지 인증과정을 거침 인증에 성공하면 두 컴퓨터 사이에 암호화된 채널이 생성됨Port Forwarding 공인 IP : 유일한 IP이기 때문에 외부에서 직접 접근이 가능 사설 IP : 해당 공유기 내에서 부여한 주소이기 때문에 고유하지 않아 외부에서는 직접 접근이 불가 포트 포워딩 : 공유기에서 각 기기에 포트를 부여해서 외부로 개방시킨 것 DMZ : 하나의 기기에 모든 포트를 부여해 개방하는 것. 보안이 취약하다는 단점 존재스냅샷 특정 시점에서의 가상머신의 시스템 상태를 캡쳐하는 기능용도용량이 큰 데이터는 완전히 백업하려면 오랜시간이 걸리고 백업도중 프로그램으로의 접근이 어려운 단점이 존재.이러한 시스템 다운을 피하기 위해 고성능 시스템과 같은 용량이 큰 데이터는 스냅샷을 기반으로 백업을 수행함shasumSHA Checksum 값을 출력하거나 검사하는 프로그램사용하는 이유인터넷 상에서 다운로드한 파일은 변조의 가능성이 있음.따라서 동일한 파일인지 체크하는 과정을 통해 이러한 위험을 예방함.원리원본 파일과 검사 파일(체크섬 파일)을 분리 제공한 후,원본 파일을 사용하기 전에 검사파일을 통해 검사한 후 사용함과제에서의 사용법 평가 제출 직전에 vm에서 스냅샷 찍기 shasum [vm이름].vdi &gt; signature.txt 로 txt파일 만든 후 제출 평가때 shasum [vm이름].vdi 입력해서 나온 해시값과 txt파일의 값이 같은지 체크FTP (File Transfer Protocol)파일 전송 프로토콜.네트워크에 연결된 컴퓨터 사이의 데이터 교환을 원활히 하기 위해 개발됨.FTP 서버파일을 하나의 장치에서 다른 장치로 전송하는 소프트웨어 애플리케이션.FTP 주소를 가지고 있고 FTP 연결을 수신하는 데 사용되는 컴퓨터.역할파일 송수신 (FTP 서버 ↔ 클라이언트)원리사용대량의 파일을 처리하는 경우 (주로 웹 개발)워드프레스의 경우 FTP를 사용하여 파일을 송수신할 수 있음. 워드프레스의 테마편집기를 이용하면 아래와 같은 단점이 존재함. 로딩 속도가 느림 되돌리기 기능 부재 사이트 접속이 안되는 경우 존재 보안 문제vsftpd (very secure FTP daemon)유닉스 계열 OS의 FTP 서버.우분투, CentOS, Fedora 등에서 기본 FTP 서버로 사용.강력한 보안, 빠른 퍼포먼스, 높은 안정성을 지님. config 설정 방법이 간단해 FTP 서버 관리가 용이함.vsftpd는 UNIX 계정 관리를 통해 작동. 즉, FTP 서버에 필요한 사용자 이름과 암호를 가진 사용자 계정이 운영 체제에 있어야 하며 /etc/vsftpd.user_list 내에 나열되어 있어야 함.Ref.https://www.vmware.com/topics/glossary/content/virtual-machine.htmlhttps://www.itworld.co.kr/news/166350https://www.redhat.com/ko/topics/open-source/what-is-open-source-softwarehttps://www.tecmint.com/difference-between-apt-and-aptitude/https://velog.io/@joonpark/aptitude-vs-apthttps://www.vultr.com/docs/why-use-sudo-instead-of-logging-in-as-root/https://ko.wikipedia.org/wiki/AppArmorhttps://tino1999.tistory.com/40]https://nostressdev.tistory.com/5https://eunguru.tistory.com/88https://greencloud33.tistory.com/41https://soft.plusblog.co.kr/46https://ko.wikipedia.org/wiki/스냅샷_(기억_장치)https://hanamon.kr/네트워크-ssh란/https://velog.io/@pearpearb/42서울-Born2berootSSH와-포트포워딩https://ko.wikipedia.org/wiki/UFWhttps://blog.naver.com/wideeyed/221300065871https://experience.dropbox.com/ko-kr/resources/what-is-ftphttps://sepiros.tistory.com/22https://www.thewordcracker.com/basic/using-ftp-to-work-with-wordpress/" }, { "title": "Born2beroot ② 환경 세팅", "url": "/posts/born2beroot2/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-06-25 00:00:00 +0900", "snippet": "VirtualBox &amp; Debian 설치설치 방법Debian 버전 : 11.3.0 (amd64)파티션 설정파티션별 역할 /root : 시스템 관리자 root의 홈 위치. 일반적으로 첫번째 파티션의 루트 /boot : 부팅 프로세스에 필요한 모든 파일이 위치 /home : 사용자에 대한 모든 홈 디렉터리가 위치 /swap : 하드 드라이브의 일부를 지정하여 시스템 메모리를 확장하는 곳 /var : 변경 가능한 상태의 파일을 위한 장소. variable(변수)를 의미함 /srv : 시스템에서 제공하는 서비스에 대한 데이터인 서버 데이터가 위치 /tmp : 임시 파일을 저장하는 곳 /var/log : 프로그램 로그파일이 위치파티션 확인lsblk : 가상머신의 파티션 확인 (설치를 마치고 터미널에서 입력)파일 시스템 설정 Ext3 : 저널링 파일 시스템. 16TB까지 디스크 사용할 수 있음 저널링 기술 : 시스템의 비정상적인 종료시에도 로그에 저장된 데이터로 백업 및 복구가 가능함. Ext4 : 대부분의 리눅스 배포판이 채택한 저널링 파일 시스템. 최대 1EB의 볼륨을 지원함. 하위호환성을 가짐.(ext2, ext3을 ext4로 마운트하는것이 가능) 마운트 : 물리적인 장치(디스크)를 특정한 위치(주로 디렉터리)에 연결시키는 것 sudo 설치apt install sudo : sudo 설치dpkg -l | grep sudo : sudo 설치여부 체크mkdir /var/log/sudo : sudo log를 저장할 디렉터리 생성var/log/sudo/ log : sudo를 실행한 위치와 명령어의 위치 stderr : sudo 오류 발생시 출력 내용 stdin : sudo로 표준 입력을 받은 내용 stdout : sudo로 표준 출력을 한 내용 timing : 세션 실행시간 ttyin : tty로 입력받은 내용 ttyout : tty로 출력한 내용vim 설치sudo apt install vimRef.https://www.dell.com/support/kbdoc/ko-kr/000131456/ubuntu-linux-파티션-및-디렉터리의-유형-및-정의-설명https://velog.io/@appti/born2beroot-Virtualbox-Debian-설치" }, { "title": "Born2beroot ① 참고 사항", "url": "/posts/born2beroot1/", "categories": "42Seoul, Born2beroot", "tags": "42seoul, linux", "date": "2022-06-24 00:00:00 +0900", "snippet": "PdfSummary이번 과제에서는 시스템 관리 관련 연습을 합니다.Tips 가상머신 파일의 용량이 매우 큼 → 가급적 동일한 장소에서 계속 작업 클러스터에서 작업하려면 가상머신의 경로를 goinfre에 만들고 같은 자리에서만 로그인 m1 mac에서는 VirtualBox 설치 불가(UTM은 가능) → 윈도우pc, 클러스터 맥 등에서 작업 Debian vs CentOS → 데비안이 비교적 난이도가 낮음 내용이 방대하기 때문에 모든 내용을 작성해가며 공부하는것은 비효율적임. 빠르게 훑으면서 실습한 뒤에 주요내용 위주로 정리배워야 할 내용 가상머신 운영체제 웹 개발 기초제출 방법 VM 최종점검 스냅샷 생성 원본 vdi로 shasum 생성 후 signature.txt에 저장(shasum born2beroot.vdi &gt; signature.txt) VM의 내용 수정 후 스냅샷으로 롤백. shasum의 값이 이전과 동일한지 확인 제출 평가가 끝날때마다 스냅샷을 통해 restore평가 후기부족했던 부분 LVM 개념 AppArmor 개념 : MAC, DAC 비밀번호 정책 : lcredit=-1이 들어가는 이유 cron 관련 명령어 : 재부팅 시 중단시키기" }, { "title": "ft_printf ③ 프로젝트 구현 (Mandatory part)", "url": "/posts/ft_printf3/", "categories": "42Seoul, ft_printf", "tags": "42seoul, c", "date": "2022-06-23 00:00:00 +0900", "snippet": "방법 구상 printf의 format을 체크 %를 만나면 형식지정자를 확인 해당 형식에 맞는 함수를 가변인자로 들어온 값으로 호출 Mandatory : 파싱 → 출력의 2단계로 구성 Bonus : 파싱 → 처리 → 출력의 3단계로 구성구현 과정파싱 format 파싱 %가 나올때까지 그대로 출력 type 파싱 cspdiuxX% 중 하나가 나오면 출력 if (type == 'c') count = ft_print_char(va_arg(*ap, int)); else if (type == 's') count = ft_print_str(va_arg(*ap, char *)); else if (type == 'p') count = ft_print_ptr(va_arg(*ap, void *)); else if (type == 'd' || type == 'i') count = ft_print_dec(va_arg(*ap, int)); else if (type == 'u') count = ft_print_dec_unsigned(va_arg(*ap, unsigned int)); else if (type == 'x' || type == 'X') count = ft_print_hex(va_arg(*ap, unsigned int), type); else count = write(1, &amp;type, 1); return (count); char형이 va_arg에서 int로 설정되는 이유?메모리에는 값을 기록하는 과정에서 CPU 접근에 부하를 덜어주기 위해 바이트 패딩이라는 방법이 사용되는데,이로 인해 4byte 단위로 메모리에 접근을 하게 된다. 따라서 자료형의 크기가 4byte 이하인 경우에는 4byte로 처리가 된다.출력 각 자료형에 맞게 처리하여 출력ft_printf.c 함수별 설명 ft_printf: 가변인자 목록을 만들고 ft_parse_format에 format과 목록 포인터의 주소값(?)을 넘겨줌 ft_parse_format: 넘어온 format과 ap를 통해 서식지정자를 나타내는 문자인 %가 나오면 ft_parse_type에 다음문자와 목록 포인터의 주소값(?)을 넘겨줌 ft_parse_type: 넘어온 문자를 체크해서 대응하는 함수를 호출함 format에 NULL이 들어오는 경우클러스터 맥에서의 동작: [1] 2556 segmentation fault ./a.out함수 구현: -1을 리턴해줘서 에러 발생을 알림ft_parse_formatif (!*format) : format의 맨 마지막에 %만 있는 경우ft_print_hex.c 함수 종류 ft_print_ptr: 주소값의 앞부분인 0x를 출력하고 진수 변환하는 함수를 호출함 ft_print_hex: 10진수를 16진수로 변환함 ft_addr_to_hex: 주소값을 10진수 unsigned long long 자료형으로 받아서 16진수로 변환함 ft_print_ptrft_addr_to_hex((unsigned long)addr, 'x'); : void *형으로 받은 포인터를 unsigned long형으로 형변환함. unsigned long형을 사용한 이유? 주소값은 32bit OS에서는 4바이트, 64bit OS에서는 8바이트를 차지함 unsigned long 은 32bit 에서는 4바이트 64bit 에서는 8바이트가 되므로 주소값을 담기에 적합함 ft_print_dec.c 함수 종류 ft_print_dec: int형으로 들어온 값을 10진수로 출력함 ft_print_dec_unsigned : unsigned int형으로 들어온 값을 10진수로 출력함 ft_print_dec code1ft_putnbr_fd → ft_itoa → ft_strlen 문제점 :출력된 길이를 구하는 과정이 비효율적임.malloc, free 등의 사용으로 에러 발생 시 예기치 못하게 함수가 종료될 수 있음. int\tft_print_dec(int n) { int\t\tlen; char\t*str; len = 0; ft_putnbr_fd(n, 1); str = ft_itoa(n); len = ft_strlen(str); free (str); return (len); } code2 int\tft_print_dec(int n) { int\tlen; len = 0; if (n == -2147483648) return (write(1, \"-2147483648\", 11)); if (n &lt; 0) { len += write(1, \"-\", 1); n *= -1; } if (n &gt;= 10) len += ft_print_dec(n / 10); len += write(1, &amp;\"0123456789\"[n % 10], 1); return (len); } ft_print_dec_unsigned재귀함수 사용ft_print_char.c 함수 종류 ft_print_char ft_print_str 기타Makefile병렬 실행 옵션make -j n : job을 한번에 n개 실행하여 컴파일 속도가 빨라짐. 의존성 문제re: fclean all: j옵션으로 컴파일 시, all이 fclean보다 먼저 실행될 수 있음 해결방법 re: fclean all Testmain함수 사용#include \"ft_printf.h\"#include &lt;stdio.h&gt;int\tmain(void){\twrite(1, \"ft_printf: \", 11);\tprintf(\", %d\\n\", ft_printf(\"%d\", 42));\twrite(1, \"printf: \", 8);\tprintf(\", %d\", printf(\"%d\", 42));} make로 생성된 libftprintf.a 실행하는법main.c에 헤더 include 한 후에 gcc main.c libftprintf.a로 컴파일 후 a.out 실행하여 사용테스터1. Tripoullehttps://github.com/Tripouille/printfTester틀린 부분 s두번째 인자를 못받고 계속 첫번째만 받음해결방법: 인자를 넘겨줄때 &amp; 형태, * 형태로 넘겨줌 ulen 변수가 누적되도록 더해주질 않음 dft_itoa 함수를 사용하고 메모리 해제를 하지 않음 hlen 변수가 누적되도록 더해주질 않음 x자료형을 잘못 사용함24,25, 27-29 TEST(24, print(\" %x \", LONG_MAX)); TEST(25, print(\" %x \", LONG_MIN)); TEST(27, print(\" %x \", ULONG_MAX)); TEST(28, print(\" %x \", 9223372036854775807LL)); TEST(29, print(\" %x %x %x %x %x %x %x\", INT_MAX, INT_MIN, LONG_MAX, LONG_MIN, ULONG_MAX, 0, -42)); 2. ft_printf_testerhttps://github.com/paulo-santana/ft_printf_testerRef.https://supercoding.tistory.com/37https://bigpel66.oopy.io/library/42/inner-circle/4https://velog.io/@hkh406/ftprintf-%EC%A0%95%EB%A6%AC" }, { "title": "ft_printf ② 배경 지식", "url": "/posts/ft_printf2/", "categories": "42Seoul, ft_printf", "tags": "42seoul, c", "date": "2022-06-23 00:00:00 +0900", "snippet": "printf 함수printf manualint printf(const char * restrict format, ...);반환값 출력한 문자수 (끝의 널문자 제외) 음수값 (output or encoding error 발생 시)서식 문자열printf의 f는 formatted의 약자로, 서식화된 출력을 지원한다는 의미임.%[flag][width][.precision][length]specifier format specifier (형식 지정자) 서식 지정자 설명 d, i 부호 있는 10진 정수 u 부호 없는 10진 정수 o 부호 없는 8진 정수 x 부호 없는 16진 정수(소문자) X 부호 없는 16진 정수(대문자) f 실수를 소수점으로 표기(소문자) F 실수를 소수점으로 표기(대문자) e 실수 지수 표기법 사용(소문자) E 실수 지수 표기법 사용(대문자) g %f와 %e 중에서 짧은 것을 사용(소문자) G %F와 %E 중에서 짧은 것을 사용(대문자) a 실수를 16진법으로 표기(소문자) A 실수를 16진법으로 표기(대문자) c 문자 s 문자열 p 포인터의 메모리 주소 % % 기호 출력 형식 지정자 d와 i의 차이점 output 함수(ex. printf 등)에서는 차이 없음 input 함수(ex. scanf 등)에서는 받는 값이 다름 %d : signed 10진수 정수를 입력 받음 %i : 8진수/10진수/16진수 입력 받음 예시 코드 #include &lt;stdio.h&gt; int main() { \tint oct; \tint dec; \tint hex; \tint num; \tscanf(\"%i, %i, %i\", &amp;oct, &amp;dec, &amp;hex); \tscanf(\"%d\", &amp;num); \tprintf(\"oct: %d, dec: %d, hex: %d, num: %d\\n\", oct, dec, hex, num); \tprintf(\"oct: %i, dec: %i, hex: %i, num: %i\", oct, dec, hex, num); } 출력결과 011, 11, 0x11 011 oct: 9, dec: 11, hex: 17, num: 11 oct: 9, dec: 11, hex: 17, num: 11 보다시피 printf함수에서는 d와 i가 모두 같은 값인 10진수 값을 출력한다. 하지만 scanf함수에서는 i로 지정한 부분은 input의 prefix에 따라 8진수(0), 10진수, 16진수(0x)로 다르게 입력받는다. 가변 인자 함수 (Variadic Function)매개변수의 개수가 정해지지 않은채 사용하는 함수반환값자료형 함수이름(자료형 고정매개변수, ...){}#include &lt;stdarg.h&gt; : 가변인자 매크로가 정의되어 있음가변인자 매크로 (Variadic Macro)va_list // 가변 인자 목록va_start // 가변 인자 시작 주소 참조하는 포인터 설정va_arg // 자료형의 크기만큼 가변 인자 목록 포인터에서 값을 가져옴va_end // 가변 인자 목록 포인터를 NULL로 초기화va_copy // 가변 인자 목록을 복사va_start: 첫번째 가변인자 주소로 ap를 설정함va_arg: ap를 type에 맞게 읽고 다음 가변인자로 포인터를 움직여줌 가변 인자 포인터 ap를 인자로 넘기는 경우 void func(va_list *ap); : 매개변수를 포인터로 설정하고 func(&amp;ap) : 주소를 넘겨줘야 함 예시 코드#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;void print_num(int count, ...){ va_list ap;\tint\t\tnum;\tint\t\ti; va_start(ap, count); for (i = 1; i &lt;= count; i++) { num = va_arg(ap, int);\t\tprintf(\"%d x %d = %d\\n\", i, num, i * num); } va_end(ap);}int main(void){ print_num(3, 2, 4, 6); return (0);}출력결과1 x 2 = 22 x 4 = 83 x 6 = 18Ref.https://dojang.io/mod/page/view.php?id=736https://kirkim.github.io/42seoul/2021/03/03/a_formatted.htmlhttps://dojang.io/mod/page/view.php?id=577https://hashcode.co.kr/questions/934/형식지정자-i-d-차이https://jungpaeng.tistory.com/33https://waintman.tistory.com/55https://velog.io/@24siefil/ftprintf-Variadic-Arguments" }, { "title": "ft_printf ① Subject", "url": "/posts/ft_printf1/", "categories": "42Seoul, ft_printf", "tags": "42seoul, c", "date": "2022-06-10 00:00:00 +0900", "snippet": "PdfSummary이 프로젝트의 목표는 매우 간단합니다. printf()를 다시 코드화합니다. 당신은 가변 인자를 사용하는 것에 대해 배울 것입니다.Mandatory partlibc의 printf() 함수를 다시 코딩해야 합니다.ft_printf()의 프로토타입 :int ft_printf(const char *, ...);요구 사항은 다음과 같습니다. 원본 printf()의 버퍼 관리(buffer management)를 구현하지 마십시오. 함수는 다음 변환을 처리해야 합니다. cspdiuxX% 함수는 원본 printf()와 비교됩니다. 라이브러리를 만들려면 ar 명령어를 사용해야 합니다. libtool 명령을 사용할 수 없습니다. libftprintf.a는 리포지토리의 루트에 생성되어야 합니다.다음의 변환을 구현해야 합니다. %c 단일 문자를 출력합니다. %s 일반 C 규칙에 정의된 대로 문자열을 출력합니다. %p void * 포인터 인수는 16진수 형식으로 출력해야 합니다. %d 십진수(밑이 10) 숫자를 출력합니다. %i 밑이 10인 정수를 출력합니다. %u 부호 없는 10진수(밑이 10) 숫자를 출력합니다. %x 숫자를 16진수(밑이 16) 소문자 형식으로 출력합니다. %X 숫자를 16진수(밑이 16) 대문자로 출력합니다. %% 백분율 기호를 출력합니다.Bonus part모든 보너스를 구현할 필요는 없습니다.보너스 리스트: 다음 플래그들의 조합(any combination)을 구현하세요 : ‘-0.’ 그리고 각 서식 지정자별 최소 폭 다음 플래그를 모두 관리합니다. ‘# +’ (맞아요, 이 중 하나는 공백입니다.)" }, { "title": "Get Next Line ⑤ 기타", "url": "/posts/gnl5/", "categories": "42Seoul, get_next_line", "tags": "42seoul, c", "date": "2022-06-09 00:00:00 +0900", "snippet": "과제 유의사항메모리 관리GNL 과제를 진행하며 메모리 관리의 중요성을 계속해서 느꼈다. 이전까지는 메모리공간의 사용이 복잡하지 않아 기계적으로 malloc 뒤에 free를 해주었지만 이번 과제에서는 함수를 호출하며 해당 포인터를 인수로 넘겨주거나 반환값으로 넘겨주는 경우가 있어 꼼꼼하게 관리할 필요가 있었다.backup = ft_strjoin(backup, buffer); 위와 같이 get_next_line 함수 안에서 아래의 ft_strjoin으로 backup 뒤에 buffer를 추가해주었다. 하지만 테스터에서 계속해서 Memory leak이 발생했다.ft_strjoin.c char\t*ft_strjoin(char *s1, char *s2){\tchar\t*result;\tsize_t\ti;\tsize_t\tj;\tif (!s1)\t{\t\ts1 = (char *)malloc(1 * sizeof(char));\t\ts1[0] = '\\0';\t}\tif (!s1 || !s2)\t\treturn (NULL);\ti = ft_strlen(s1);\tj = ft_strlen(s2);\tresult = (char *)malloc(i + j + 1);\tif (!result)\t\treturn (NULL);\tft_strlcpy(result, s1, i + 1);\tft_strlcpy(result + i, s2, j + 1);\tfree(s1); // 추가한 부분\treturn (result);}위 코드가 leak이 발생했던 이유는 인자로 들어온 동적할당한 포인터 s1(기존의 backup)은 이 함수에서 사용되고 반환되지 않기 때문이다. 따라서 새롭게 메모리 해제를 위한 코드를 추가해주었다.ft_strjoin.c char\t*ft_strjoin(char *s1, char *s2){\tchar\t*result;\tsize_t\ti;\tsize_t\tj;\tif (!s1)\t{\t\ts1 = (char *)malloc(1 * sizeof(char));\t\ts1[0] = '\\0';\t}\tif (!s1 || !s2)\t\treturn (NULL);\ti = ft_strlen(s1);\tj = ft_strlen(s2);\tresult = (char *)malloc(i + j + 1);\tif (!result)\t\treturn (NULL);\tft_strlcpy(result, s1, i + 1);\tft_strlcpy(result + i, s2, j + 1);\tfree(s1); // 추가한 부분\treturn (result);}나는 아래의 방법을 통해 누수가 발견되면 디버거를 사용하여 각각의 동적할당된 변수를 따라가면서 마지막으로 사용된 위치를 찾는 방법으로 메모리 관리를 수월하게 할 수 있었다. 검사방법 main문 마지막에 아래 코드 삽입해서 검사system(\"leaks a.out &gt; leaks_result_temp; cat leaks_result_temp | grep leaked &amp;&amp; rm -rf leaks_result_temp\"); valgrind 사용 sanitizer 사용 더 공부할 내용 포인터 배열 개념 메모리 누수 확인방법 (valgrind, sanitizer 사용법)" }, { "title": "Printf Manual", "url": "/posts/printf-manual/", "categories": "42Seoul, ft_printf", "tags": "42seoul, c", "date": "2022-06-09 00:00:00 +0900", "snippet": "C Programming Standard7.19.6.3 The printf functionSynopsis#include &lt;stdio.h&gt;int printf(const char * restrict format, ...);DescriptionThe printf function is equivalent to fprintf with the argument stdoutinterposed before the arguments to printf.ReturnsThe printf function returns the number of characters transmitted, or a negative value if an output or encoding error occurred.man pagePRINTF(3) Library Functions Manual PRINTF(3)NAME printf, fprintf, sprintf, snprintf, asprintf, dprintf, vprintf, vfprintf, vsprintf, vsnprintf, vasprintf, vdprintf – formatted output conversionLIBRARY Standard C Library (libc, -lc)SYNOPSIS #include &lt;stdio.h&gt; int printf(const char * restrict format, ...); int fprintf(FILE * restrict stream, const char * restrict format, ...); int sprintf(char * restrict str, const char * restrict format, ...); int snprintf(char * restrict str, size_t size, const char * restrict format, ...); int asprintf(char **ret, const char *format, ...); int dprintf(int fd, const char * restrict format, ...); #include &lt;stdarg.h&gt; int vprintf(const char * restrict format, va_list ap); int vfprintf(FILE * restrict stream, const char * restrict format, va_list ap); int vsprintf(char * restrict str, const char * restrict format, va_list ap); int vsnprintf(char * restrict str, size_t size, const char * restrict format, va_list ap); int vasprintf(char **ret, const char *format, va_list ap); int vdprintf(int fd, const char * restrict format, va_list ap);DESCRIPTION The printf() family of functions produces output according to a format as described below. The printf() and vprintf() functions write output to stdout, the standard output stream; fprintf() and vfprintf() write output to the given output stream; dprintf() and vdprintf() write output to the given file descriptor; sprintf(), snprintf(), vsprintf(), and vsnprintf() write to the character string str; and asprintf() and vasprintf() dynamically allocate a new string with malloc(3). Extended locale versions of these functions are documented in printf_l(3). See xlocale(3) for more information. These functions write the output under the control of a format string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of stdarg(3)) are converted for output. The asprintf() and vasprintf() functions set *ret to be a pointer to a buffer sufficiently large to hold the formatted string. This pointer should be passed to free(3) to release the allocated storage when it is no longer needed. If sufficient space cannot be allocated, asprintf() and vasprintf() will return -1 and set ret to be a NULL pointer. The snprintf() and vsnprintf() functions will write at most size-1 of the characters printed into the output string (the size'th character then gets the terminating ‘\\0’); if the return value is greater than or equal to the size argument, the string was too short and some of the printed characters were discarded. The output is always null-terminated, unless size is 0. The sprintf() and vsprintf() functions effectively assume a size of INT_MAX + 1. For those routines that write to a user-provided character string, that string and the format strings should not overlap, as the behavior is undefined. The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the % character. The arguments must correspond properly (after type promotion) with the conversion specifier. After the %, the following appear in sequence: • An optional field, consisting of a decimal digit string followed by a $, specifying the next argument to access. If this field is not provided, the argument following the last argument accessed will be used. Arguments are numbered starting at 1. If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate. • Zero or more of the following flags: ‘#’ The value should be converted to an “alternate form”. For c, d, i, n, p, s, and u conversions, this option has no effect. For o conversions, the precision of the number is increased to force the first character of the output string to a zero. For x and X conversions, a non-zero result has the string ‘0x’ (or ‘0X’ for X conversions) prepended to it. For a, A, e, E, f, F, g, and G conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows). For g and G conversions, trailing zeros are not removed from the result as they would otherwise be. ‘0’ (zero) Zero padding. For all conversions except n, the converted value is padded on the left with zeros rather than blanks. If a precision is given with a numeric conversion (d, i, o, u, i, x, and X), the 0 flag is ignored. ‘-’ A negative field width flag; the converted value is to be left adjusted on the field boundary. Except for n conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A - overrides a 0 if both are given. ‘ ’ (space) A blank should be left before a positive number produced by a signed conversion (a, A, d, e, E, f, F, g, G, or i). ‘+’ A sign must always be placed before a number produced by a signed conversion. A + overrides a space if both are used. ‘'’ (apostrophe) Decimal conversions (d, u, or i) or the integral portion of a floating point conversion (f or F) should be grouped and separated by thousands using the non-monetary separator returned by localeconv(3). • An optional separator character (  , | ; |  : | _ ) used for separating multiple values when printing an AltiVec or SSE vector, or other multi-value unit. NOTE: This is an extension to the printf() specification. Behaviour of these values for printf() is only defined for operating systems conforming to the AltiVec Technology Programming Interface Manual. (At time of writing this includes only Mac OS X 10.2 and later.) • An optional decimal digit string specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width. • An optional precision, in the form of a period . followed by an optional digit string. If the digit string is omitted, the precision is taken as zero. This gives the minimum number of digits to appear for d, i, o, u, x, and X conversions, the number of digits to appear after the decimal-point for a, A, e, E, f, and F conversions, the maximum number of significant digits for g and G conversions, or the maximum number of characters to be printed from a string for s conversions. • An optional length modifier, that specifies the size of the argument. The following length modifiers are valid for the d, i, n, o, u, x, or X conversion: Modifier d, i o, u, x, X n hh signed char unsigned char signed char * h short unsigned short short * l (ell) long unsigned long long * ll (ell ell) long long unsigned long long long long * j intmax_t uintmax_t intmax_t * t ptrdiff_t (see note) ptrdiff_t * z (see note) size_t (see note) q (deprecated) quad_t u_quad_t quad_t * Note: the t modifier, when applied to a o, u, x, or X conversion, indicates that the argument is of an unsigned type equivalent in size to a ptrdiff_t. The z modifier, when applied to a d or i conversion, indicates that the argument is of a signed type equivalent in size to a size_t. Similarly, when applied to an n conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a size_t. The following length modifier is valid for the a, A, e, E, f, F, g, or G conversion: Modifier a, A, e, E, f, F, g, G l (ell) double (ignored, same behavior as without it) L long double The following length modifier is valid for the c or s conversion: Modifier c s l (ell) wint_t wchar_t * The AltiVec Technology Programming Interface Manual also defines five additional length modifiers which can be used (in place of the conventional length modifiers) for the printing of AltiVec or SSE vectors: v Treat the argument as a vector value, unit length will be determined by the conversion specifier (default = 16 8-bit units for all integer conversions, 4 32-bit units for floating point conversions). vh, hv Treat the argument as a vector of 8 16-bit units. vl, lv Treat the argument as a vector of 4 32-bit units. NOTE: The vector length specifiers are extensions to the printf() specification. Behaviour of these values for printf() is only defined for operating systems conforming to the AltiVec Technology Programming Interface Manual. (At time of writing this includes only Mac OS X 10.2 and later.) As a further extension, for SSE2 64-bit units: vll, llv Treat the argument as a vector of 2 64-bit units. • A character that specifies the type of conversion to be applied. A field width or precision, or both, may be indicated by an asterisk ‘*’ or an asterisk followed by one or more decimal digits and a ‘$’ instead of a digit string. In this case, an int argument supplies the field width or precision. A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing. If a single format directive mixes positional (nn$) and non-positional arguments, the results are undefined. The conversion specifiers and their meanings are: diouxX The int (or appropriate variant) argument is converted to signed decimal (d and i), unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x and X) notation. The letters “abcdef” are used for x conversions; the letters “ABCDEF” are used for X conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros. DOU The long int argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been ld, lo, or lu respectively. These conversion characters are deprecated, and will eventually disappear. eE The double argument is rounded and converted in the style [-]d.ddde±dd where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears. An E conversion uses the letter ‘E’ (rather than ‘e’) to introduce the exponent. The exponent always contains at least two digits; if the value is zero, the exponent is 00. For a, A, e, E, f, F, g, and G conversions, positive and negative infinity are represented as inf and -inf respectively when using the lowercase conversion character, and INF and -INF respectively when using the uppercase conversion character. Similarly, NaN is represented as nan when using the lowercase conversion, and NAN when using the uppercase conversion. fF The double argument is rounded and converted to decimal notation in the style [-]ddd.ddd, where the number of digits after the decimal-point character is equal to the precision specification. If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it. gG The double argument is converted in style f or e (or F or E for G conversions). The precision specifies the number of significant digits. If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style e is used if the exponent from its conversion is less than -4 or greater than or equal to the precision. Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit. aA The double argument is rounded and converted to hexadecimal notation in the style [-]0xh.hhhp[±]d, where the number of digits after the hexadecimal-point character is equal to the precision specification. If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs. If the precision is zero, no hexadecimal-point character appears. The p is a literal character ‘p’, and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2. The A conversion uses the prefix “0X” (rather than “0x”), the letters “ABCDEF” (rather than “abcdef”) to represent the hex digits, and the letter ‘P’ (rather than ‘p’) to separate the mantissa and exponent. Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format. For example, 0x1.92p+1, 0x3.24p+0, 0x6.48p-1, and 0xc.9p-2 are all equivalent. The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized. Zeroes are always represented with a mantissa of 0 (preceded by a ‘-’ if appropriate) and an exponent of +0. C Treated as c with the l (ell) modifier. c The int argument is converted to an unsigned char, and the resulting character is written. If the l (ell) modifier is used, the wint_t argument shall be converted to a wchar_t, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences. If a shift sequence is used, the shift state is also restored to the original state after the character. S Treated as s with the l (ell) modifier. s The char * argument is expected to be a pointer to an array of character type (pointer to a string). Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character. If the l (ell) modifier is used, the wchar_t * argument is expected to be a pointer to an array of wide characters (pointer to a wide string). For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences. If any shift sequence is used, the shift state is also restored to the original state after the string. Wide characters from the array are written up to (but not including) a terminating wide NUL character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences). Partial characters are never written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide NUL character. p The void * pointer argument is printed in hexadecimal (as if by ‘%#x’ or ‘%#lx’). n The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is converted. The format argument must be in write-protected memory if this specifier is used; see SECURITY CONSIDERATIONS below. % A ‘%’ is written. No argument is converted. The complete conversion specification is ‘%%’. The decimal point character is defined in the program's locale (category LC_NUMERIC). In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.RETURN VALUES These functions return the number of characters printed (not including the trailing ‘\\0’ used to end output to strings), except for snprintf() and vsnprintf(), which return the number of characters that would have been printed if the size were unlimited (again, not including the final ‘\\0’). These functions return a negative value if an error occurs.EXAMPLES To print a date and time in the form “Sunday, July 3, 10:02”, where weekday and month are pointers to strings: #include &lt;stdio.h&gt; fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min); To print pi to five decimal places: #include &lt;math.h&gt; #include &lt;stdio.h&gt; fprintf(stdout, \"pi = %.5f\\n\", 4 * atan(1.0)); To allocate a 128 byte string and print into it: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdarg.h&gt; char *newfmt(const char *fmt, ...) { char *p; va_list ap; if ((p = malloc(128)) == NULL) return (NULL); va_start(ap, fmt); (void) vsnprintf(p, 128, fmt, ap); va_end(ap); return (p); }COMPATIBILITY The conversion formats %D, %O, and %U are not standard and are provided only for backward compatibility. The effect of padding the %p format with zeros (either by the 0 flag or by specifying a precision), and the benign effect (i.e., none) of the # flag on %n and %p conversions, as well as other nonsensical combinations such as %Ld, are not standard; such combinations should be avoided.ERRORS In addition to the errors documented for the write(2) system call, the printf() family of functions may fail if: [EILSEQ] An invalid wide character code was encountered. [ENOMEM] Insufficient storage space is available.SEE ALSO printf(1), printf_l(3), fmtcheck(3), scanf(3), setlocale(3), stdarg(3), wprintf(3)STANDARDS Subject to the caveats noted in the BUGS section below, the fprintf(), printf(), sprintf(), vprintf(), vfprintf(), and vsprintf() functions conform to ANSI X3.159-1989 (“ANSI C89”) and ISO/IEC 9899:1999 (“ISO C99”). With the same reservation, the snprintf() and vsnprintf() functions conform to ISO/IEC 9899:1999 (“ISO C99”), while dprintf() and vdprintf() conform to IEEE Std 1003.1-2008 (“POSIX.1”).HISTORY The functions asprintf() and vasprintf() first appeared in the GNU C library. These were implemented by Peter Wemm &lt;peter@FreeBSD.org&gt; in FreeBSD 2.2, but were later replaced with a different implementation from OpenBSD 2.3 by Todd C. Miller &lt;Todd.Miller@courtesan.com&gt;. The dprintf() and vdprintf() functions were added in FreeBSD 8.0.BUGS The printf family of functions do not correctly handle multibyte characters in the format argument.SECURITY CONSIDERATIONS The sprintf() and vsprintf() functions are easily misused in a manner which enables malicious users to arbitrarily change a running program's functionality through a buffer overflow attack. Because sprintf() and vsprintf() assume an infinitely long string, callers must be careful not to overflow the actual space; this is often hard to assure. For safety, programmers should use the snprintf() interface instead. For example: void foo(const char *arbitrary_string, const char *and_another) { char onstack[8]; #ifdef BAD /* * This first sprintf is bad behavior. Do not use sprintf! */ sprintf(onstack, \"%s, %s\", arbitrary_string, and_another); #else /* * The following two lines demonstrate better use of * snprintf(). */ snprintf(onstack, sizeof(onstack), \"%s, %s\", arbitrary_string, and_another); #endif } The printf() and sprintf() family of functions are also easily misused in a manner allowing malicious users to arbitrarily change a running program's functionality by either causing the program to print potentially sensitive data “left on the stack”, or causing it to generate a memory fault or bus error by dereferencing an invalid pointer. %n can be used to write arbitrary data to potentially carefully- selected addresses. Programmers are therefore strongly advised to never pass untrusted strings as the format argument, as an attacker can put format specifiers in the string to mangle your stack, leading to a possible security hole. This holds true even if the string was built using a function like snprintf(), as the resulting string may still contain user-supplied conversion specifiers for later interpolation by printf(). For this reason, a format argument containing %n is assumed to be untrustworthy if located in writable memory (i.e. memory with protection PROT_WRITE; see mprotect(2)) and any attempt to use such an argument is fatal. Practically, this means that %n is permitted in literal format strings but disallowed in format strings located in normal stack- or heap-allocated memory. Always use the proper secure idiom: snprintf(buffer, sizeof(buffer), \"%s\", string);macOS 12.4 December 2, 2009 macOS 12.4(END)" }, { "title": "Get Next Line ④ 프로젝트 구현 (Mandatory, Bonus part)", "url": "/posts/gnl4/", "categories": "42Seoul, get_next_line", "tags": "42seoul, c", "date": "2022-06-03 00:00:00 +0900", "snippet": "Mandatory part과제 설명char *get_next_line(int fd); 매개변수 fd: 읽어야 할 파일의 디스크립터 반환값 읽은 line: 한 줄을 제대로 읽음 NULL : 더이상 읽을게 없음 or 에러 발생 사용가능 외부함수 read, malloc, free gnl각각의 함수의 역할은 다음과 같다.get_next_line : 3개의 함수를 호출ft_read_data : 데이터를 개행문자가 나올때까지 버퍼크기만큼 읽고 저장ft_extract_line : 맨 앞부터 개행문자까지 저장ft_save_rest : 개행문자 뒷부분 저장get_next_line 전체적인 동작을 관리하는 함수ex) text : abc\\nde\\nf\\0 변수 char *line; : 한 줄+개행문자를 저장해 리턴할 변수 static char *backup; : 다음에 읽을 데이터의 시작 주소 char *text = \"abc\\nde\\nf\"char *line = \"abc\\n\"char *backup = \"de\\nf\"// 전부 맨 뒤에 '\\0' 포함 fd 유효성 체크 정적변수의 사용static char *backup;정적변수의 특성상 함수가 종료되어도 저장해놓은 문자열을 잃지 않음지역변수로 선언되었다면 문자열을 잃어버려 메모리 누수 발생함ft_read_data 데이터를 읽고 ‘\\n’이 나올때까지의 line을 BUFFER_SIZE의 배수만큼 읽어들여 반환ex) BUFFER_SIZE : 3, backup : abc\\nde 변수 char *buffer; : read해서 저장해 둘 데이터의 시작주소 int bytes_read : read한 데이터의 바이트수 동작방식 read로 읽고 bytes_read에 읽은 바이트 저장 bytes_read로 read함수가 읽어들인 바이트 체크(0,-1,나머지) strchr로 개행문자 체크 buffer[bytes_read]=0 : 버퍼의 데이터를 문자열로 만듦 기존 backup에 읽어들인 buffer 이어붙임(ft_strjoin 기존함수와의 차이점: NULL이 들어왔을 때 처리) buffer 메모리 해제 후 backup 반환 기타 buffer 변수를 동적할당할 때 malloc 대신 calloc을 사용한 이유? → 맨 처음 while문이 동작할 때 buffer 안에는 쓰레기값이 들어있으므로 strchr이 ‘\\n’을 검색하는 과정에서 의도치 않게 동작할 수 있음 strchr이 backup이 아닌 buffer를 탐색하는 이유? → backup의 경우 행의 길이가 길어지면 while문을 반복하는 동안 탐색했던 위치를 재탐색하는 비효율적인 과정을 거치게됨 ft_extract_line backup[fd]에서 \\n을 포함한 앞부분 분리(리턴할 line)ex) line : abc\\n\\0 변수 char *line : 인수로 들어온 backup에서 개행문자 뒷부분을 제외한 데이터의 시작주소 int i : backup과 line 배열의 인덱스 동작방식 null값 처리 backup 배열의 값이 ‘\\0’이거나 ‘\\n’일 때까지 뒤로 이동해서 끝위치 파악 파악한 위치 활용해서 line에 메모리 할당(끝에 ‘\\n’과 ‘\\0’자리 포함) 다시 맨 앞부터 메모리 복사 맨 끝이 개행문자다? 개행저장하고 다음값을 null로 아니다? null만 복사 만든 line 반환 ft_save_rest backup[fd]에서 \\n을 제외한 뒷부분 분리(저장할 부분)ex) rest : de\\0 변수 char *rest : backup에서 개행문자 뒷부분을 저장할 포인터 int idx1 : backup 배열의 인덱스 int idx2 : rest 배열의 인덱스 동작방식 backup의 맨 처음부분부터 돌면서 개행문자나 널문자가 나올때까지 이동 그대로 끝난다면 backup을 해제하고 널 반환 rest에 메모리 할당(ft_strlen(backup) - idx1 + 1 : 뒷부분길이 + 널값) rest에 backup 뒷부분을 저장 후 backup은 메모리 해제 gnl_utils 사용한 함수 ft_strlen ft_strlcpy-strjoin에서 사용 ft_strchr ft_strjoin ft_calloc 기존 libft와의 차이점 ft_calloc count * size &gt; SIZE_MAX 처리하는 부분 제외 ft_strjoin 앞부분 인수로 들어온 s1이 NULL일 경우 크기가 1인 메모리공간을 할당함 (맨 처음에 backup이 아무곳도 가리키지 않는 경우) if (!s1) \t{ \t\ts1 = (char *)malloc(1 * sizeof(char)); \t\ts1[0] = '\\0'; \t} 끝부분에 s1을 free함 headerget_next_line.h#ifndef GET_NEXT_LINE_H# define GET_NEXT_LINE_H# include &lt;stdlib.h&gt;# include &lt;unistd.h&gt;# ifndef BUFFER_SIZE# define BUFFER_SIZE 50# endif// gnlchar\t*get_next_line(int fd);// gnl_utilssize_t\tft_strlen(char *s);size_t\tft_strlcpy(char *dst, char *src, size_t dstsize);char\t*ft_strjoin(char *s1, char *s2);char\t*ft_strchr(char *s, int c);void\t*ft_calloc(size_t count, size_t size);#endif표준 라이브러리 stdlib.h malloc free unistd.h read #define BUFFER_SIZE 컴파일시에 정의되는 경우 고려해서 ifndef 사용 Bonus part파일 디스크립터 여러개를 관리할 수 있는 함수 만들기.get_next_line 변수 static char *backup[OPEN_MAX + 1]; : 다음에 읽을 line의 시작 주소를 계속 저장해둘 변수 정적변수의 사용 static char *backup[OPEN_MAX];* ** 과 같이 이중포인터를 사용한다면 array to pointer decay(배열의 크기를 잃어버리는 것)가 발생함 포인터 배열 배열의 요소로 포인터를 갖는 배열각각의 backup 배열의 요소에 각 fd에서 읽어들인 부분을 저장하기 위해 사용 (참고) fd 유효성 체크 : fd &gt; OPEN_MAX : read함수가 읽어들일 수 있는 최대 파일의 개수를 초과한 것 배열의 크기 관련headerget_next_line_bonus.h#ifndef GET_NEXT_LINE_BONUS_H# define GET_NEXT_LINE_BONUS_H# include &lt;stdlib.h&gt;# include &lt;unistd.h&gt;# ifndef OPEN_MAX# define OPEN_MAX 256# endif# ifndef BUFFER_SIZE# define BUFFER_SIZE 50# endif// gnlchar\t*get_next_line(int fd);// gnl_utilssize_t\tft_strlen(char *s);size_t\tft_strlcpy(char *dst, char *src, size_t dstsize);char\t*ft_strjoin(char *s1, char *s2);char\t*ft_strchr(char *s, int c);void\t*ft_calloc(size_t count, size_t size);#endifTest1. 메인함수 활용test_main.c#include \"get_next_line.h\"#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int\tmain(void){\tchar\t*line;\tint\t\tfd;\tfd = 0;\tfd = open(\"./test\", O_RDONLY);\tline = \"\\0\";\twhile (line)\t{\t\tline = get_next_line(fd);\t\tprintf(\"%s\\n\", line);\t\tfree(line);\t}\treturn (0);}테스트용 문서는 test라고 이름붙이고 같은 경로에 위치방법 1. BUFFER_SIZE를 그대로 컴파일gcc -Wall -Wextra -Werror get_next_line.c get_next_line_utils.c test_main.c방법 2. BUFFER_SIZE를 변경하여 컴파일gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 get_next_line.c get_next_line_utils.c test_main.cBUFFER_SIZE 대신 OPEN_MAX를 넣어도 원하는 결과를 낼 수 있음(표준 라이브러리(limits.h)를 include하지 않고 직접 상수를 define한 경우)gcc -D gcc -D [name]=[definition] #define을 프로그램 외부에서 정의하고 컴파일 시 반영할 수 있음gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 get_next_line.c get_next_line_utils.c2. 테스터 활용gnlTester 사용 방법 make m : mandatory 테스트 make b : bonus 테스트 make a : 둘 다 테스트 Ref.static 변수포인터 배열프로젝트 참고" }, { "title": "Dangling pointer(댕글링 포인터)", "url": "/posts/dangling-pointer/", "categories": "TIL", "tags": "c", "date": "2022-06-01 22:24:31 +0900", "snippet": "Description해제된 메모리 영역을 가리키고 있는 포인터char *ptr1 = (char *)malloc(sizeof(char));...free(ptr1);위의 ptr1이 가리키는 메모리 영역은 free함수로 해제됐지만 ptr1은 여전히 해당 영역을 가리킨다.(변수가 삭제되지 않았기 때문)Problem예측 불가능한 동작 (메모리 접근 시)Segmentation fault (메모리 접근 불가 시)잠재적인 보안 위험Solution메모리 해제 후 포인터를 NULL로 설정char *ptr1 = (char *)malloc(sizeof(char));...free(ptr1);ptr1 = NULL;Ref.https://80000coding.oopy.io/77c32056-1ba6-40ad-9a2b-0d3cdf270888https://thinkpro.tistory.com/67" }, { "title": "메모리 구조", "url": "/posts/memory-structure/", "categories": "TIL", "tags": "cs", "date": "2022-06-01 22:22:58 +0900", "snippet": "메모리 공간의 구분 코드(code) 영역 데이터(data) 영역 스택(stack) 영역 힙(heap) 영역*Heap과 Stack의 데이터 저장 방향은 운영체제 따라 다르다고 함.메모리 해제Data 영역: 프로세스가 종료되면 소멸함Stack 영역: 함수 종료 시 제거됨Heap 영역: 개발자가 직접 free !!Ref.http://www.tcpschool.com/c/c_memory_structure" }, { "title": "Memory leak(메모리 누수)", "url": "/posts/memory-leak/", "categories": "TIL", "tags": "c", "date": "2022-06-01 22:20:55 +0900", "snippet": "free(buf) 와 buf = 0 의 차이? free(buf) : 할당받은 메모리를 해제 buf = 0 : 할당받은 메모리 주소를 담고있는 buf 변수가 0 값을 갖게 됨 → memory leak!" }, { "title": "컴파일의 4단계", "url": "/posts/4step-compiling/", "categories": "TIL", "tags": "c", "date": "2022-06-01 22:18:13 +0900", "snippet": "전처리주석제거헤더 파일 삽입매크로 치환 및 적용컴파일언어의 문법 검사static 영역(Data, BSS 영역)의 메모리 할당어셈블리어셈블러를 통해 어셈블리어 파일을 오브젝트 파일로 변환링킹링커를 통해 오브젝트 파일과 라이브러리를 묶어서 실행파일 생성Ref.https://bradbury.tistory.com/226" }, { "title": "0, ‘\\0’, NULL 차이점", "url": "/posts/null-difference/", "categories": "TIL", "tags": "c", "date": "2022-06-01 22:15:57 +0900", "snippet": "의미char null_1 = '\\0';char null_2 = 0;char null_3 = (char)NULL;3개 모두 결과는 동일하지만 해석방식의 차이가 있음.null_1 : \\0의 아스키 값인 0이 저장됨null_2 : 0이 바로 저장됨null_3 : NULL은 헤더파일에 (void *)0으로 저장되어 있음.→ 0이 저장됨.예외사항char null_4 = '0';null_4 : ‘0’은 문자 0을 의미하기 때문에 아스키코드 상의 값인 48이 저장됨.Ref.https://modoocode.com/29https://code4human.tistory.com/116" }, { "title": "배열과 포인터를 활용한 다양한 표현", "url": "/posts/array-pointer-expressions/", "categories": "TIL", "tags": "c", "date": "2022-06-01 00:00:00 +0900", "snippet": "char arr[3] = {'a','b','c'};배열요소arr[0] : aarr[1] : b주소값&amp;arr[0] : 0x7ffd209e6cb9&amp;arr[0]+1 : 0x7ffe523d59ca포인터요소*arr : a(arr+1) : b*(&amp;arr[0]+1) : b주소값arr : 0x7ffdb7fbe519arr+1 : 0x7ffc831da80a배열에서의 주소값예시 1.#include &lt;stdio.h&gt;int main(){ char arr[] = {'a','b','c'}; printf(\"%p\\n\", arr); printf(\"%p\\n\", arr+1); printf(\"%p\\n\\n\", arr+2); printf(\"%p\\n\", &amp;arr[0]); printf(\"%p\\n\", &amp;arr[1]); printf(\"%p\\n\\n\", &amp;arr[2]); printf(\"%lu\", sizeof(arr)); return(0);}실행결과 1.0x7ffe88b761390x7ffe88b7613a0x7ffe88b7613b0x7ffe88b761390x7ffe88b7613a0x7ffe88b7613b3위와 같이 char타입의 배열을 만들게 되면 배열의 크기는 char형의 크기인 1바이트와 배열의 개수인 3개의 곱으로 나오게 됨.주소값의 경우 자료형의 크기인 1만큼 간격이 발생함.예시 2.#include &lt;stdio.h&gt;int main(){ int arr[] = {1,2,3}; printf(\"%p\\n\", arr); printf(\"%p\\n\", arr+1); printf(\"%p\\n\\n\", arr+2); printf(\"%p\\n\", &amp;arr[0]); printf(\"%p\\n\", &amp;arr[1]); printf(\"%p\\n\\n\", &amp;arr[2]); printf(\"%lu\", sizeof(arr)); return(0);}실행결과 2.0x7fffe86cbbf00x7fffe86cbbf40x7fffe86cbbf80x7fffe86cbbf00x7fffe86cbbf40x7fffe86cbbf812반면 이렇게 배열을 int형으로 선언하게 되면 자료형의 크기인 4바이트와 개수인 3개의 곱인 12가 나오게 됨.주소값의 경우 자료형의 크기인 4만큼 간격이 발생함. arr+1의 의미(포인터 변수 arr에 1을 더하는게 ox7f…f1로 1씩이 아니라 4씩 차이가 나는 이유?)포인터 변수에 1을 더하는 것은 주소를 1 증가시키는 것이 아니라 다음 위치의 데이터로 이동한다는 의미이기 때문 포인터간의 뺄셈두 주소 사이에 값이 몇개가 있는지를 의미함. 포인터간의 덧셈오류가 발생함 (정의되어 있지 않음) Ref.https://m.blog.naver.com/tipsware/221192754086" }, { "title": "Get Next Line ③ 방향 탐색", "url": "/posts/gnl3/", "categories": "42Seoul, get_next_line", "tags": "42seoul, c", "date": "2022-05-27 00:00:00 +0900", "snippet": "구현 방법간략한 방법 ‘\\n’가 포함된 버퍼까지 읽음 ‘\\n’의 뒷부분 저장 계속 읽음 EOF가 나오면 중단해결방향포인터로 해결이 가능한 mandatory 파트와 달리 추가적인 fd를 고려해야 하는 bonus 파트의 경우 해결방법이 둘로 나뉜다. 포인터 배열을 활용한 풀이 (주로 OPEN_MAX) 가변크기 자료구조를 활용한 풀이 (주로 연결 리스트)나는 아래의 몇가지 사항을 고려하여 최종적으로 OPEN_MAX를 활용해서 과제를 수행하였다.OPEN_MAX 사용 문제점 limits.h 관련 a. 사용자가 ulimit -Hn 나 ulimit -Sn 를 통해 OS의 fd limit(OPEN_MAX값)을 변경한다면 함수에 Segmentation fault가 발생할 수 있음 (관련 링크) b. norminette 문서 위배(허용된 함수의 표준라이브러리 외 include 및 매크로 상수 사용) 메모리 관련 a. 파일을 한개만 열어서 fd가 한개만 필요한 상황에서도 비효율적으로 RAM을 점유하게 될 수 있음&lt;/br&gt; 해결방안 limits.h 관련 a. 헤더파일에 OPEN_MAX 상수를 직접 정의해서 사용 메모리 관련 a. mandatory: 배열, bonus: OPEN_MAX 로 해결방식을 다양화 해서 mandatory에서 파일이 한개만 열릴 때의 문제 예방 이 방법을 선택한 이유 탐색과정의 효율성: fd=n일때의 시간복잡도 → 배열은 값을 바로 찾을 수 있지만 연결리스트는 맨 앞부터 n번째까지 탐색해야 함 fd값의 확률: 연결리스트의 장점인 OPEN_MAX 이상의 값을 처리하는 경우보다 그 이하의 값을 처리는 경우가 훨씬 많다고 판단함. 범위를 벗어가서 생기는 문제는 gnl함수에서 fd값의 유효성을 체크하는 부분에서 처리함. Ref.GNL OPEN_MAX vs Linked list?링크 1, 링크 2연결리스트, 배열 시간복잡도 차이" }, { "title": "Get Next Line ② 배경 지식", "url": "/posts/gnl2/", "categories": "42Seoul, get_next_line", "tags": "42seoul, c", "date": "2022-05-20 00:00:00 +0900", "snippet": "과제를 위한 배경 지식 static 변수 메모리의 데이터 영역에 저장됨 프로그램이 종료될 때까지 유지됨 파일 디스크립터(fd) 특정한 파일에 접근하기 위한 추상적인 키 0,1,2는 표준 POSIX 파일 서술자로 각각 표준입력, 표준출력, 표준에러를 의미함 프로세스 실행 도중 파일을 open 하면 커널은 해당 프로세스의 fd 중에 사용하지 않는 가장 작은 값을 할당함 OPEN_MAX fd의 최대값 하나의 프로세스에서 열 수 있는 최대의 파일 개수를 의미 getconf OPEN_MAX : 현재 OS에서의 OPEN_MAX값을 출력 read 함수 함수 원형 ssize_t read(int fd, void *buf, size_t nbyte); 동작 fd가 가리키는 파일에서 nbyte만큼을 가져와서 buf가 가리키는 주소에 읽음 리턴값 성공 → 읽은 바이트 or 0(EOF 읽으면) 실패 → -1 유의사항 문자열의 끝을 알리는 널문자가 별도로 추가되지 않기 때문에 따로 추가해줘야 함 gcc -D gcc -D name=definition #define을 프로그램 외부에서 정의하고 컴파일 시 반영할 수 있음 gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 get_next_line.c get_next_line_utils.c 알아두면 좋은 내용 메모리 할당 관련 Dangling pointer Double free 디버거 관련 Vscode Debugger valgrind (Mac OS에서는 Catalina까지만 지원된다고 함) lldb 메모리 구조" }, { "title": "Get Next Line ① Subject", "url": "/posts/gnl1/", "categories": "42Seoul, get_next_line", "tags": "42seoul, c", "date": "2022-05-17 00:00:00 +0900", "snippet": "PdfSummary이 프로젝트는 파일 디스크립터에서 읽은 행을 반환하는 함수를 프로그래밍하는 것입니다.Common Instructions 당신의 프로젝트는 C로 작성되어야 합니다. 당신의 프로젝트는 Norm 따라 작성되어야 합니다. 보너스 파일/함수가 있으면 norm 검사에 포함되며 내부에 norm 오류가 있으면 0점을 받게 됩니다. 정의되지 않은 동작을 제외하고 기능이 예기치 않게 종료되면 안 됩니다(segmentation fault, bus error, double free 등). 이 경우 프로젝트가 작동하지 않는 것으로 간주되어 0점을 받게 됩니다. 필요한 경우 모든 heap 할당 메모리 공간을 적절하게 확보해야 합니다. leak은 허용되지 않습니다. Subject에서 필요한 경우 소스 파일을 cc로 컴파일하고 -Wall, -Wextra 및 -Werror 플래그가 포함된 Makefile을 제출해야 합니다. Makefile은 리링크되어서는 안됩니다. Makefile에는 적어도 $(NAME), all, clean, fclean 및 re의 룰이 포함되어야 합니다. 프로젝트에 보너스를 넣으려면 메인 파트에서 금지된 다양한 헤더, 라이브러리 또는 함수가 더해진 Makefile에 보너스 룰을 포함해야 합니다. Subject가 명시하지 않는다면 보너스는 다른 _bonus.{c/h} 파일에 있어야 합니다. Mandatory와 Bonus 파트 평가는 별도로 이루어집니다. 프로젝트에서 libft를 허용한 경우 해당 소스와 관련 Makefile을 libft 폴더에 복사해야 합니다. 프로젝트의 Makefile은 Makefile을 사용하여 라이브러리를 먼저 컴파일한 후에 프로젝트를 컴파일해야 합니다. 프로젝트에 대한 테스트 프로그램은 제출하지 않아도 되고 채점되지 않겠지만 만드는 것이 좋습니다. 그것은 여러분과 동료들의 작업을 쉽게 테스트할 수 있는 기회를 줄 것입니다. 당신은 과제를 디펜스하는동안 이것이 유용하다는 것을 더욱 알게 될 것입니다. 실제로, 디펜스하는 동안, 여러분은 여러분 또는 동료의 시험을 자유롭게 사용할 수 있습니다. 할당된 Git 저장소에 작업을 제출합니다. Git 저장소에 있는 작업만 채점됩니다. Deepthought가 당신의 작품을 채점하도록 지정되어 있다면, 동료 평가 후에 이루어질 것입니다. Deepthought를 채점하는 동안 어느 부분에서든 오류가 발생한다면 평가가 중지됩니다.Mandatory part get_next_line() 함수에 대한 반복 호출(예: 루프 사용)을 통해 e file descriptor가 가리키는 텍스트 파일을 한 번에 한 줄씩 읽을 수 있습니다. 함수는 읽은 행을 반환해야 합니다. 다른 읽을 내용이 없거나 오류가 발생한 경우 NULL을 반환해야 합니다. 파일을 읽을 때와 표준 입력에서 읽을 때 모두 기능이 예상대로 작동하는지 확인합니다. 중요!! 파일의 끝에 도달하여 \\n 문자로 끝나지 않는 경우를 제외하고 반환되는 행에는 종료 \\n 문자가 포함되어야 합니다. 헤더 파일 get_next_line.h에는 적어도 get_next_line() 함수의 프로토타입이 포함되어야 합니다. get_next_line_utils.c 파일에 필요한 모든 helper 함수를 추가합니다. get_next_line()의 파일을 읽어야 하므로 다음 옵션을 컴파일러 호출에 추가합니다 : -D BUFFER_SIZE=n 이건 read()에 대한 버퍼 크기를 정의합니다. 버퍼 크기 값은 코드를 테스트하기 위해 동료 평가자와 Moulinette에 의해 수정됩니다. 다음과 같이 코드를 컴파일합니다(버퍼 크기 42는 예시입니다). cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 &lt;files&gt;.c file descriptor가 가리키는 파일이 마지막 호출 이후 변경되었지만 read()가 파일 끝에 도달하지 않은 경우 get_next_line()은 정의되지 않은 동작을 하는 것으로 간주합니다. 또한 get_next_line()은 바이너리 파일을 읽을 때 정의되지 않은 동작을 하는 것으로 간주합니다. 그러나 원한다면 이 동작을 처리하는 논리적인 방법을 구현할 수 있습니다.forbidden 이 프로젝트에서 libft를 사용할 수 없습니다. lseek()는 금지되어 있습니다. 전역 변수는 사용할 수 없습니다.Bonus part이 프로젝트는 간단하며 복잡한 보너스를 허용하지 않습니다. 하지만, 우리는 당신의 창의성을 신뢰합니다. 필수 파트를 완료한 경우 이 보너스 파트를 시도해 보십시오.다음은 보너스 부품 요구 사항입니다. 정적 변수 하나만 사용하여 get_next_line()을 개발합니다. get_next_line()은 여러 file descriptor를 동시에 관리할 수 있습니다.예를 들어, file descriptor 3, 4, 5에서 읽을 수 있는 경우 각 file descriptor의 읽기 스레드를 손실하거나 다른 fd에서 줄을 반환하지 않고 호출당 다른 fd에서 읽을 수 있어야 합니다.즉, get_next_line()을 호출하여 fd 3에서 읽은 다음 fd 4, 5에서 호출하고 다시 3, 다시 4에서 호출할 수 있습니다.보너스 파트 파일들에 _bonus.[c\\h] 접미사를 추가하세요.즉, mandatory part의 파일과 함께 다음 3개의 파일을 제출해야 합니다. get_next_line_bonus.c get_next_line_bonus.h get_next_line_utils_bonus.c" }, { "title": "Libft ⑤ Bonus part", "url": "/posts/libft5/", "categories": "42Seoul, Libft", "tags": "42seoul, c", "date": "2022-05-16 00:00:00 +0900", "snippet": "Synopsistypedef struct s_list{\tvoid\t\t\t*content;\tstruct s_list\t*next;}\t\t\t\t\tt_list; content: 노드에 들어있는 데이터(void형이라 다 가능함) next: 다음 노드의 주소 or NULL(마지막 노드면) 멤버 연산자 개념 (. 대신 -&gt; 통해 멤버 참조)Functionsft_lstnew 첫 노드를 생성하는 함수node-&gt;content = content; //구조체 포인터로 멤버에 접근node-&gt;next = NULL; 구현방법 malloc&amp;널체크 content에 인수 content 저장 next에 NULL 저장 ft_lstadd_frontvoid ft_lstadd_front(t_list **lst, t_list *new) 앞쪽에 새로운 노드를 추가하는 함수 매개변수 t_list **lst : 삽입될 리스트 *lst : 첫 번째 연결 리스트의 포인터 주소 t_list *new : 리스트에 더해질 노드 new : 새로운 노드의 포인터 주소 구현방법 널체크 new→next = *lst : new 노드가 가리키는 값을 리스트의 첫 노드로 설정 *lst = new : lst의 첫노드를 new로 변경 ft_lstsize 리스트의 길이 세는 함수 반환값: 리스트의 노드 개수 매개변수: lst: 리스트의 시작주소 구현방법lst = lst-&gt;next : 포인터에 다음 노드의 주소 저장ft_lstlast 마지막 노드를 반환하는 함수 구현방법 노드가 널값을 가리킬 때까지 이동한 후 리턴 lst-&gt;next 가 NULL? == 노드가 널값을 가리킴 ft_lstadd_back 리스트 끝에 new 노드를 추가하는 함수void ft_lstadd_back(t_list **lst, t_list *new) 매개변수 lst: 첫 번째 연결리스트의 포인터 주소 new: 새로 추가할 노드의 포인터 주소 구현방법 노드(*lst)가 NULL이면 new노드로 바꿔주고 끝냄 ft_lstlast(*lst))-&gt;next = new : 기존의 마지막 노드가 가리키는 값을 새로운 노드의 시작주소가 되도록 설정 ft_lstdelone 특정 노드를 삭제하는 함수void ft_lstdelone(t_list *lst, void (*del)(void *)) 매개변수 lst void (*del)(void *) : void *형을 매개변수로 가진 삭제 함수 포인터 구현과정 노드의 content를 삭제(del) 해당 노드를 free ft_lstclear 모든 노드를 삭제하는 함수 구현방법 tmp에 첫 노드의 next 멤버를 저장 ft_lstdelone 활용해서 현재 노드를 삭제&amp;free 첫 노드를 tmp로(2번째 노드가 첫노드로 변경됨)  lst의 메모리가 해제되었다는 것을 명시적으로 알려주기 위해 *lst에 NULL을 할당 참고 lst == NULL: 연결리스트 자체가 없음 *lst == NULL 연결리스트에 노드가 없이 비어있음 ft_lstiter 노드의 모든 요소에 함수를 적용시키는 함수 매개변수 lst: 리스트의 포인터 주소 f: 리스트에 적용할 함수포인터 구현방법 while문으로 끝까지 돌리기 f(lst→contenxt) : 노드에 f함수를 적용함 lst = lst-&gt;next : 현재 노드가 가리키는 노드로 lst를 바꿔줌 ft_lstmap 연결리스트의 노드요소들에 함수를 적용해서 새 리스트와 노드에 복사하는 함수 매개변수 lst: 리스트의 포인터 주소 f: 각 리스트에 적용시킬 함수 del: content를 삭제하는데 사용되는 함수 반환값 새 리스트 NULL(할당 실패 시) 구현방법 널가드 tmp에 f함수포인터를 적용한 노드를 저장 tmp에 노드 만드는데 오류생기면 0리턴 result뒤에 노드 붙이기 tmp, lst 다음으로 넘기기 끝까지 돌면 result 리턴 " }, { "title": "VSCode에서 Norminette 확장 오류", "url": "/posts/vscode-norminette/", "categories": "42Seoul, etc_42", "tags": "42seoul, issue, vscode", "date": "2022-05-06 00:00:00 +0900", "snippet": "본 게시글은 linux, macOS를 기준으로 작성하였음.Issuenorminette을 Global에서 설치한 상태에서 vscode extenstion 중 42 Norminette Highlighter (3.x) 를 설치하게 되면 norminette을 찾지 못했다는 문구가 뜨면서 확장이 적용되지 않는다.Solution클러스터에서 정상 작동하던 확장이 개인 pc에서는 제대로 동작하지 않는 이유는 두 환경에서의 norminette 패키지의 설치 경로가 다르고 path가 설정되어 있지 않기 때문인 것으로 보인다.1. alias 삭제기존에 ~/.zshrc에 alias norminette=\"python3 -m norminette\" 와 같은 명령어 별칭을 지정해 두었다면 우선 별칭을 삭제한다.2. PATH 추가 /etc 로 이동 sudo vim paths 로 path 목록 수정 목록의 제일 아래에 본인의 홈디렉토리 이름에 맞게 /Users/$HOME/Library/Python/3.8/bin 을 추가(이때의 3.8로 된 Python 버전은 사용자에 따라 다를 수 있으니 사전에 해당 경로에 norminette이 존재하는지 확인)3. vscode 재시작 후 확장 설치Ref.https://jinnynote.com/learn/how-to-add-paths-on-mac/" }, { "title": "void 포인터", "url": "/posts/void-pointer/", "categories": "TIL", "tags": "c", "date": "2022-05-05 16:41:46 +0900", "snippet": " 대상이 되는 데이터의 타입을 명시하지 않은 포인터주요 특징 어떤 자료형 포인터도 void 포인터에 넣을 수 있음 void 포인터를 어떤 자료형 포인터에도 넣을 수 있음 역참조를 할 수 없음(자료형이 없음 == 값을 가져오거나 저장할 size가 정해지지 않음) 유의할 점사용하려면 명시적 형변환 과정을 먼저 거쳐야 함Ref.https://www.tcpschool.com/c/c_pointer_varioushttps://dojang.io/mod/page/view.php?id=278" }, { "title": "구조체 포인터", "url": "/posts/struct-pointer/", "categories": "TIL", "tags": "c", "date": "2022-05-05 16:34:13 +0900", "snippet": "개요struct 구조체이름 *포인터이름 = malloc(sizeof(struct 구조체이름));구조체는 크기가 크기 때문에 효율성을 위해서는 포인터에 메모리를 할당해 사용함.접근구조체 멤버에 접근하는 방법 일반 변수로 선언한 경우 . 사용 struct Person p1; p1.age = 30; 포인터로 선언한 경우 -&gt; 사용 struct Person *p1 = malloc(sizeof(struct Person)); p1-&gt;age = 30; 구조체 포인터에서 . 으로 멤버 접근하는법 p1-&gt;age;(*p1).age; 구조체 포인터를 역참조한 뒤 .으로 멤버에 접근 (*p1).age와 같이 구조체 포인터를 역참조하면, pointer to struct Person → struct Person Ref.https://dojang.io/mod/page/view.php?id=418" }, { "title": "임베디드 시스템 (Embedded System)", "url": "/posts/embedded-system/", "categories": "TIL", "tags": "cs", "date": "2022-05-05 16:29:27 +0900", "snippet": "개념장치 내에 존재하는 전자 시스템활용메인 역할은 하지 않고 보조적인 역할만 수행함선풍기, 세탁기, 인터넷 공유기 등 다양한 전자기기에 내장되어 있음사물인터넷 (IoT): 임베디드 + 인터넷Ref.https://swev.net/43" }, { "title": "norminette 개인pc 설치방법", "url": "/posts/norm-install/", "categories": "42Seoul, etc_42", "tags": "42seoul", "date": "2022-05-05 00:00:00 +0900", "snippet": " norminette을 클러스터 외부에서 설치하는 방법을 다룸본 게시글은 linux, macOS를 기준으로 작성하였음.설치 과정옵션 1. Global에서 설치 setuptools 업그레이드 python3 -m pip install --upgrade pip setuptools norminette 설치 python3 -m pip install norminette 명령어 별칭 추가 및 적용 echo 'alias norminette=\"python3 -m norminette\"' &gt;&gt; ~/.zshrc source ~/.zshrc 추후 버전 업그레이드는 아래의 명령을 통해 진행 python3 -m pip install --upgrade norminette 옵션 2. 가상환경에서 설치 가상환경 생성 python3 -m venv venv 가상환경 활성화 source venv/bin/activate norminette 설치 pip install norminette norminette 사용이 끝나면 deactivate 명령어로 가상환경 비활성화Ref.42School/norminette42Seoul Norminette 설치하기" }, { "title": "Libft ④ Additional functions", "url": "/posts/libft4/", "categories": "42Seoul, Libft", "tags": "42seoul, c", "date": "2022-04-30 00:00:00 +0900", "snippet": "Functionsft_substr s 문자열에서 start 부터 len 만큼의 문자열을 할당한 메모리에 복사char *ft_substr(char const *s, unsigned int start, size_t len) 매개변수 s: 하위 문자열을 만드는 데 사용할 문자열 start: 문자열 ‘s’에 있는 하위 문자열의 시작 인덱스 len: 하위 문자열의 최대 길이 코드 tmp = (char *)malloc(sizeof(char) * (len = s_len + 1)); : len이 쓸데없이 길게 들어오는 경우 len에 s의 길이를 저장한 채로 할당함. (size_t)start &gt;= s_len : 인덱스가 s의 길이를 벗어남 !(ft_strlcpy(tmp, s + start, len + 1)) : 가운데 매개변수의 의미: s가 0번인덱스에 해당하는 주소값 s + start는 start번 인덱스에 해당하는 주소값임. strlcpy의 return이 0이라는건 매개변수src에 해당하는 s+start가 null이라는의미 → 0번 인덱스에 null 저장. ft_strjoin 문자열 두개를 합쳐서 리턴하는 함수char *ft_strjoin(char const *s1, char const *s2) 매개변수 s1: 앞부분 s2: 뒷부분 반환값 새로운 문자열 NULL (할당실패 시) strlcat과의 차이? strlcat: 동작: 기존 문자열을 늘림. 반환: 합친문자열의 길이 strjoin: 동작: 새로운 문자열에다가 붙인걸 저장. 반환: 만든 문자열 구현방법 malloc ft_memcpy(tmp, s1, len_s1) : tmp에 s1 복사(len_s1 잴 때 널은 제외했으므로 널 빼고 복사됨) ft_memcpy(tmp + len_s1, s2, len_s2) : tmp 뒤에(s1으로 치면 널이 들어올 자리)부터 s2 붙이기 tmp[len_s1 + len_s2] = '\\0' 끝에다가 널 삽입 ft_strtrim 문자열의 시작과 끝에서 ‘set’에 지정된 문자가 제거된 ‘s1’의 복사본을 리턴char *ft_strtrim(char const *s1, char const *set) 매개변수 s1: 기존 문자열 set: 잘라낼 문자열의 참조세트 리턴값 잘린 문자열 할당실패시 → null set에 포함되는 문자가 s1의 맨 앞이랑 맨 뒤에 있으면 지워나가기(파이썬의 strip() 함수의 기능과 유사함) 구현방법 널체크 앞에서부터 strchr()로 포함되는 문자가 있으면 주소값을 더해가기 뒤에서부터 strchr()로 포함되는 문자가 있으면 인덱스를 빼가기 substr()로 0부터 i+1 만큼 복사 ft_split 문자열을 구분자로 나누어 2차원 배열에 저장해 리턴하는 함수char **ft_split(char const *s, char c) 리턴값 배열(잘린 문자열들) 할당실패시 → NULL 매개변수 s: 잘릴 문자열 c: 구분자 메모리 할당 → c로 자르고 → 배열(맨뒤는 널포인터) 리턴 메모리 할당할 크기 (아래 그림 참고) sizeof(char *) * (ft_wordnum + 1) : 2차원 (각 줄의 포인터 크기 x 줄수) (char *)malloc(idx2 + 1) : 1차원 (각 줄(단어)의 길이) ex) s=\"anthony\" c='n' 라고 할 때 아래와 같음 방법 구상 나눌 문자 개수 구하기 전체 단어용 2d malloc 단어 자르기 각 단어용 1d malloc 배열에 한 단어씩 저장 free() 반드시!! 함수 종류 ft_wordnum : 나눌 단어의 총 개수 ft_free : ft_cutword 에서 메모리할당에 실패할 때 memory leak 방지. 각 문자들을 모두 free 하고 난 후, 전체 result를 free하는 순서로 해야함. ft_cutword : 단어 자름 ft_split : 기본 함수 변수 종류 word : 단어의 개수 idx1 : (s+idx1) s에서 현재 보고있는 인덱스 idx2 : 각 단어의 길이 구현 방법 ft_split 함수 ft_wordnum으로 나눌 문자의 개수 구함 (그 개수+1)*(char *의 크기) 만큼 2d 메모리 할당(위 이미지) (result + count) = 0 배열 끝줄에 널값 넣기 ft_cutword 함수 while (*(s + idx1 + idx2) != c &amp;&amp; *(s + idx1 + idx2)) s에서 c를 찾을때의 인덱스 구함 ft_memcpy(*(result + word), s + idx1, idx2) *(*(result + word) + idx2) = 0 : 각 줄 배열의 끝칸에 널값 넣기 idx1 += idx2 : 인덱스 뒤로 땡기기 문제 생기면 (free 후) 0 리턴, 아니면 1 리턴 ft_itoa int형태로 수를 집어넣으면 문자열 형태로 리턴atoi의 반대 역할을 하는 함수이다.malloc을 통해 메모리할당하여 각 자리수를 넣으면 될 듯.음수도 처리하는게 관건이다. 구현순서 부호 판단 (0과 대소비교) (ft_signcheck) 자릿수 체크 (ft_digitcheck) malloc 양수: digit+1 (널값) 음수 : digit+2 (마이너스, 널값) 배열에 저장 포인터 역참조 활용. 음수일땐 맨앞에 ‘-’ 추가 ft_strmapi 문자열 s를 돌면서 f함수를 적용하여 리턴char *ft_strmapi(char const *s, char (*f)(unsigned int, char)) 매개변수 s: 순환할 문자열 f: 적용할 함수 구현방법 인수 널체크 메모리 할당→널체크 값 저장 함수포인터이므로 (res + i) = f(i, *(s + i)) 다음과 같이 저장 ft_striterivoid ft_striteri(char *s, void (*f)(unsigned int, char*)) 문자열 s를 돌면서 f함수를 적용하는 함수 (strmapi와의 차이: 리턴여부) 매개변수 s: 반복할 문자열 f: 적용할 함수 ft_putchar_fdwrite (파일 디스크립터, 출력할 버퍼의 포인터, 출력할 개수) 파일 디스크립터에 버퍼를 정해준 개수만큼 기록 매개변수 c: 출력할 문자 파일 디스크립터 ft_putstr_fd 파일 디스크립터에 따라서 문자열을 출력 매개변수 s: 출력할 문자열 fd: 파일 디스크립터 ft_putendl_fd 끝에 ‘\\n’이 추가된 문자열을 fd파일 디스크립터 형식으로 출력putstr, putchar 활용해서 구현ft_putnbr_fd 파일디스크립터로 주어진 정수 출력 첫번째 코드→금지함수(malloc) 사용int → char * → write 구현방법 itoa() putstr_fd() void\tft_putnbr_fd(int n, int fd) { ft_putstr_fd(ft_itoa(n), fd); } 두번째 코드 구현방법 파일디스크립터 체크 INT_MIN → 바로 출력 음수면→양수로 10단위로 재귀함수를 통해 제일 높은 자리수부터 출력 Ref.2차원 배열에서의 널값" }, { "title": "조건문 안에서 변수 할당하기", "url": "/posts/assign-statement/", "categories": "TIL", "tags": "c", "date": "2022-04-22 11:48:45 +0900", "snippet": "사용예시#include &lt;stdio.h&gt;int main() { int a; if ((a = 1)) printf(\"a의 값은 %d입니다\", a); return 0;}동작원리if문은 조건문 안의 값이 0이 아닐 때 작동한다.위의 경우는 a에 1이라는 값을 먼저 할당한 후 조건문 안의 값이 1이 되어서 식이 동작하게 된다.Ref.https://dojang.io/mod/page/view.php?id=130" }, { "title": "Libft ③ Libc functions", "url": "/posts/libft3/", "categories": "42Seoul, Libft", "tags": "42seoul, c", "date": "2022-04-20 00:00:00 +0900", "snippet": "Functionsisalpha, isdigit, isascii, isprint 각 인수가 alpha, digit, ascii, printable인지를 체크하는 함수ASCII코드 번호로 return문 안에서 체크isalnum 인수가 alpha 또는 digit인지를 체크하는 함수isalpha, isdigit 활용strlen 문자열의 길이를 재는 함수맨 끝 null문자를 제외한 길이memset 특정 문자열 바이트를 특정 값으로 채우는 함수void *ft_memset(void *b, int c, size_t len) b에서 1바이트씩 옆으로 밀면서 값을 저장해야함. but, 현재 b는 void 포인터이기 때문에 다른 포인터로 변환해야함 The memset() function writes len bytes of value c (converted to an unsigned char) to the string b. unsigned char 사용하는 이유 1바이트씩 이동하기 위해, 음수로 인한 에러 방지 void 포인터memcpy 메모리의 일부분을 복사하는 함수 매개변수 dest : 채우고자 하는 메모리의 시작 주소 src : 복사하려는 메모리의 시작 주소 n : 채우고자 하는 바이트의 수 리턴값 dest 반환 구현방법 둘다 널이면 널 반환 memset과 같은 방식으로 채워넣기 if (dst != src) : dst와 src가 같으면 동작 수행 안되고 바로 리턴됨memmove 메모리를 이동하는 함수 memcpy와 비교 (restrict 포인터와 관련?) 공통점: 둘다 메모리를 복사함 차이점: memcpy-버퍼를 안거치고 바로 복사, memmove-버퍼를 통해 복사 (libft 과제에서는 예외적으로 버퍼개념 대신 위치에 따라 조건을 달리 주는 식으로 구현함.)→ src 구간에 dst가 있는 경우에 memcpy는 덮어쓴채로 복사되는 문제가 발생하지만 memmove는 그런 문제로부터 자유로움. 동작과정 src → usrc, dst → udst 케이스를 dst의 주소가 src의 주소 앞에, 뒤에 있을 때로 나눔&amp; 복사 순서를 앞먼저 or 뒤먼저로 다르게 함.(뒤에 있는 경우 len의 길이에 따라 src의 뒷부분이 잘릴 수 있기 때문에) memchr 메모리에서 특정 값을 찾는 함수 동작과정 ptr에 unsigned char 로 변환한 s를 할당함. while문을 돌면서 비교함. 같은값이 발생시 ptr의 주소값을 리턴. 없을시 0리턴. memcmp 두 메모리를 n바이트만큼 비교하는 함수별도의 unsigned char형 포인터를 만들어서 비교.strlcpy, strlcat 공통 restrict 포인터란? 각 포인터가 서로 다른 메모리공간을 가르키고 있다는 전제하에 컴파일러가 최적화할 수 있도록 함. 앞부분에 널가드 넣지 않은 이유(memcpy와의 차이점) C89에서는 유효한 값이 들어온다는 전제가 깔려있기 때문임.(원함수와 같은 동작 위해) dstsize : 맨 끝 ‘\\0’ 포함된 길이strlcpy NULL을 보장하여 문자열을 길이만큼 복사 동작과정 dst에 src를 복사 길이 리턴 strlcat NULL을 보장하여 문자열을 길이만큼 붙임 매개변수 char *dst : 앞 문자열 const char *src : 뒤에 붙일 문자열 size_t dstsize : dst에 src를 덧붙인 총길이(‘\\0’포함) return 값 dstsize ≤ dst길이 : src길이 + dstsize 그외 : dst길이 + src길이 toupper &amp; tolower 각각 대문자, 소문자로 변환아스키코드 값으로 각각 32씩 빼고 더해줌.strchr 문자열의 앞에서부터 특정 문자가 처음 나오는 위치 찾는 함수while (*s != (char)c) 형변환 이유: c+256이 들어왔을 때 c로 인식해야 하므로 int를 char로 변환해줌. 구현방법 c와 다를때 while문을 돌리다가 널 만나면 리턴. 널 안만나고 while문 끝나면 해당 위치 리턴 strrchr 문자열의 뒤에서부터 특정 문자가 처음 나오는 위치 찾는 함수strncmp 두 문자열의 일부 문자열을 비교하는 함수 unsinged char이 쓰이는 이유 The comparison is done using unsigned characters, so that ‘\\200’ is greater than ‘\\0’. 위 예시에서 \\200은 8진수로 10진수로 변환하면 128이 됨. 따라서 char 자료형이라면 범위인 127을 초과하지만 unsigned char이기 때문에 초과하지 않게 됨. const char을 사용한 이유 s1, s2값을 바꾸지 못하게 하기 위함.memchr 메모리 블록의 일부 범위에서 특정 문자를 찾는 함수 구현방법 void형으로 들어왔기 때문에 unsigned char형으로 형변환 해당 범위에서 while문 돌다가 같은 위치 찾으면 해당 주소값 반환 memcmp 두 개의 메모리 블럭을 비교하는 함수unsigned char * 타입의 다른 변수에 저장해서 비교.(void *형이기 때문에 명시적 형변환을 거쳐서 사용해야함)strnstr 특정 문자열에서 len 이하의 범위만큼 문자열을 찾는 함수 return value needle이 빈 경우 → haystack haystack에 needle이 없는 경우 → NULL 그 외 → needle의 첫번째 발견 지점 구현방법 haystack, needle 둘다 널가드 안넣음→원함수와 같게 seg.fault 일으킴 len과 nd_len(needle)을 대소비교하며 첫값 비교. (nd_len &lt;= len-— : 남은 길이가 needle보다 짧다면?→비교할 필요 없음) 첫 값이 같다? → memcmp 진행→리턴 or 반복 atoi 문자열 형태로 들어온 인수를 int형으로 반환하는 함수 return value 부호 개수 &gt; 1 or 문자가 맨 처음→ 0 숫자+공백 or 공백+숫자 or 숫자+문자 → 앞부분 숫자만 구현방법 공백체크(스킵) 부호체크(1자만) → 피신때와의 차이 숫자체크(10씩 자릿수 올려가며)→digit이 아닌값을 만날때까지 NULL이 입력됐을 때의 경우→ 아무 처리하지 않기.(seg fault 출력) LONG_MIN (==2147483647) 선언 헤더 : limits.hcalloc size크기의 변수를 count개 저장할 수 있는 메모리 공간 할당 &amp; 0으로 초기화malloc → 선언헤더 : stdlib.h malloc과의 차이점? 1.공간의 값을 0으로 바꾸는지 2.count개를 함수 안에서 한번에 할당 가능한지 malloc(0)에 대해 NULL과의 차이? malloc(0)일때의 동작: gcc에서는 할당을 해줌. 구현체마다 동작이 다름. count * size &gt; SIZE_MAX 조건을 준 이유 size_t 자료형의 범위를 넘어가는것을 방지하기 위해. malloc(SIZE_MAX)→ NULL 리턴될 것. &amp; 원함수와의 동작을 맞춰줌 SIZE_MAX 선언 헤더 : limits.h 사용예시ptr1 = (int*) malloc(sizeof(int) * 5);ptr2 = (int*) calloc(5, sizeof(int));strdup 문자열을 새롭게 할당한 메모리 공간에 복사함.malloc 선언헤더 : stdlib.h 구현방법 result 에 메모리 할당 후 널체크 (If insufficient memory is available, NULL is returned and errno is set to ENOMEM.) strlcpy 를 통해 문자열 복사 후 널보장 복사된 문자열을 리턴. count + 1 인 이유? strlen은 NULL을 제외한 길이임, strlcpy는 dstsize-1만큼 복사하고 널을 추가하는 함수.Ref59.3 void 포인터로 포인터 연산하기memmove와 memcpy의 차이점restrict 포인터널가드 관련 논의malloc(0)과 NULL의 차이점calloc 참고문서limits.h (LONG_MIN, SIZE_MAX 선언)" }, { "title": "size_t 자료형이란?", "url": "/posts/about-sizet/", "categories": "TIL", "tags": "c", "date": "2022-04-16 11:10:07 +0900", "snippet": "사용하는 이유컴파일하는 시스템이 32bit인지, 64bit인지에 상관없이 같은 값을 표현하기 위해서 사용헤더stdlib.h에 선언되어 있음출력printf(\"%zu\",a)와 같이 사용해야 함" }, { "title": "mac에서 vscode 실행 안됨 (code 명령어)", "url": "/posts/mac-vscode-command-error/", "categories": "Project", "tags": "issue, mac, vscode", "date": "2022-03-25 16:32:21 +0900", "snippet": " macOS에서 code . 명령어를 입력했을 때 not found가 출력되는 문제에 관한 해결방법을 담고있음.Ubuntu에서의 해결방법은 다음을 참고.① .zshrc 파일 수정홈 디렉터리에서 .zshrc파일을 수정하여 하단에 다음과 같은 라인을 추가한다.code () { VSCODE_CWD=\"$PWD\" open -n -b \"com.microsoft.VSCode\" --args $* ;}② 수정된 파일 적용다음 두가지 방법 중 한가지로 수정된 내용을 적용한다.option 1shell 재시작option 2$ source ~/.zshrc 입력" }, { "title": "Libft ② 기초 작업", "url": "/posts/libft2/", "categories": "42Seoul, Libft", "tags": "42seoul, c", "date": "2022-03-25 00:00:00 +0900", "snippet": "Create filesmandatory functionstouch ft_isalpha.c ft_isdigit.c ft_isalnum.c ft_isascii.c ft_isprint.c ft_strlen.c ft_memset.c ft_bzero.c ft_memcpy.c ft_memmove.c ft_strlcpy.c ft_strlcat.c ft_toupper.c ft_tolower.c ft_strchr.c ft_strrchr.c ft_strncmp.c ft_memchr.c ft_memcmp.c ft_strnstr.c ft_atoi.c ft_calloc.c ft_strdup.cadditional &amp; bonus functionstouch ft_substr.c ft_strjoin.c ft_strtrim.c ft_split.c ft_itoa.c ft_strmapi.c ft_striteri.c ft_putchar_fd.c ft_putstr_fd.c ft_putendl_fd.c ft_putnbr_fd.c ft_lstnew.c ft_lstadd_front.c ft_lstsize.c ft_lstlast.c ft_lstadd_back.c ft_lstdelone.c ft_lstclear.c ft_lstiter.c ft_lstmap.cetctouch Makefile libft.h42 header &amp; norminette42header 개인pc 설치방법norminette 개인pc 설치방법" }, { "title": "전처리기 지시어 (include, define, ...)", "url": "/posts/preprocessor-directive/", "categories": "TIL", "tags": "c", "date": "2022-03-22 01:20:41 +0900", "snippet": "전처리기 지시어 (Preprocessor Directive)는 프로그램을 실행시킬 때가 아닌, 컴파일할 때 동작함#include헤더파일 삽입 지시자 컴파일러에서 기본 제공된 파일을 포함할 때#include &lt;filename&gt; 직접 만든 파일을 포함할 때#include \"filename\" #define기호상수를 정의하는 지시자보통 변수와 구분하기 위해 대문자로 작성함예시)#define NAME \"thk\"#define PI 3.14Ref.https://dev-alice.tistory.com/5" }, { "title": "Vim 단축키 (Vim Cheat Sheet)", "url": "/posts/vim-shortcut/", "categories": "Tips", "tags": "단축키, vim", "date": "2022-03-17 00:00:00 +0900", "snippet": "Main ShortcutsGlobal:h[elp] keyword # open help for keyword:o file # open file:sav[eas] file # save file as:clo[se] # close current pane:ter[minal]\t\t# open terminalCursor movementh # move cursor leftj # move cursor downk # move cursor upl # move cursor rightH # move to top of screenM # move to middle of screenL # move to bottom of screenw # jump forwards to the start of a wordW # jump forwards to the start of a word (words can contain punctuation)e # jump forwards to the end of a wordE # jump forwards to the end of a word (words can contain punctuation)b # jump backwards to the start of a wordB # jump backwards to the start of a word (words can contain punctuation)0 # jump to the start of the line^ # jump to the first non-blank character of the line$ # jump to the end of the lineg_ # jump to the last non-blank character of the linegg # go to the first line of the documentG # go to the last line of the document5G # go to line 5fx # jump to next occurrence of character xtx # jump to before next occurrence of character x} # jump to next paragraph (or function/block, when editing code){ # jump to previous paragraph (or function/block, when editing code)zz # center cursor on screenCtrl + b # move back one full screenCtrl + f # move forward one full screenCtrl + d # move forward 1/2 a screenCtrl + u # move back 1/2 a screenInsert mode - inserting/appending texti # insert before the cursorI # insert at the beginning of the linea # insert (append) after the cursorA # insert (append) at the end of the lineo # append (open) a new line below the current lineO # append (open) a new line above the current lineea # insert (append) at the end of the wordEsc # exit insert modeEditingr # replace a single characterJ # join line below to the current onecc # change (replace) entire linecw # change (replace) to the start of the next wordce # change (replace) to the end of the next wordcb # change (replace) to the start of the previous wordc0 # change (replace) to the start of the linec$ # change (replace) to the end of the lines # delete character and substitute textS # delete line and substitute text (same as cc)xp # transpose two letters (delete and paste). # repeat last commandu # undoCtrl + r # redoMarking text (visual mode)v # start visual mode, mark lines, then do a command (like y-yank)V # start linewise visual modeo # move to other end of marked areaO # move to other corner of blockaw # mark a wordab # a block with ()aB # a block with {}ib # inner block with ()iB # inner block with {}Esc # exit visual modeCtrl + v # start visual block modeVisual commands&gt; # shift text right&lt; # shift text lefty # yank (copy) marked textd # delete marked text~ # switch caseCut and pasteyy # yank (copy) a line2yy # yank (copy) 2 linesyw # yank (copy) the characters of the word from the cursor position to the start of the next wordy$ # yank (copy) to end of linep # put (paste) the clipboard after cursorP # put (paste) before cursordd # delete (cut) a line2dd # delete (cut) 2 linesdw # delete (cut) the characters of the word from the cursor position to the start of the next wordD # delete (cut) to the end of the lined$ # delete (cut) to the end of the lined^ # delete (cut) to the first non-blank character of the lined0 # delete (cut) to the begining of the linex # delete (cut) characterSearch and replace/pattern # search for pattern?pattern # search backward for pattern\\vpattern # 'very magic' pattern: non-alphanumeric characters are interpreted as special regex symbols (no escaping needed)n # repeat search in same directionN # repeat search in opposite direction:%s/old/new/g # replace all old with new throughout file:%s/old/new/gc # replace all old with new throughout file with confirmations:noh # remove highlighting of search matchesSearch in multiple files:vimgrep /pattern/ {file} # search for pattern in multiple files:cn # jump to the next match:cp # jump to the previous match:copen # open a window containing the list of matchesExiting:w # write (save) the file, but don't exit:w !sudo tee % # write out the current file using sudo:wq or :x or ZZ # write (save) and quit:q # quit (fails if there are unsaved changes):q! or ZQ # quit and throw away unsaved changesWorking with multiple files:e file # edit a file in a new buffer:bnext or :bn # go to the next buffer:bprev or :bp # go to the previous buffer:bd # delete a buffer (close a file):ls # list all open buffers:sp file # open a file in a new buffer and split window:vsp file # open a file in a new buffer and vertically split windowCtrl + ws # split windowCtrl + ww # switch windowsCtrl + wq # quit a windowCtrl + wv # split window verticallyCtrl + wh # move cursor to the left window (vertical split)Ctrl + wl # move cursor to the right window (vertical split)Ctrl + wj # move cursor to the window below (horizontal split)Ctrl + wk # move cursor to the window above (horizontal split)Tabs:tabnew or :tabnew file # open a file in a new tabCtrl + wT # move the current split window into its own tabgt or :tabnext or :tabn # move to the next tabgT or :tabprev or :tabp # move to the previous tab&lt;number&gt;gt # move to tab &lt;number&gt;:tabmove &lt;number&gt; # move current tab to the &lt;number&gt;th position (indexed from 0):tabclose or :tabc # close the current tab and all its windows:tabonly or :tabo # close all tabs except for the current one:tabdo command # run the command on all tabs (e.g. :tabdo q - closes all opened tabs)vim 설정아래 내용을 vim 내 명령 모드에서 입력하면 일시 적용, ~/.vimrc 에 작성하면 영구 적용됨set number # 줄 번호 적용 (또는 :se nu)syntax on # 문법 컬러 적용set cin # 자동 들여쓰기set ts=&lt;number&gt; # 탭 너비를 몇 개의 스페이스로 화면에 보여줄 지 설정set sts=&lt;number&gt; # 탭을 몇 개의 스페이스로 입력할 지 설정set shiftwidth=&lt;number&gt; # 자동 들여쓰기에서 스페이스 개수 설정Ref.Vim Cheat Sheet1Vim Cheat Sheet2vi 단축키" }, { "title": "Notion 단축키 모음", "url": "/posts/notion-shortcut/", "categories": "Tips", "tags": "단축키, notion", "date": "2022-03-17 00:00:00 +0900", "snippet": "주요 단축키 cmd/ctrl + n 을 눌러 새 페이지를 만듭니다 (데스크톱 앱만 해당). cmd/ctrl + shift + n 을 누르거나 cmd/ctrl + click 을 사용하여 새로운 Notion 창을 엽니 다. cmd/ctrl + p 를 눌러 검색을 열거 나 최근에 본 페이지로 이동하십시오. cmd/ctrl + [ 를 누르면 페이지로 뒤로 돌아갑니다. cmd/ctrl + ] 를 누르면 페이지가 앞으로 이동합니다. cmd/ctrl + shift + l 눌러 다크 모드로 전환하십시오 (1이 아닌 L입니다).Tip: 이모지 선택기 사용 방법: Mac: ctrl + cmd + space Windows 10: windows key + . or windows key + ;마크다운 스타일입력하는 동안: 텍스트의 양쪽에 ** 입력해 굵게 표시하십시오. bold. 텍스트의 양쪽에 * 입력해 이탤릭체를 표시하십시오. italicize. 텍스트의 양쪽에 ` 입력해 인라인 코드를 만듭니다. inline code. 텍스트의 양쪽에 ~ 입력해 취소선을 만듭니다. strikethrough.바로 가기: 글 머리 기호 목록을 만들려면 *, -, or + 다음에 space 를 입력하십시오. 할 일 확인란을 만들려면 [] 를 입력하십시오. (사이에는 space 공백이 없습니다.) 번호 매기기 목록을 만들려면 1. 과 space 를 차례로 입력하십시오. H1 큰 제목을 만들려면 # 다음에 space 를 입력하십시오. H2 중간 제목을 만들려면 ## 다음에 space 를 입력하십시오. H3 작은 제목을 만들려면 ### 다음에 space 를 입력하십시오. 토글리스트를 생성하기 위해 &gt; 다음에 space 를 입력하십시오. 인용 블록을 만들려면 ” 다음에 space 를 입력하십시오.컨텐츠 제작 및 스타일 지정 enter 를 눌러 한 줄의 텍스트를 삽입하십시오. shift + enter 를 눌러 텍스트 블록 내에 줄 바꿈을 만듭니다. cmd/ctrl + shift + m 을 눌러 주석을 만듭니다. 구분선을 만들려면 — 를 입력하십시오. (Three dashes in a row.) 텍스트를 선택한 상태에서 cmd/ctrl + b 를 눌러 굵은 글씨로 표시. bold text. 텍스트를 선택한 상태에서 cmd/ctrl + i 를 눌러 텍스트를 이탤릭체로 표시. italicize text. 텍스트를 선택한 상태에서 cmd/ctrl + shift + s 를 눌러 텍스트를 취소선으로 표시 strikethrough. 텍스트를 선택한 상태에서 cmd/ctrl + k 를 눌러 링크를 추가하십시오. cmd/ctrl + v 를 사용하여 선택된 텍스트 위에 URL을 붙여 링크로 바꿀 수도 있습니다 텍스트를 선택한 상태에서 cmd/ctrl + e 를 눌러 인라인 코드를 표시. 들여 쓰기하려면 tab 을 누르십시오. 참고: 들여 쓰기를 할 때마다 그 블록을 그 블록 위에 중첩시킵니다. 부모를 선택하면 그 아래의 모든 항목도 선택됩니다. 예를 들면 다음과 같습니다: Block 1 ← 부모 블록 Block 2 ← 블록 1 안에 중첩된 블록 들여 쓰기를 해지하려면 shift + tab 을 누릅니다. 블록의 시작 또는 끝에 /turn 을 입력하여 다른 유형의 블록으로 바꿉니다. 선택 목록이 나타납니다. 예를 들어, 텍스트 줄을 제목으로 한 다음해야 할 일로 바꾸는 방법은 다음과 같습니다: 텍스트 블록의 시작 또는 끝에 /color 를 입력하여 색상을 변경하거나 색상을 강조 표시하십시오. (색상이나 강조 표시를 제거하려면 /default 를 입력하십시오.) 예: /blue, /blue background이러한 모든 컨텐츠 생성 바로 가기에서, cmd + option 은 Mac의 조합이고, ctrl + shift 는 Windows 및 Linux의 조합입니다: cmd/ctrl + option/shift + 0 을 눌러 텍스트를 만듭니다. cmd/ctrl + option/shift + 1 을 눌러 H1 표제를 작성하십시오. cmd/ctrl + option/shift + 2 를 눌러 H2 제목을 만듭니다. cmd/ctrl + option/shift + 3 을 눌러 H3 제목을 만듭니다. cmd/ctrl + option/shift + 4 를 눌러 해야할 일 체크 박스를 만듭니다. cmd/ctrl + option/shift + 5 를 눌러 글 머리 기호 목록을 만듭니다. cmd/ctrl + option/shift + 6 을 눌러 번호 매기기 목록을 만드십시오. cmd/ctrl + option/shift + 7 을 눌러 토글 목록을 만듭니다. cmd/ctrl + option/shift + 8 을 눌러 코드 블록을 생성하십시오 - 아래처럼:&lt;b&gt;Any kind of code can go here and be copied to your clipboard!&lt;/b&gt; cmd/ctrl + option/shift + 9 를 눌러 새 페이지를 만들거나 한 줄에 있는 것을 페이지로 바꿉니다. cmd/ctrl + + 를 눌러 확대합니다. cmd/ctrl + - 를 누르면 축소됩니다. 끌어다 놓을 때 option/alt 를 누른 상태로 Notion 페이지의 내용을 복제하십시오:블록 편집 및 이동Notion의 모든 항목은 한 줄의 선 (또는 단락)에서 이미지 또는 삽입에 이르는 블록입니다. 이 단축키를 사용하면 전체 블록을 선택한 후 편집 할 수 있습니다. esc 를 눌러 현재 있는 블록을 선택하거나 선택된 블록을 지우십시오. cmd/ctrl + a 를 한 번 눌러 커서가 있는 블록을 선택하십시오. space 를 누르면 선택된 이미지가 전체 화면으로 열립니다. 또는 전체 화면을 종료합니다. arrow keys 화살표 키를 눌러서 다른 블록을 선택하십시오. shift + up/down arrow keys 를 길게 눌러 선택을 위 또는 아래로 확장합니다. Mac에서는 cmd + shift + click, Windows/Linux에서는 option + shift + click 을 사용하여 전체 블록을 선택하거나 선택 해제하십시오. shift + click 을 사용하여 다른 블록과 그 사이의 모든 블록을 선택하십시오. 선택된 블록을 삭제하려면 backspace or delete 를 누르십시오. cmd/ctrl + d 를 눌러 선택한 블록을 복제하십시오. enter 를 눌러 선택한 블록 안의 텍스트를 편집하거나 페이지 안의 페이지를 엽니다. cmd/ctrl + / 를 눌러 하나 이상의 선택된 블록을 편집하거나 변경하십시오. 이 단축키를 사용하여 블록 유형, 색상을 변경하거나 블록을 편집, 복제 또는 이동하십시오. 메뉴 상 단에 팝업 상자가 나타납니다. 원하는 액션, 블록 또는 색상을 입력하십시오: 보드 보기에서 여러 카드를 선택한 다음 cmd/ctrl + / 를 사용하여 한 번에 편집하십시오. 예 : 한 번에 여러 작업의 상태를 변경하는 방법은 다음과 같습니다. cmd/ctrl + shift + arrow keys 를 누르고 있으면 선택된 블록이 움직입니다. cmd/ctrl + option/alt + t 를 눌러 토글 목록에서 모든 토글을 확장하거나 닫습니다. cmd/ctrl + shift + h 를 눌러 마지막으로 사용한 텍스트 또는 강조 색상을 적용하십시오. cmd/ctrl + enter 를 눌러 현재 블록을 수정하십시오. 수정 방법: 페이지를 여십시오 할 일 체크 박스를 체크 또는 체크 해제 토글 목록 항목을 열거나 닫습니다 퍼가기 또는 이미지를 전체 화면으로 만들기 @ Commands Mention a person - Type @ 와 다른 작업 공간 구성원의 이름을 입력하여 어떤 것에 대한 주의를 환기시킨다. 그들은 통지받을 것이다. 의견과 토론에 유용합니다. Mention a page - 작업 공간에 Type @ 와 다른 페이지의 이름을 입력하여 링크를 만듭니다. 페이지 이름을 변경하면 이 링크도 자동으로 변경됩니다. Mention a date - Type @ 및 모든 형식의 날짜 (또는 “어제”, “오늘”또는 “내일”또는 “다음 수요일”)를 입력하십시오. 마감일을 알려주는 데 도움이 됩니다. Add a reminder - Type @remind 를 입력 한 후 날짜를 입력하십시오 (예 : “어제”, “오늘”, “내일” 등). 표시되는 링크를 클릭하면 알림을 받을 날짜와 정확한 시간을 조정할 수 있습니다. 그때 알림을 받게 됩니다. More on reminders here →단순히 @-command를 입력하려면 esc 를 눌러 @ -command 메뉴를 닫습니다./ 슬래시 명령/ 를 누르면 삽입 할 수있는 컨텐츠 블록의 전체 메뉴가 나타납니다. / 를 누른 다음 다음 원하는 것을 입력하면 된다. 선택 사항은 다음과 같습니다:Basic /text or /plain 은 새로운 텍스트 블록을 만듭니다. /page 는 새로운 페이지를 생성합니다 (enter 를 누르면 자동으로 열립니다.) /bullet 은 글 머리 기호 목록을 만듭니다. /num 은 번호가 매겨진 목록을 만듭니다. /todo 는 체크 박스가 있는 할일 목록을 만듭니다. /toggle 은 토글 목록을 만듭니다. /div 는 밝은 회색 구분선을 만듭니다. /quote 는 더 큰 텍스트의 인용 블록을 만듭니다. /h1 or /# 는 큰 제목을 만듭니다. /h2 or /## 는 중간 크기의 제목을 만듭니다. /h3 or /### 은 작은 제목을 만듭니다. /link 는 작업 공간에 있는 다른 페이지에 대한 링크를 만듭니다. esc 는 / 메뉴를 지웁니다. 글쓸 때 / 를 사용하려는 경우 편리합니다.Database /table-inline 은 현재 페이지 내에 데이터베이스 테이블을 만듭니다. /board-inline 은 현재 페이지 내에 Kanban 보드를 만듭니다. /calendar-inline 은 현재 페이지 안에 달력을 만듭니다. /list-inline 은 현재 페이지 내에 목록 스타일 데이터베이스를 만듭니다. /gallery-inline 은 현재 페이지 안에 갤러리를 만듭니다. 위의 어떤 것도 -inline 대신 -full 으로 생성하여 자체 페이지에서 해당 유형의 데이터베이스 보기를 자동으로 열 수 있습니다. 예: /table-full, /board-full /linked 는 링크 된 데이터베이스를 생성합니다 — 기존 데이터베이스의 사본으로 인라인 페이지에 삽입하고 원하는대로 필터링하거나 볼 수 있습니다. 같은 페이지의 같은 데이터베이스에서 여러 발췌를 만드는 데 도움이됩니다.Media /image 는 이미지를 업로드 또는 내장하거나 Unsplash 에서 이미지를 추가하는 옵션을 불러옵니다. /pdf 를 사용하면 URL을 임의의 PDF에 붙여 넣어 페이지에 인라인으로 표시 할 수 있습니다. /book 을 사용하면 웹 사이트에 URL을 붙여 웹 북마크를 만들 수 있습니다. 이처럼:단축키 배우기 /video 를 사용하면 비디오 파일을 업로드하거나 YouTube, Vimeo 등의 비디오를 포함할 수 있습니다. /audio 를 사용하면 오디오 파일을 업로드하거나 SoundCloud, Spotify 등에서 녹음을 포함할 수 있습니다. /code 는 코드 조각을 작성하고 복사할 수있는 코드 블록을 만듭니다. /file 을 사용하면 컴퓨터에서 파일을 업로드하거나 포함을 만들 수 있습니다. /embed 는 Notion과 함께 작동하는 500+개 이상의 임베드 중 하나를 추가 할 수 있습니다.고급 /comment 를 사용하면 모든 블록에 주석을 작성할 수 있습니다. /duplicate 는 현재 블록의 정확한 사본을 만듭니다. /moveto 를 사용하면 해당 블록을 다른 페이지로 이동할 수 있습니다. /delete 는 현재 블록을 삭제합니다. /toc 는 목차 블록을 만듭니다. /button or /template 은 정의한 블록의 조합을 복제하는 템플릿 버튼을 제공합니다. Here’s a guide on template buttons → /bread 는 현재 페이지가 작업 공간에서 어디에 있는지 보여주는 이동 경로 메뉴를 삽입합니다. /math or /latex 를 사용하면 TeX 를 사용하여 수학 방정식과 기호를 쓸 수 있습니다.Ref.노션 - 단축키 배우기" }, { "title": "macOS 단축키 모음", "url": "/posts/mac-shortcut/", "categories": "Tips", "tags": "단축키, mac", "date": "2022-03-17 00:00:00 +0900", "snippet": "주요 키보드 기호command(또는 cmd) ⌘shift ⇧option(또는 alt) ⌥control(또는 ctrl) ⌃오려두기, 복사하기, 붙여 넣기 및 기타 일반적으로 사용하는 단축키 ⌘-X: 선택한 항목을 잘라내어 클립보드에 복사합니다. ⌘-C: 선택한 항목을 클립보드에 복사합니다. 이 키는 Finder의 파일에도 작동합니다. ⌘-V: 클립보드의 콘텐츠를 현재 문서 또는 앱에 붙여 넣습니다. 이 키는 Finder의 파일에도 작동합니다. ⌘-Z: 이전 명령을 실행 취소합니다. 그런 다음 ⇧-⌘-Z 키를 눌러 실행 복귀하면 실행 취소 명령을 되돌릴 수 있습니다. 일부 앱에서는 여러 명령을 실행 취소하고 실행 복귀할 수 있습니다. ⌘-A: 모든 항목을 선택합니다. ⌘-F: 문서에서 항목을 찾거나 찾기 윈도우를 엽니다. ⌘-G: 다시 찾기: 이전에 찾은 항목이 다음으로 나타나는 위치를 찾습니다. 이전에 나타난 위치를 찾으려면 ⇧-⌘-G 키를 누릅니다. ⌘-H: 전면에 있는 앱의 윈도우를 가립니다. 전면에 있는 앱을 제외한 나머지 앱을 모두 가리려면 ⌥-⌘-H 키를 누릅니다. ⌘-M: 전면에 있는 윈도우를 최소화하여 Dock에 추가합니다. 전면에 있는 앱의 윈도우를 모두 최소화하려면 ⌘-⌥-M 키를 누릅니다. ⌘-O: 선택한 항목을 열거나 열려는 파일을 선택할 수 있는 대화상자를 엽니다. ⌘-P: 현재 문서를 프린트합니다. ⌘-S 현재 문서를 저장합니다. ⌘-T: 새 탭을 엽니다. ⌘-W: 전면에 있는 윈도우를 닫습니다. 앱의 윈도우를 모두 닫으려면 ⌥-⌘-W 키를 누릅니다. ⌥-⌘-esc: 앱을 강제 종료합니다. ⌘-스페이스 바: Spotlight 검색 필드를 표시하거나 가립니다. Finder 윈도우에서 Spotlight 검색을 수행하려면 ⌘–⌥–스페이스 바를 누릅니다. (다른 언어로 입력하기 위해 여러 입력 소스를 사용하는 경우 이 단축키를 누르면 Spotlight가 표시되는 대신 입력 소스가 변경됩니다. 충돌하는 키보드 단축키를 변경하는 방법에 대해 알아봅니다.) ⌃-⌘-스페이스 바: 이모티콘 및 기타 기호를 선택할 수 있는 문자 뷰어를 표시합니다. ⌃-⌘-F 또는 fn-F: 앱에서 지원하는 경우 전체 화면으로 앱을 사용합니다. 스페이스 바: 훑어보기를 사용하여 선택한 항목을 미리 봅니다. ⌘-tab: 열려 있는 앱 중에서 다음으로 최근에 사용한 앱으로 전환합니다. ⇧-⌘-5: macOS Mojave 및 이후 버전에서 스크린샷을 찍거나 화면을 기록합니다. ⇧-⌘-3 또는 ⇧-⌘-4 키를 사용해도 스크린샷을 찍을 수 있습니다. 스크린샷에 대해 자세히 알아봅니다. ⇧-⌘-N: Finder에 새 폴더를 생성합니다. ⌘-쉼표(,): 전면에 있는 앱의 환경설정을 엽니다.잠자기, 로그아웃 및 시스템 종료 단축키다음 단축키 중 일부는 다른 단축키보다 약간 더 오래 길게 눌러야 할 수 있습니다. 이렇게 하면 단축키가 의도치 않게 사용되는 것을 방지할 수 있습니다. 전원 버튼: Mac을 켜거나 Mac을 잠자기 상태에서 깨우려면 누릅니다. Mac을 잠자기 상태로 전환하려면 1.5초 동안 길게 누릅니다.* 계속 누르고 있으면 Mac이 강제로 꺼집니다. ⌥-⌘-전원 버튼 또는 ⌥-⌘-미디어 추출 : Mac을 잠자기 상태로 전환합니다. ⌃-⇧-전원 버튼 또는 ⌃-⇧-미디어 추출 : 디스플레이를 잠자기 상태로 전환합니다. ⌃-전원 버튼 또는 ⌃-미디어 추출 : 재시동하거나, 잠자기로 전환하거나, 시스템을 종료할 것인지 묻는 대화 상자를 표시합니다. ⌃-⌘-전원 버튼:* 저장되지 않은 열린 문서를 저장할지 묻는 메시지를 표시하지 않고 Mac을 강제로 재시동합니다. ⌃-⌘-미디어 추출 : 모든 앱을 종료한 다음 Mac을 재시동합니다. 열려 있는 문서의 변경 내용을 저장하지 않은 경우 변경 내용을 저장할지 묻는 메시지가 표시됩니다. ⌃-⌥-⌘-전원 버튼 또는 ⌃-⌥-⌘-미디어 추출 : 모든 앱을 종료한 후 Mac 시스템을 종료합니다. 열려 있는 문서의 변경 내용을 저장하지 않은 경우 변경 내용을 저장할지 묻는 메시지가 표시됩니다. ⌃-⌘-Q: 화면을 곧바로 잠급니다. ⇧-⌘-Q: macOS 사용자 계정에서 로그아웃합니다. 확인하는 메시지가 표시됩니다. 확인하지 않고 바로 로그아웃하려면 ⌥-⇧-⌘-Q 키를 누릅니다. Touch ID 센서에는 적용되지 않습니다.Finder 및 시스템 단축키 fn-C: 제어센터를 엽니다. ⌘-D: 선택한 파일을 복제합니다. ⌘-E: 선택한 디스크 또는 볼륨을 추출합니다. ⌘-F: Finder 윈도우에서 Spotlight 검색을 시작합니다. ⌘-I: 선택한 파일의 정보 가져오기 윈도우를 표시합니다. ⌘-R: (1) Finder에서 가상본을 선택한 경우 선택된 가상본의 원본 파일이 나타납니다. (2) 캘린더나 Safari 등 일부 앱에서 페이지를 새로 고치거나 다시 로드합니다. (3) 소프트웨어 업데이트 환경설정에서 소프트웨어 업데이트를 다시 확인합니다. ⇧-⌘-C: 컴퓨터 윈도우를 엽니다. ⇧-⌘-D: 데스크탑 폴더를 엽니다. ⇧-⌘-F: 최근 사용 윈도우를 열고 최근에 보았거나 변경한 모든 파일을 표시합니다. ⇧-⌘-G: 폴더로 이동 윈도우를 엽니다. ⇧-⌘-H: 현재 macOS 사용자 계정의 홈 폴더를 엽니다. ⇧-⌘-I: iCloud Drive를 엽니다. ⇧-⌘-K: 네트워크 윈도우를 엽니다. ⌥-⌘-L: 다운로드 폴더를 엽니다. ⇧-⌘-N: 새 폴더를 생성합니다. ⇧-⌘-O: 문서 폴더를 엽니다. ⇧-⌘-P: Finder 윈도우에서 미리보기 패널을 표시하거나 가립니다. ⇧-⌘-R: AirDrop 윈도우를 엽니다. ⇧-⌘-T: Finder 윈도우에서 탭 막대를 표시하거나 가립니다. ⌃-⇧-⌘-T: 선택한 Finder 항목을 Dock에 추가합니다(OS X Mavericks 및 이후 버전). ⇧-⌘-U: 유틸리티 폴더를 엽니다. ⌥-⌘-D: Dock을 표시하거나 가립니다. ⌃-⌘-T: 선택한 항목을 사이드바에 추가합니다(OS X Mavericks 및 이후 버전). ⌥-⌘-P: Finder 윈도우에서 경로 막대를 가리거나 표시합니다. ⌥-⌘-S: Finder 윈도우에서 사이드바를 가리거나 표시합니다. ⌘-슬래시(/): Finder 윈도우에서 상태 막대를 가리거나 표시합니다. ⌘-J: 보기 옵션을 표시합니다. ⌘-K: 서버에 연결 윈도우를 엽니다. ⌃-⌘-A: 선택한 항목의 가상본을 만듭니다. ⌘-N: 새로운 Finder 윈도우를 엽니다. ⌥-⌘-N: 새로운 스마트 폴더를 생성합니다. ⌘-T: 현재 Finder 윈도우에 단일 탭이 열려 있는 경우 탭 막대를 표시하거나 가립니다. ⌥-⌘-T: 현재 Finder 윈도우에 단일 탭이 열려 있는 경우 도구 막대를 표시하거나 가립니다. ⌥-⌘-V: 클립보드에 있는 파일을 원래 위치에서 현재 위치로 이동합니다. ⌘-Y: 훑어보기를 사용하여 선택한 파일을 미리 봅니다. ⌥-⌘-Y: 선택한 파일의 훑어보기 슬라이드쇼를 표시합니다. ⌘-1: Finder 윈도우의 항목을 아이콘으로 표시합니다. ⌘-2: Finder 윈도우의 항목을 목록으로 표시합니다. ⌘-3: Finder 윈도우의 항목을 열로 표시합니다. ⌘-4: Finder 윈도우의 항목을 갤러리로 표시합니다. ⌘-[: 이전 폴더로 이동합니다. ⌘-]: 다음 폴더로 이동합니다. ⌘-위쪽 화살표: 현재 폴더를 포함하는 폴더를 엽니다. ⌘-⌃-위쪽 화살표: 현재 폴더를 포함하는 폴더를 새로운 윈도우에 엽니다. ⌘-아래쪽 화살표: 선택한 항목을 엽니다. 오른쪽 화살표: 선택한 폴더를 엽니다. 이 기능은 목록 보기에서만 작동합니다. 왼쪽 화살표: 선택한 폴더를 닫습니다. 이 기능은 목록 보기에서만 작동합니다. ⌘-delete: 선택한 항목을 휴지통으로 이동합니다. ⇧-⌘-delete: 휴지통을 비웁니다. ⌥-⇧-⌘-delete: 확인 대화상자를 표시하지 않고 휴지통을 비웁니다. ⌘-밝기 낮추기: Mac이 두 대 이상의 디스플레이에 연결되어 있는 경우 비디오 미러링을 켜거나 끕니다. ⌥-밝기 높이기: 디스플레이 환경설정을 엽니다. 이 기능은 두 개의 밝기 조절 키 중 어느 것을 사용해도 작동합니다. ⌃-밝기 높이기 또는 ⌃-밝기 낮추기: 외장 디스플레이에서 지원하는 경우 디스플레이의 밝기를 변경합니다. ⌥-⇧-밝기 높이기 또는 ⌥-⇧-밝기 낮추기: 디스플레이 밝기를 더 미세한 단계로 조절합니다. 외장 디스플레이에서 지원하는 경우 이 단축키에 ⌃ 키를 추가하여 디스플레이 밝기를 조절할 수 있습니다. ⌥-Mission: Mission Control 환경설정을 엽니다. ⌘-Mission: 데스크탑을 표시합니다. ⌃-아래쪽 화살표: 전면에 있는 앱의 윈도우를 모두 표시합니다. ⌥-음량 높이기 또는 ⌥-음량 낮추기: 사운드 환경설정을 엽니다. 이 기능은 두 개의 음량 조절 키 중 어느 것을 사용해도 작동합니다. ⌥-⇧-음량 높이기 또는 ⌥-⇧-음량 낮추기: 사운드 음량을 더 미세한 단계로 조절합니다. ⌥-키보드 밝기 높이기: 키보드 환경설정을 엽니다. 이 기능은 어느 키보드 밝기 조절 키로도 작동합니다. ⌥-⇧-키보드 밝기 높이기 또는 ⌥-⇧-키보드 밝기 낮추기: 키보드 밝기를 더 미세한 단계로 조절합니다. ⌥ 키를 누른 채 이중 클릭: 별도의 창에서 항목을 연 다음 원래 창을 닫습니다. ⌘ 키를 누른 상태에서 이중 클릭: 별도의 탭이나 창에서 폴더를 엽니다. ⌘ 키를 누른 상태에서 다른 볼륨으로 드래그: 드래그한 항목을 복사하는 대신 다른 볼륨으로 이동합니다. ⌥ 키를 누른 상태에서 드래그: 드래그한 항목을 복사합니다. 항목을 드래그하는 동안 포인터가 변경됩니다. ⌥-⌘ 키를 누른 상태에서 드래그: 드래그한 항목의 가상본을 만듭니다. 항목을 드래그하는 동안 포인터가 변경됩니다. 펼침 삼각형 ⌥-클릭: 선택한 폴더 안에 있는 모든 폴더를 엽니다. 이 기능은 목록 보기에서만 작동합니다. 윈도우 제목 ⌘-클릭: 현재 폴더의 상위 폴더를 표시합니다. ⌘ 또는 ⇧ 키를 사용하여 Finder에서 여러 항목을 선택하는 방법에 대해 알아봅니다. Finder 메뉴 막대에서 ‘이동’ 메뉴를 클릭하면 응용 프로그램, 문서, 다운로드, 유틸리티, iCloud Drive 등 자주 사용하는 여러 폴더를 여는 단축키가 표시됩니다.문서 단축키문서 단축키의 동작은 사용 중인 앱에 따라 다를 수 있습니다. ⌘-B: 선택한 텍스트를 볼드체로 만들거나 볼드체 사용을 켜거나 끕니다. ⌘-I: 선택한 텍스트를 이탤릭체로 만들거나 이탤릭체 사용을 켜거나 끕니다. ⌘-K: 웹 링크를 추가합니다. ⌘-U: 선택한 텍스트에 밑줄을 긋거나 밑줄 사용을 켜거나 끕니다. ⌘-T: 서체 윈도우를 표시하거나 가립니다. ⌘-D: 열기 대화상자 또는 저장 대화상자 내에서 데스크탑 폴더를 선택합니다. ⌃-⌘-D: 선택한 단어의 정의를 표시하거나 가립니다. ⇧-⌘-콜론(:): 맞춤법 및 문법 윈도우를 표시합니다. ⌘-세미콜론(;): 문서에서 맞춤법이 틀린 단어를 찾습니다. ⌥-delete: 삽입 지점의 왼쪽에 있는 단어를 삭제합니다. ⌃-H: 삽입 지점의 왼쪽에 있는 문자를 삭제합니다. 또는 delete 키를 사용합니다. ⌃-D: 삽입 지점의 오른쪽에 있는 문자를 삭제합니다. 또는 fn-delete 키를 사용합니다. fn-delete: 오른쪽 방향 delete 키가 없는 키보드에서 오른쪽 방향 delete 키 기능을 합니다. 또는 ⌃-D 키를 사용합니다. ⌃-K: 삽입 지점과 줄 끝 또는 단락 끝 사이에 있는 텍스트를 삭제합니다. fn-위쪽 화살표: page up: 한 페이지 위로 스크롤합니다. fn-아래쪽 화살표: page down: 한 페이지 아래로 스크롤합니다. fn-왼쪽 화살표: home: 문서의 시작 위치로 스크롤합니다. fn-오른쪽 화살표: end: 문서의 끝으로 스크롤합니다. ⌘-위쪽 화살표: 삽입 지점을 문서의 시작 위치로 이동합니다. ⌘-아래쪽 화살표: 삽입 지점을 문서의 끝으로 이동합니다. ⌘-왼쪽 화살표: 삽입 지점을 현재 줄의 시작 위치로 이동합니다. ⌘-오른쪽 화살표: 삽입 지점을 현재 줄의 끝으로 이동합니다. ⌥-왼쪽 화살표: 삽입 지점을 이전 단어의 시작 위치로 이동합니다. ⌥-오른쪽 화살표: 삽입 지점을 다음 단어의 끝으로 이동합니다. ⇧-⌘-위쪽 화살표: 삽입 지점과 문서의 시작 위치 사이에 있는 텍스트를 선택합니다. ⇧-⌘-아래쪽 화살표: 삽입 지점과 문서의 끝 사이에 있는 텍스트를 선택합니다. ⇧-⌘-왼쪽 화살표: 삽입 지점과 현재 줄의 시작 위치 사이에 있는 텍스트를 선택합니다. ⇧-⌘-오른쪽 화살표: 삽입 지점과 현재 줄의 끝 사이에 있는 텍스트를 선택합니다. ⇧-위쪽 화살표: 텍스트 선택 부분을 윗줄에서 수평으로 동일한 위치에 있는 가장 가까운 문자까지 확장합니다. ⇧-아래쪽 화살표: 텍스트 선택 부분을 아랫줄에서 동일한 수평 위치에 있는 가장 가까운 문자까지 확장합니다. ⇧-왼쪽 화살표: 텍스트 선택 부분을 한 문자씩 왼쪽으로 확장합니다. ⇧-오른쪽 화살표: 텍스트 선택 부분을 한 문자씩 오른쪽으로 확장합니다. ⌥-⇧-위쪽 화살표: 텍스트 선택 부분을 현재 단락의 시작 위치까지 확장한 다음 다시 한 번 누르면 다음 단락의 시작 위치까지 확장합니다. ⌥-⇧-아래쪽 화살표: 텍스트 선택 부분을 현재 단락의 끝까지 확장한 다음 다시 한 번 누르면 다음 단락의 끝까지 확장합니다. ⌥-⇧-왼쪽 화살표: 텍스트 선택 부분을 현재 단어의 시작 위치까지 확장한 다음 다시 한 번 누르면 다음 단어의 시작 위치까지 확장합니다. ⌥-⇧-오른쪽 화살표: 텍스트 선택 부분을 현재 단어의 끝까지 확장한 다음 다시 한 번 누르면 다음 단어의 끝까지 확장합니다. ⌃-A: 줄 또는 단락의 시작 위치로 이동합니다. ⌃-E: 줄 또는 단락의 끝으로 이동합니다. ⌃-F: 한 문자 앞으로 이동합니다. ⌃-B: 한 문자 뒤로 이동합니다. ⌃-L: 커서 또는 선택 영역을 눈에 보이는 영역의 중앙에 위치시킵니다. ⌃-P: 한 줄 위로 이동합니다. ⌃-N: 한 줄 아래로 이동합니다. ⌃-O: 삽입 지점 다음에 새 줄을 삽입합니다. ⌃-T: 삽입 지점 뒤에 있는 문자를 삽입 지점 앞에 있는 문자와 바꿉니다. ⌘-왼쪽 중괄호({): 왼쪽에 맞추어 정렬합니다. ⌘-오른쪽 중괄호(}): 오른쪽에 맞추어 정렬합니다. **⇧-⌘-수직 막대( )**: 가운데에 맞추어 정렬합니다. ⌥-⌘-F: 검색 필드로 이동합니다. ⌥-⌘-T: 앱에서 도구 막대를 표시하거나 가립니다. ⌥-⌘-C: 스타일 복사하기: 선택한 항목의 포맷 설정을 클립보드에 복사합니다. ⌥-⌘-V: 스타일 붙여넣기: 복사한 스타일을 선택한 항목에 적용합니다. ⌥-⇧-⌘-V: 붙여넣고 스타일 일치시킴: 주변 콘텐츠의 스타일을 해당 콘텐츠 내의 붙여 넣은 항목에 적용합니다. ⌥-⌘-I: 속성 윈도우를 표시하거나 가립니다. ⇧-⌘-P: 페이지 설정: 문서 설정을 선택하는 윈도우를 표시합니다. ⇧-⌘-S: 별도 저장 대화상자를 표시하거나 현재 문서를 복제합니다. ⇧-⌘-빼기 기호(-): 선택한 항목의 크기를 줄입니다. ⇧-⌘-더하기 기호(+): 선택한 항목의 크기를 늘립니다. ⌘-등호(=) 키도 같은 기능을 수행합니다. ⇧-⌘-물음표(?): 도움말 메뉴를 엽니다.기타 단축키더 많은 단축키를 보려면 앱의 메뉴에 표시된 단축키 약어를 확인합니다. 앱마다 고유한 단축키가 있을 수 있으며, 한 앱에서 작동하는 단축키가 다른 앱에서는 작동하지 않을 수 있습니다. 손쉬운 사용 단축키 Safari 단축키 Spotlight 단축키 시동 단축키 Apple Music 단축키: 음악 앱의 메뉴 막대에서 도움말 &gt; 키보드 단축키를 선택합니다. 기타 단축키: Apple 메뉴 &gt; 시스템 환경설정을 선택하고 ‘키보드’를 클릭한 후 ‘단축키‘를 클릭합니다.Ref.Mac 키보드 단축키" }, { "title": "42header 개인pc 설치방법", "url": "/posts/42header-install/", "categories": "42Seoul, etc_42", "tags": "42seoul", "date": "2022-03-16 00:00:00 +0900", "snippet": " 42헤더를 클러스터 밖에서 적용할 수 있는 방법을 다룸본 게시글은 linux, macOS를 기준으로 작성하였음.1. 42header plugin 설치클러스터 밖 개인 pc를 사용중이라면 pc에 우선 42헤더 플러그인을 설치해야한다. 아래와 같이 본인의 홈 디렉터리 임의의 디렉터리에서 git clone을 받는다.git clone https://github.com/42Paris/42header.gitclone 받은 디렉터리에서 stdheader.vim(plugin에 위치)을 찾아~/.vim/plugin으로 복사한다. (해당 경로가 없으면 새로 만든다.)2. configuration file 설정아래 두가지 옵션 중 한가지로만 하면 된다.옵션 1. zshrc~/.zshrc 하단에 다음과 같이 추가한다. (intraID 부분만 본인의 ID로 변경)(파일이 없다면 새로 만든다.)export USER=intraIDexport MAIL=$USER@student.42seoul.kr옵션 2. vimrc~/.vimrc 하단에 다음과 같이 추가한다. (intraID 부분만 본인의 ID로 변경)(파일이 없다면 새로 만든다.)let g:user42 = 'intraID'let g:mail42 = 'intraID@student.42seoul.kr'3. 테스트터미널을 재시작한 후 테스트할 파일을 vim으로 열고 F1을 눌러서 42헤더가 제대로 입력되는지 확인한다.Ref.42Paris/42header[42Seoul] 윈도우10 wsl2에서 42 과제 편하게 하기" }, { "title": "WSL2 시작 경로 변경하기", "url": "/posts/wsl2-startingdir/", "categories": "Project", "tags": "wsl2, issue", "date": "2022-03-14 22:03:28 +0900", "snippet": "Issue윈도우 터미널에서 wsl2를 실행하게 되면 기본 시작 경로가 C:\\Users\\&lt;YourUsername&gt;으로 되어있다.이것을 리눅스의 홈 디렉터리로 변경하려고 한다.Solution윈도우 터미널을 실행한 후, 상단의 설정(또는 Ctrl + ,)-좌측 하단의 Json 파일 열기를 클릭하여 에디터에서 자신의 WSL 프로필을 찾는다.{ \"guid\": \"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}\", \"hidden\": false, \"name\": \"WSL\", \"source\": \"Windows.Terminal.Wsl\",}source키-값 쌍 아래에 시작경로를 아래와 같이 추가한다.startingDirectory\": \"/home/&lt;directory name&gt;\"Ref.https://docs.microsoft.com/ko-kr/windows/terminal/troubleshooting#set-your-wsl-distribution-to-start-in-the-home--directory-when-launchedhttps://jakupsil.tistory.com/45" }, { "title": "Makefile", "url": "/posts/makefile/", "categories": "TIL", "tags": "unix", "date": "2022-03-14 19:52:23 +0900", "snippet": "Makefile 소프트웨어 개발을 위해 유닉스 계열 운영 체제에서 주로 사용하는 프로그램 빌드 도구main.cvoid hello();int main(){\thello();}test.c#include &lt;unistd.h&gt;void hello(){\twrite(1,\"hello world!/n\",13);}위와 같은 두개의 파일이 있을 때 평소대로 컴파일을 하려면 gcc -c main.c test.c와 gcc -o hello main.o test.o의 명령어를 사용해서 번거롭게 작업을 해야한다. 하지만 Makefile을 활용하면 make 명령어 하나로 이 작업들을 한번에 실행할 수 있다.MakefileSRCS\t= main.c test.cOBJS\t= ${SRCS:.c=.o}all:\t${OBJS} # 아래가 실행되기 위한 조건\t\tgcc -o hello main.c test.c주요 규칙 SRCS : 컴파일할 소스파일 OBJS : 중간단계의 오브젝트 파일 all : 기본 빌드 규칙SRCS\t= main.c test.cOBJS\t= ${SRCS:.c=.o}NAME\t= hello${NAME}:\t${OBJS}\t\tgcc -o ${NAME} ${OBJS}위와 같이 나타낼 수도 있다.기타 규칙 NAME CFLAGS : -Wall등의 플래그 사용 CC : 컴파일러 정의 RM .c.o clean : rm ${OBJS}처럼 써서 오브젝트 파일 삭제함 fclean re : fclean all처럼 전부 지웠다가 다시 컴파일할 수 있음 .PHONY : 파일로 해석하면 안되는 규칙들 정의Ref.https://ko.wikipedia.org/wiki/Make_(소프트웨어)" }, { "title": "Libft ① Subject", "url": "/posts/libft1/", "categories": "42Seoul, Libft", "tags": "42seoul, c", "date": "2022-03-13 00:00:00 +0900", "snippet": "PdfSummary이 프로젝트는 C 라이브러리를 코딩하는 것입니다.여기에는 프로그램에 의존할 많은 범용 기능이 포함되어 있습니다.IntroductionC 프로그래밍은 매우 유용한 표준 함수에 접근할 수 없을 때 매우 지루할 수 있습니다. 이 프로젝트를 통해 해당 기능을 다시 작성하고 이해하며 사용법을 배울 수 있습니다. 이 도서관이 앞으로의 모든 C 프로젝트를 도와줄 것입니다. 1년 내내 시간을 내서 당신의 libft를 확장하세요. 그러나 항상 어떤 기능이 허용되는지 확인해야 합니다!Common Instructions 당신의 프로젝트는 반드시 C로 작성되어야 합니다. 당신의 프로젝트는 Norm에 따라 작성되어야 합니다. 보너스 파일/함수가 있는 경우 해당 파일/함수가 Norm 검사에 포함되며 내부에 Norm 오류가 있으면 0을 받게 됩니다. 정의되지 않은 동작과 별도로 함수가 예기치 않게 종료되어서는 안 됩니다(segmentation fault, bus error, double free 등). 이렇게 되면 당신의 프로젝트는 작동하지 않는 것으로 간주되며 평가 중에 0점을 받습니다. 필요한 경우 할당된 모든 힙 메모리 공간을 적절하게 확보해야 합니다. Leak는 용납되지 않습니다. 제목에 필요한 경우 원본 파일을 필요한 출력으로 컴파일할 Makefile을 제출해야 합니다. 플래그가 -Wall, -Wextra 및 -Werror인 경우 cc를 사용하고 Makefile을 다시 링크하지 마십시오. Makefile에는 적어도 $(NAME), all, clean, fclean 및 re 규칙이 포함되어야 합니다. 프로젝트에 보너스를 제출하려면 Makefile에 규칙 보너스를 포함해야 합니다. 이 규칙 보너스는 프로젝트의 주요 부분에서 금지된 모든 다양한 헤더, 라이브러리 또는 함수를 추가합니다. 보너스는 다른 파일 _bonus에 있어야 합니다.제목에 다른 내용이 지정되지 않은 경우 {c/h}을(를) 선택합니다. 필수 및 보너스 부분 평가는 별도로 진행됩니다. 프로젝트에서 libft를 사용할 수 있는 경우 해당 소스 및 연결된 Makefile을 연결된 Makefile과 libft 폴더에 복사해야 합니다. 프로젝트의 Makefile은 Makefile을 사용하여 라이브러리를 컴파일한 다음 프로젝트를 컴파일해야 합니다. 테스트 프로그램은 제출하지 않아도 되고 채점이 되지 않지만 귀하의 프로젝트를 위해서 만들 것을 권장합니다. 그것은 당신의 작업과 동료들의 작업을 쉽게 테스트할 수 있는 기회를 줄 것입니다. defense동안 그 테스트들이 특히 유용하다는 것을 알게 될 것입니다. 실제로 defense하는 동안, 당신은 당신의 테스트 또는 당신이 평가하는 동료의 테스트를 자유롭게 사용할 수 있습니다. 할당된 git 저장소에 작업을 제출합니다. 깃 저장소의 작업만 등급이 매겨집니다. Deepthought가 당신의 작품을 채점하도록 지정되면, 동료 평가 후에 작업이 완료됩니다. Deepthought의 평가 작업 중에 작업 부분에서 오류가 발생하면 평가가 중단됩니다.Mandatory partTechnical considerations 전역 변수를 선언하는 것은 금지되어 있습니다. 보다 복잡한 기능을 분할하기 위해 helper function이 필요한 경우 정적 함수로 정의합니다. 이렇게 하면 해당 함수의 범위가 해당 파일로 제한됩니다. 모든 파일을 리포지토리의 루트에 배치합니다. 사용하지 않는 파일을 제출하는 것은 금지되어 있습니다. 모든 .c 파일은 -Wall -Wextra -Werror 플래그를 사용하여 컴파일해야 합니다. 라이브러리를 만들려면 명령어를 사용해야 합니다. libtool 명령은 사용할 수 없습니다. libft.a는 리포지토리의 루트에 생성되어야 합니다.Libc functions이 첫 번째 파트에서는 man에 정의된 대로 libc 함수 집합을 다시 코드화해야 합니다. 당신의 함수는 원본과 동일한 프로토타입과 동작을 보여줘야 합니다. 함수 이름 앞에는 “ft_“가 와야 합니다. 예를 들어 stren은 ft_stren이 됩니다. isalpha isdigit isalnum isascii isprint strlen memset bzero memcpy memmove strlcpy strlcat toupper tolower strchr strrchr strncmp memchr memcmp strnstr atoi calloc strdupAdditional functions이 두 번째 파트에서는 libc에 없거나, 그것의 일부이지만 다른 형태의 함수 들을 개발해야 한다. ft_substr ft_strjoin ft_strtrim ft_split ft_itoa ft_strmapi ft_striteri ft_putchar_fd ft_putstr_fd ft_putendl_fd ft_putnbr_fdBonus part필수 부분을 완료했다면 주저하지 말고 이 추가 부분을 더 진행하세요. 성공적으로 통과되면 보너스 점수를 얻을 수 있습니다.메모리와 문자열을 조작하는 기능은 매우 유용합니다. 그러나 리스트를 조작하는 것이 훨씬 더 유용하다는 것을 곧 알게 될 것이다.목록의 노드를 나타내려면 다음 구조체를 사용해야 합니다. libft.h 파일에 아래의 선언을 추가합니다.typedef struct s_list{void *content;struct s_list *next;} t_listt_list 구조체의 멤버는 다음과 같다: content노드에 포함된 데이터.void *를 사용하면 모든 종류의 데이터를 저장할 수 있습니다. next다음 노드의 주소.다음 노드가 마지막 노드인 경우 NULL.Makefile에서 보너스 함수를 libft.a에 추가할 make bonus 규칙을 추가합니다.목록을 쉽게 사용할 수 있도록 다음 기능을 구현하십시오. ft_lstnew ft_lstadd_front ft_lstsize ft_lstlast ft_lstadd_back ft_lstdelone ft_lstclear ft_lstiter ft_lstmap" }, { "title": "[42 Seoul] 본과정 합격", "url": "/posts/piscine-result/", "categories": "42Seoul, Piscine", "tags": "회고", "date": "2022-03-09 00:00:00 +0900", "snippet": "라피신 최종 결과 발표가 지난 3일에 나왔다. 내가 참여한 과정은 6기 1차였고 2차가 종료된 2/25에야 선발이 진행되었기 때문에 시간이 조금 걸린 것 같다.결과 발표📧합격은 이메일로 개별 통보되었다.42서울을 처음 지원했던 사이트에 들어가니 라피신에서 본과정으로 바뀌어있었다.다른 실력있는 카뎃들과 함께 공부할 본과정이 기대가 된다. 본과정부터는 2년이라는 긴 시간동안 자율학습을 진행해야 하는데 피신때의 마음가짐을 되새기면서 남에게 묻는 것을 서슴지 않고 나 또한 적극적으로 도와야겠다.앞으로의 계획📝우선 대학을 한학기만 휴학해 볼 생각이다. 지난 8일에 OT를 가서 학장 연설을 듣는데 일주일에 60시간 이상 공부할 것을 권장하였다. 하지만 대학 공부와 병행하게 되면 공부시간이 저것에 절반도 못미칠 것 같았다(주당 10시간은 할까). 또한 슬랙에서 카뎃들이 다른 일(대학, 직장)과의 병행을 비추천하기도 했다.또 당분간은 Libft 등의 과제를 해결하는데 초점을 맞추어 공부를 진행할 것이다. 요 근래에 풀어오던 알고리즘도 잠시 멈추고 과제 해결을 최우선으로 둘 것이다. 이후에 어느정도 블랙홀 기간이 늘어나고 기본실력이 쌓였다고 느낀 후에야 사이드 프로젝트를 병행할 계획이다.2년간 진행되는 교육이다보니 휴학을 계속 하기는 조금 힘들어서 2학기에는 상황을 봐가며 대학과 병행하게 되지 않을까 싶다." }, { "title": "[C언어] 다양한 포인터", "url": "/posts/various-pointer/", "categories": "TIL", "tags": "c", "date": "2022-03-08 10:13:21 +0900", "snippet": "Cvoid 포인터void *포인터이름;자료형이 정해지지 않은 포인터역참조를 할 수 없음.참고이중 포인터#include &lt;stdio.h&gt;int main(){ int *numPtr1; // 단일 포인터 선언 int **numPtr2; // 이중 포인터 선언 int num1 = 10; numPtr1 = &amp;num1; // num1의 메모리 주소 저장 numPtr2 = &amp;numPtr1; // numPtr1의 메모리 주소 저장 printf(\"%d\\n\", **numPtr2); // 20: 포인터를 두 번 역참조하여 num1의 메모리 주소에 접근 return 0;}함수 포인터반환값자료형 (*함수포인터이름)();함수 포인터와 저장될 함수의 반환값 자료형, 매개변수 자료형과 개수가 일치해야한다.//↓ 반환값 자료형void (*fp)(); // 반환값과 매개변수가 없는 함수 포인터 fp 정의// ↑ ↖ 매개변수가 없음// 함수 포인터 이름Ref.https://dojang.io/mod/page/view.php?id=279https://dojang.io/mod/page/view.php?id=592" }, { "title": "[Python] 백준 11729번 : 하노이 탑 이동 순서", "url": "/posts/boj11729-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-08 01:16:26 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11729Solutioncodedef hanoi(n, before, after) : if n == 1 : print(before, after) return hanoi(n-1, before, 6-before-after) # 1단계 print(before, after) # 2단계 hanoi(n-1, 6-before-after, after) # 3단계 n = int(input())print(2**n - 1)hanoi(n, 1, 3)Ref.https://study-all-night.tistory.com/6" }, { "title": "[Python] 백준 1009번 : 분산처리", "url": "/posts/boj1009-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-04 21:30:54 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1009Solution이 문제는 ab를 10으로 나눴을 때의 나머지를 구하는 문제이다.처음 문제를 보고나서 큰 고민 없이 아래의 코드를 제출했다가 2번 연속 시간초과로 오답처리가 되었다.오답코드import syst = int(sys.stdin.readline())for i in range(t): a,b = map(int, sys.stdin.readline().split()) n = pow(a,b)%10 print(n)이 코드엔 문제가 있는데 입력값의 조건이 (1 ≤ a &lt; 100, 1 ≤ b &lt; 1,000,000)인 상황에서 a, b 각각에 최댓값이 입력되면 처리시간이 오래 걸리게 된다. 따라서 처리과정의 효율화가 필요하다.또한 나머지가 0이 나올때 0이 출력되는 문제도 있다.정답코드import sysdef first_digit(a,b): a %= 10 if a==0: return 10 elif a==1 or a==5 or a==6: return a elif a==4 or a==9: b %= 2 return a**(b+2) % 10 elif a==2 or a==3 or a==7 or a==8: b %= 4 return a**(b+4) % 10 t = int(sys.stdin.readline())for i in range(t): a,b = map(int, sys.stdin.readline().split()) n = first_digit(a,b) print(n)알아야 하는 결과는 1의 자리이기 때문에 a를 10으로 나눈 뒤 거듭제곱을 하여 1의 자리만 관찰하기로 했다. 그렇게 0~9까지 총 10개의 수가 생기는데, 1, 5, 6의 경우 거듭제곱해도 같은 수가 나온다. 4, 9의 경우 2개의 수가 반복되며 2, 3, 7, 8은 4개의 수가 반복된다.a의 나머지를 구했을 때 나누어 떨어지는 경우 n0=1이 나오는 경우를 막기 위해 나누는 수를 한번 더 더해주었다.Memo입력되는 값의 조건을 유심히 살필 필요가 있다." }, { "title": "[Python] 백준 1541번 : 잃어버린 괄호", "url": "/posts/boj1541-py/", "categories": "Problem Solving, BOJ", "tags": "python, greedy", "date": "2022-03-03 21:09:26 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1541Solution식의 결과를 최소로 만들기 사고과정어떻게 해야 결과가 최소로 나올까?빼는 값을 최대로 만들자 (뺄 수 있는 최대로 빼기)“-“와 인접한 수 + ··· + 수를 모두 묶어서 계산 해결방법“-“로 split하기eval함수 활용해서 계산 예외처리왼쪽에 0이 n개 붙은 경우? try-except문, lstrip(‘0’) 활용0으로만 이루어진 수는? 빈 문자열이 되면 0으로 codea = input()b = a.split(\"-\") # '-'를 기준으로 분류for i in range(len(b)): try: b[i] = eval(b[i]) # 문자열로 된 계산식을 계산해서 결과를 저장 except SyntaxError: # 앞에 0이 붙은 경우 tmp = list(b[i].split('+')) for j in range(len(tmp)): tmp[j] = tmp[j].lstrip('0') if tmp[j].lstrip('0')!='' else '0' # 요소가 0으로만 된 경우 '0' 반환 b[i] = sum(map(int,tmp))res = b[0]for i in range(1, len(b)): # 맨 앞 요소부터 빼나가기 res -= b[i]print(res)" }, { "title": "[Python] 백준 2447번 : 별 찍기 - 10", "url": "/posts/boj2447-py/", "categories": "Problem Solving, BOJ", "tags": "python, 분할정복", "date": "2022-03-03 18:12:44 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2447Solution위 문제는 분할정복 알고리즘을 통해 풀 수 있다. 분할 정복분할 정복은 크게 분할-정복-병합 3단계로 나뉜다.각 단계에서는 문제를 쪼갤 수 있는 최소 단위로 나눈 후, 각 최소 문제를 해결하고, 전체 문제로 합치는 과정을 거친다.다시 위 문제로 돌아오면 문제는 3의 거듭제곱 꼴인 n값이 입력된다. 최종 출력할 별의 형태는 n x n 크기의 정사각형에 가운데에 n/3 만큼의 빈 공간이 있고 주변을 이루는 n/3 - 1개의 정사각형은 가운데에 n/32 * n/32 만큼의 빈 공간이 있는 프랙탈 형태를 띈다.따라서 제일 작은 단위인 n=3일 때의 형태. 즉, 아래와 같은 형태를 기저 단계(base case)로 저장해 두고 크기를 줄여서 해결해 나가면 된다.**** ****codeimport sysdef makeStar(n): # 기저 사례 if n == 3: return ['***','* *','***'] finalStar = [] beforeStar = makeStar(n//3) # 이전 별 모양 # 위, 아래 패턴 topStar = [] for i in range(n//3): lineStar = beforeStar[i]*3 topStar.append(lineStar) # 중간 패턴 midStar = [] for i in range(n//3): lineStar = beforeStar[i]+ ' '*(n//3) + beforeStar[i] midStar.append(lineStar) finalStar.extend(topStar) # 윗 줄 finalStar.extend(midStar) # 가운데 줄 finalStar.extend(topStar) # 아래 줄 return finalStarn = int(sys.stdin.readline())result = makeStar(n)print('\\n'.join(result)) # 요소를 줄 바꿔 출력Memo리스트를 활용한다는 사실을 알기 전까지는 해결하기가 정말 어려웠다.Ref.https://velog.io/@ember/분할정복-백준-2447-별-찍기-10https://ko.wikipedia.org/wiki/분할_정복_알고리즘https://abouteverything.tistory.com/10" }, { "title": "[Python] List Comprehension", "url": "/posts/list-comprehension/", "categories": "TIL", "tags": "python", "date": "2022-03-03 16:40:53 +0900", "snippet": "List Comprehension이란?리스트를 간단하게 한 줄로 표현하는 파이썬 문법형태[ ( 변수를 활용한 값 ) for ( 사용할 변수 이름 ) in ( 순회할 수 있는 값 )]예시size = 10arr = [i * 2 for i in range(size)]print(arr)[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]Refhttps://shoark7.github.io/programming/python/about-list-comprehension-python" }, { "title": "[Python] 백준 1002번 : 터렛", "url": "/posts/boj1002-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-02 18:56:53 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1002Solution두 원의 위치관계를 활용해 푸는 문제이다.t = int(input())for i in range(t): x1, y1, a, x2, y2, b = map(int, input().split()) d = ((x1-x2)**2+(y1-y2)**2)**0.5 # 두 점 사이의 거리 구하기 if d &gt; a+b or d &lt; abs(a-b): # 밖에서 안만나거나 안에서 안만나는 경우 print(0) elif d == a+b or d == abs(a-b) !=0: # 외접, 내접 print(1) elif abs(a-b) &lt; d &lt; a+b: # 서로 다른 두점에서 만나는 경우 print(2) else: # 같은 원인 경우 print(-1)두 점 사이의 거리를 먼저 구한 후 각각의 점에서 측정한 거리를 반지름이라고 생각하면 두개의 원을 만들 수 있다. 이 두 원의 교점이 문제에서 류재명이 있을 수 있는 위치인 셈이다.각각의 조건의 식은 학창시절 배운 거리와 반지름간의 관계를 활용하였다.처음 제출했을 때는 마지막 조건을 빠뜨렸는데 이는 입력이 0 0 1 0 0 1과 같이 동일한 원인 경우에 해당한다. 이 경우에는 교점이 무한대이므로 -1을 출력하도록 조건을 추가하였다.Ref.두 원의 위치관계" }, { "title": "[Python] 백준 2442번 : 별 찍기", "url": "/posts/boj2442-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-02 03:01:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2442Solution오답코드n = int(input())for i in range(n): for j in range(2*n-1): if n-1-i&lt;=j&lt;=n-1+i: print('*',end='') else: print(' ',end='') print()위 코드를 제출하니 출력형식이 잘못되었다며 오답처리가 되었다. 원인을 찾아보니 공백-별 순서로 출력해야하는데 공백-별-공백과 같이 끝에도 공백을 출력해서 생긴 문제였다.정답코드n = int(input())for i in range(n): print(\" \" * (n-1-i) + \"*\" * (2*i+1))Ref.https://jyeonnyang2.tistory.com/29" }, { "title": "[Python] 백준 11721번 : 열 개씩 끊어 출력하기", "url": "/posts/boj11721-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-02 02:33:01 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11721Solution이 문제는 문자열 인덱싱과 슬라이싱을 활용하여 풀었다.주어진 문자열의 길이를 10으로 나눈 몫과 나머지를 이용해서 10개 단위로 쪼개어 출력하였다.오답코드arr = input()n = len(arr)q = n//10r = n%10for i in range(q): print(arr[10*i:10*(i+1)])print(arr[-r:])이 코드는 길이가 10인 문자열이 입력된 경우 해당 문자열이 2번 출력되는 버그가 있어서 오답처리됐다.n에 10이 저장되면 q와 r에 각각 1과 0이 저장되는데, for문에어 이미 문자열을 다 출력하였음에도 마지막 줄에서 print(arr[0:]로 문자열이 한번 더 출력되게 된다.정답코드arr = input()n = len(arr)q = n//10r = n%10for i in range(q): print(arr[10*i:10*(i+1)])if r: print(arr[-r:])위 코드에 if문을 추가해서 문자열의 길이가 10의 배수가 아닐 때에만 마지막 줄이 실행되도록 하였다.Memo문자열 슬라이싱 개념을 한번 더 되짚어볼 수 있었다.Ref.문자열 인덱싱 및 슬라이싱" }, { "title": "[Python] 백준 11719번 : 그대로 출력하기", "url": "/posts/boj11719-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-02 02:02:49 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11718Solution이 문제는 파일의 끝(EOF)을 판단할 수 있는지를 묻는 문제이다. 파일의 끝은 Ctrl + D로 만들 수 있다.파이썬의 input함수의 경우 EOF를 만나게 되면 EOFError를 발생시키기 때문에 try-except 문을 통해 EOFError를 찾아서 끝낼 수 있다.codewhile True: try: print(input()) except EOFError: breakRef.출제 의도" }, { "title": "[Python] 백준 1931번 : 회의실 배정", "url": "/posts/boj1931-py/", "categories": "Problem Solving, BOJ", "tags": "python, greedy", "date": "2022-03-01 22:51:04 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1931Solution※ 풀이 포인트끝나는 시간 기준으로 정렬하기이 문제에서 중요한 점은 6 6과 같은 회의 직후에 6 7이 올 수 있다는 것이다.오답코드n = int(input())time = list()for i in range(n): time.append(list(map(int, input().split()))) # 입력값을 2차원 리스트로 저장time.sort(key=lambda x:x[1]) # 안쪽 리스트의 1번 인덱스 값을 기준으로 정렬present = 0count = 0for i in time: if i[0] &gt;= present: present = i[1] count += 1print(count)위 코드는 아래와 같은 반례가 존재한다.56 76 65 65 57 7위와 같이 입력했을 때 정답인 5가 아닌 4가 출력된다.56 75 66 65 57 7위와 같이 3, 4번째 줄을 바꿔서 입력하니 제대로 출력되는 것으로 보아 이차원 리스트를 정렬할 때 [5,6]보다 [6,6]이 앞에 오게 되어 발생하는 문제로 보인다.정답코드import sysn = int(sys.stdin.readline())time = list()for i in range(n): time.append(list(map(int, sys.stdin.readline().split())))time.sort(key = lambda x : (x[1], x[0]))present = 0count = 0for i in time: if i[0] &gt;= present: # 현재 회의의 끝시간과 같거나 늦는 경우 present = i[1] count += 1print(count)위의 코드에서 리스트를 정렬할 때 time.sort(key = lambda x : (x[1], x[0]))과 같이 작성하였는데, 안쪽 리스트의 1번 인덱스를 기준으로 정렬하되, 같은 값이 나오면 0번 인덱스를 통해 정렬하는 방식이다.여담으로 처음에는 위 코드에서 입력받는 부분을 전부 input()을 사용하였는데 채점시간이 4480ms가 나와서 sys.stdin.readline()으로 바꿔주니 344ms로 10배가 넘게 빠르게 나왔다. 채점에서 입력되는 n값이 상당히 큰 것 같다." }, { "title": "[Python] 백준 3009번 : 네 번째 점", "url": "/posts/boj3009-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-01 19:16:22 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/3009Solutionx1, y1 = map(int, input().split())x2, y2 = map(int, input().split())x3, y3 = map(int, input().split())x4, y4 = x1^x2^x3, y1^y2^y3print(x4, y4)Memo직사각형의 나머지 한 점은 다른 점들과 x, y좌표가 겹치는 횟수가 1번씩밖에 없다.위 코드는 비트단위연산인 XOR연산을 사용한 풀이방법으로, A ^ A ^ B == B과 같은 원리로 인해 겹치지 않는 좌표값을 찾을 수 있다.Ref.https://velog.io/@zero_mountain/알고리즘-직사각형-좌표-구하기" }, { "title": "[Python] 백준 9020번 : 골드바흐의 추측", "url": "/posts/boj9020-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-01 18:03:12 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/9020Solution오답코드1 (시간초과)import sys# 소수 탐색def prime_list(n): sieve = [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True]# 골드바흐 파티션 구하기def solve(n): j = 0 arr = {} # 모든 파티션을 저장할 딕셔너리 sosu = prime_list(n) while sosu[j] &lt;= (n//2): # 소수가 n/2 이하인 경우 if n-sosu[j] in sosu: arr[sosu[j]] = n-sosu[j] j += 1 min = n x, y = 0, 0 for k, v in arr.items(): # 차이가 최소인 파티션 찾기 if abs(k - v) &lt; min: min = abs(k - v) x, y = k, v return x, yt = int(input())for i in range(t): n = int(sys.stdin.readline()) x,y = solve(n) print(x,y)n 미만의 소수 중에서 합이 n이 나오는 모든 쌍을 찾아 딕셔너리에 저장 후 차이가 최소인 파티션을 리턴해 출력하는 코드이다.오답코드2 (시간초과)import sys# 소수 탐색def prime_list(n): sieve = [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True]# 골드바흐 파티션 구하기def solve(n): j = 0 sosu = prime_list(n) while sosu[j] &lt;= (n//2): # 소수가 n/2 이하인 경우 if n-sosu[j] in sosu: x, y = sosu[j], n-sosu[j] j += 1 return x, yt = int(input())for i in range(t): n = int(sys.stdin.readline()) x,y = solve(n) print(x,y)1번 코드에서 마지막으로 구한 파티션은 결국 차이가 최소인 파티션이기 때문에(n/2 이하인 소수만 찾았으므로) 따로 딕셔너리에 저장해서 비교하지 않고 바로 리턴했다.정답코드import sys# 소수 탐색def prime_list(n): sieve = [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True]# 골드바흐 파티션 구하기def solve(n): sosu = prime_list(n) j = len(sosu)-1 while sosu[j]&gt; n//2: # 소수가 n/2 초과인 경우 j-=1 while 1: if n-sosu[j] in sosu: x, y = sosu[j], n-sosu[j] break j -= 1 return x, yt = int(input())for i in range(t): n = int(sys.stdin.readline()) x,y = solve(n) print(x,y)위의 2번과 같은 방식의 코드이지만 이번에는 소수를 중간부터 찾아서 내려오는 방식으로 짰다. 어쨌든 차이가 최소가 되려면 (x, y)값에서 x가 제일 큰 경우를 찾아야 하기 때문에 큰 값부터 찾는게 효율적이기 때문이다.Ref.https://www.acmicpc.net/board/view/82570" }, { "title": "[Python] 백준 4948번 : 베르트랑 공준", "url": "/posts/boj4948-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-01 16:17:32 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/4948Solutiondef prime_list(n): sieve = [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True]n = int(input())while n: final_list = [i for i in prime_list(2*n+1) if i&gt;n] print(len(final_list)) n = int(input())Memo소수판별 알고리즘인 에라토스테네스의 체를 활용하였다." }, { "title": "[Python] 백준 9095번 : 1, 2, 3 더하기", "url": "/posts/boj9095-py/", "categories": "Problem Solving, BOJ", "tags": "python, dp", "date": "2022-03-01 15:55:31 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/9095Solution문제를 풀기에 앞서 각 값들의 규칙성을 파악해보면 하나의 값은 이전 3개의 값과 같다는 것을 알 수 있다. 이를 통해 점화식을 작성해보면 f(n) = f(n-1) + f(n-2) + f(n-3)과 같이 나타낼 수 있다.code1 (bottom-up)def solve(n): arr = [0, 1, 2, 4] # n=1~3까지의 값을 저장 for i in range(4, n+1): val = arr[i-3] + arr[i-2] + arr[i-1] arr.append(val) return arr[n]t = int(input())for i in range(t): n = int(input()) print(solve(n))위 코드는 점화식을 bottom-up의 형태로 반복문을 사용해 해결한 것이다. arr 리스트에 1~3까지 값들을 우선 저장한 뒤 반복문을 돌면서 값을 더해나가는 것이다.code2 (top-down)def solve(n): arr = [0, 1, 2, 4] if 0 &lt;= n &lt;= 3: return arr[n] return solve(n-1) + solve(n-2) + solve(n-3)t = int(input())for i in range(t): n = int(input()) print(solve(n))위 코드는 해당 점화식을 재귀함수 형태로 나타내어 해결한 것이다.Ref.https://yongku.tistory.com/entry/백준-9095번-1-2-3-더하기-파이썬Python" }, { "title": "Dynamic Programming(동적계획법)", "url": "/posts/dynamic-programming/", "categories": "TIL", "tags": "algorithm", "date": "2022-03-01 13:00:41 +0900", "snippet": "종류Bottom-Up 방식반복문 이용제일 작은 값부터 구해나감Top-Down 방식재귀함수 이용하나의 문제를 여러 하위 문제로 쪼갬하위 문제의 결과를 저장하여 상위문제에서 사용Ref.https://www.log2base2.com/algorithms/dynamic-programming/dynamic-programming.html" }, { "title": "[Python] 백준 10250번 : ACM 호텔", "url": "/posts/boj10250-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-03-01 02:46:37 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10250Solutioncode1t = int(input())for i in range(t): h,w,n = map(int, input().split()) count = 0 for i in range(1,w+1): for j in range(1,h+1): count+=1 if count==n: break if count==n: break print(\"%d%02d\" %(j,i))1번은 101호부터 차례대로 사람들을 배치해 나가면서 n번째 방이 되면 결과를 출력하는 방식이다.code2t = int(input())for i in range(t): h, w, n = map(int, input().split()) r = h if n%h==0 else n%h # 층수 구하기(나머지가 0일때는 4로) b = (n-r)//h + 1 # 호수 구하기 print(\"%d%02d\" %(r, b))2번의 경우 몫과 나머지를 이용하여 풀었는데 전체 층수인 h로 나누었을때의 나머지를 이용해 해당 층수를 구했고 몫을 통해 정문으로부터의 거리인 호수를 구했다.| 3 | 6 | 9 | 12 ||—|—|—|—-|| 2 | 5 | 8 | 11 || 1 | 4 | 7 | 10 |위의 예시를 보면 h와 w가 각각 3, 4인 상황에서 n=6의 층수와 호수를 구하는 방법은 h인 3으로 나누는 것이다. 그렇게 되면 r=3, b=2가 나오므로 302호가 나오게 된다." }, { "title": "[Python] 백준 1463번 : 1로 만들기", "url": "/posts/boj1463-py/", "categories": "Problem Solving, BOJ", "tags": "python, dp", "date": "2022-03-01 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1463Solution오답 코드x = int(input())n = 0while True: if x == 1 : break elif x % 3 == 0 : x = x/3 n = n+1 if x == 1 : break else : continue elif x % 2 == 0 : x = x/2 n = n+1 if x == 1 : break else : continue else : x = x-1 n = n+1 if x == 1 : break else : continueprint(n)문제에 제시된 연산 세가지에 순서가 부여됐다고 착각해서 코드를 틀리게 작성했다.힌트의 10을 입력했을 때 출력값이 다르게 나왔다.내 코드를 적용했을 때는 10→5→4→2→1 로 4가 나오지만 힌트에서는 10→9→3→1로 3이 나오게 된다.구글링을 해보니 이런 다이나믹 프로그래밍은 점화식을 활용해야 문제를 해결할 수 있다고 한다.정답 코드def make_one(n): arr = [0, 0, 1, 1] # 1로 만드는 최솟값 저장(3까지) for i in range(4, n+1): one, two, three = n, n, arr[i-1] # one, two가 결과값을 방해하지 않도록 n으로 if i % 3 == 0: one = arr[i//3] if i % 2 == 0: two = arr[i//2] arr.append(1 + min(one, two, three)) # (3가지 방법 중 최솟값+1)로 저장 return arr[n]n = int(input())print(make_one(n))DP 중 Bottom-up 방식을 사용하여 해결한 코드이다.Ref.https://roamingman.tistory.com/12" }, { "title": "[Python] 백준 1193번 : 분수찾기", "url": "/posts/boj1193-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-28 19:44:11 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1193Solution오답코드import sysx = int(sys.stdin.readline())k, v, count = 1, 1, 1while count &lt; x: if k == 1: # 제일 윗 행일 때 if v % 2 == 1: # 분모가 홀수 v += 1 count += 1 else: # 분모가 짝수 while count &lt; x and v &gt; 1: k += 1 v -= 1 count += 1 elif v == 1: # 제일 왼쪽 열일 때 if k % 2 == 0: # 분자가 짝수 k += 1 count += 1 else: # 분자가 홀수 while count &lt; x and k &gt; 1: k -= 1 v += 1 count += 1print(k, v, sep='/')위 코드는 시간초과로 오답처리가 된 코드이다. 문제를 제대로 이해하지 못하고 주어진 순서에 해당하는 분수를 찾는 과정을 매우 비효율적으로 설계하였기 때문이라고 생각한다.정답코드x = int(input())n = (2*x + 1/4)**(1/2) - 1/2n = int(n) if n % 1 == 0 else int(n) + 1 # 해당 대각선줄의 번호(올림 후 정수로)line_order = int(x - n*(n-1)/2 - 1) # 해당 대각선줄에서의 인덱스(0부터 시작)if n % 2: # n이 홀수인 경우 print(n-line_order, 1+line_order, sep='/')else: # n이 짝수인 경우 print(1+line_order, n-line_order, sep='/')undefined위의 표를 보면 분자는 row를, 분모는 column을 각각 나타낸다는 것을 알 수 있다. 하지만 이것을 풀이에 적용시키기에는 무리가 있었다.대신 이 표에서 다른 규칙성을 찾을 수 있는데, 하나의 이동경로인 대각선 상에 있는 값들은 분자와 분모의 합이 동일하다.undefined이렇게 값을 대각선으로 분류하여 안의 값들을 내림차순(분모는 오름차순)으로 정리하면 1번 대각선은 1/1, 2번 대각선은 (2/1, 1/2), 3번 대각선은 (3/1, 2/2, 1/3), 4번 대각선은 (4/1, 3/2, 2/3, 1/4), 5번 대각선은 (5/1, 4/2, 3/3, 2/4, 1/5), ··· 와 같이 나오게 된다.※ 풀이 포인트 각 라인에 속하는 값의 개수는 1, 2, 3, 4, 5, 6, ··· 으로 1씩 증가하는 형태를 보인다. 따라서 n번 라인까지의 누적된 칸의 개수(==n번 라인의 끝값의 순번)는 1 + 2 + 3 + ··· + n이 된다. 각 라인의 첫값의 분자가 홀수, 짝수냐에 따라 이동방향이 순방향, 역방향으로 달라진다.여기까지 정리가 되면 다음으로는 입력된 정수(==순번)가 몇번째 라인에 속하는지 판단하는 것인데, 이 과정에서는 고등학교때 배웠던 정수의 합 공식을 활용하였다. n(n+1)/2 = x라는 식을 정리하여 n = (2*x + 1/4)**(1/2) - 1/2와 같은 계산식을 얻어냈다. 값을 올림한 이유는 x가 6일때는 n이 3으로 제대로 나오지만 5인 경우 3번째 줄에 속해있지만 n값은 2.7016으로 나오기 때문이다.다음은 해당 대각선에서 몇번째 인덱스의 값인지를 구했는데 이는 (해당 칸까지의 누적값) - ((n-1)번째 줄까지의 누적값) - 1과 같이 구할 수 있다.Memo이번 문제는 문제의 원리에 대해 얼마나 자세히 파악하고 있는지에 따라 그 풀이과정의 효율성이 극명하게 갈리는 것 같다.Ref.https://youtu.be/bEQq9jvU_Hg" }, { "title": "[Python] 백준 11653번 : 소인수분해", "url": "/posts/boj11653-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-28 13:07:52 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11653Solutioncode1import sysn = int(sys.stdin.readline())last_insu = 2while n&gt;1: for i in range(last_insu,n+1): if n % i == 0: sys.stdout.write(str(i) + '\\n') n //= i last_insu = i break위 코드는 정석적으로 작은수부터 나눠나가면서 소인수분해를 하는 방법이다. 처음 작성했을 당시 큰 값이 입력되었을 때 시간초과가 나올 확률이 높아보여 아래의 방법을 사용하여 제출하였다.code2import sysdef prime_list(n): sieve = [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True] n = int(sys.stdin.readline())insu_list = prime_list(n+1)last_insu = 0while n&gt;1: for i in range(last_insu, len(insu_list)): if n % insu_list[i] == 0: sys.stdout.write(str(insu_list[i]) + '\\n') n //= insu_list[i] last_insu = i break위 코드는 에라토스테네스의 체를 활용하여 주어진 정수까지의 소수를 구한 뒤 그 안에서 인수를 찾아나가는 방식이다.Memo에라토스테네스의 체가 소수판별을 할 때 효율적이라는 사실만으로 아래의 방식을 먼저 사용하였는데 놀랍게도 채점결과는 정반대였다. 아래 결과를 보면 2번이 채점시간은 2배, 메모리는 무려 4배가 넘게 나왔다.원인을 찾아보니 2번은 체를 구하는 과정이 O(Nloglog N)만큼의 시간복잡도가 나오는데반해 1번은 소수를 찾는 과정이 O(sqrt(N))이기 때문에 더 빠른 것이라고 한다.Ref.https://www.acmicpc.net/board/view/75684" }, { "title": "[Python][C언어] 백준 9498번 : 시험 성적", "url": "/posts/boj9498-py/", "categories": "Problem Solving, BOJ", "tags": "python, c", "date": "2022-02-28 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/9498Solutioncode(python)x = int(input())if 90&lt;=x&lt;=100: print(\"A\")elif 80&lt;=x&lt;=89: print(\"B\")elif 70&lt;=x&lt;=79: print(\"C\")elif 60&lt;=x&lt;=69: print(\"D\")else : print(\"F\")code(c)#include &lt;stdio.h&gt;int main(){ int a; scanf(\"%d\", &amp;a); if (a&gt;=90){ printf(\"A\"); } else if (a&gt;=80){ printf(\"B\"); } else if (a&gt;=70){ printf(\"C\"); } else if (a&gt;=60){ printf(\"D\"); } else{ printf(\"F\"); }}" }, { "title": "유클리드 호제법(Euclidean algorithm)", "url": "/posts/euclidean/", "categories": "TIL", "tags": "python, algorithm", "date": "2022-02-27 23:48:38 +0900", "snippet": "요약2개의 자연수 또는 다항식의 최대공약수를 구하는 알고리즘개념2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다. 이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.소스 코드def gcd(m,n): while n != 0: t = m%n (m,n) = (n,t) return abs(m)Ref.https://ko.wikipedia.org/wiki/유클리드_호제법" }, { "title": "[Python] 백준 2751번 : 수 정렬하기 2", "url": "/posts/boj2751-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-27 23:46:20 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2751Solution오답 코드1N = int(input())numbers = []for i in range(N) : numbers.append(int(input()))for i in range(1, len(numbers)) : while (i&gt;0) and (numbers[i] &lt; numbers[i-1]) : numbers[i], numbers[i-1] = numbers[i-1], numbers[i] i -= 1 for n in numbers : print(n)오답 코드2import sysdef bubbleSort(x):\tlength = len(x)-1\tfor i in range(length):\t\tfor j in range(length-i):\t\t\tif x[j] &gt; x[j+1]:\t\t\t\tx[j], x[j+1] = x[j+1], x[j]\treturn xN = int(input())numbers = []for i in range(N) : numbers.append(int(sys.stdin.readline()))bubbleSort(numbers) for _ in numbers : sys.stdout.write(str(_)+'\\n')버블정렬을 사용한 풀이로, input과 print를 각각 stdin.readline, write함수로 바꿔주었는데도 시간초과가 나왔다. 버블정렬의 시간복잡도가 O(N2)으로 비효율적이기 때문에 발생한 것으로 보인다.정답 코드import sysn = int(input())numbers = []for i in range(n) : numbers.append(int(sys.stdin.readline())) for j in sorted(numbers): sys.stdout.write(str(j)+'\\n')위 코드는 파이썬의 내장함수인 sorted 함수를 사용하였다. 병합정렬 기반으로 만들어진 함수이기 때문에 최악의 경우에도 시간복잡도 O(N logN)를 갖는다. 또한 입출력은 sys를 import해서 사용했다.Memo시간제한이 있는 문제의 경우 파이썬 라이브러리를 활용하면 더욱 효율적이고 빠르게 문제를 풀어낼 수 있는 것 같다.Ref.파이썬 내장함수파이썬 sorted 함수" }, { "title": "[Python] 백준 2609번 : 최대공약수와 최소공배수", "url": "/posts/boj2609-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-27 23:04:26 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2609Solutioncode1# 최대공약수def gcd(a,b): for i in range(min(a,b), 0, -1): if a % i == 0 and b % i == 0: return i# 최소공배수def lcm(a,b): for i in range(max(a,b), a*b+1): if i % a == 0 and i % b == 0: return ia, b = map(int, input().split())print(gcd(a, b))print(lcm(a, b))위 코드도 정답이 되긴 하지만 계산과정이 조금 비효율적이다. 아래의 방법은 유클리드 호제법과 최소공배수의 성질을 활용하여 시간을 단축하였다.code2 (유클리드 호제법)# 최대공약수def gcd(a, b): while b: r = a%b (a, b) = (b, r) return abs(a)a, b = map(int, input().split())x = gcd(a, b)y = int(a*b/x) # 최소공배수print(x)print(y)Memo위의 코드에서 최대공약수를 구하는 부분은 유클리드 호제법을 활용한 방법으로 나머지가 0이 될 때의 값을 찾는 것이다.최소공배수는 최대공약수를 이용해서 구했는데 최소공배수 = 두수의 곱/최대공약수인 수의 성질을 활용한 것이다.Ref.유클리드 호제법최대공약수와 최소공배수의 관계" }, { "title": "[Python] 백준 2775번 : 부녀회장이 될테야", "url": "/posts/boj2775-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-27 17:36:21 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2775Solution오답 코드def people(k, n): count = 0 if k==0: return n else: for i in range(1,n+1): count += people(k-1, i) return countt = int(input())for i in range(t): k = int(input()) n = int(input()) print(people(k, n))재귀함수 형태로 함수를 정의해서 제출하니 시간초과로 오답처리가 됐다. 낮은 층수를 구할때는 큰 문제가 없지만 14층 14호와 같이 높은 층을 구하려면 시간이 오래 걸리게 되어 다른 방법을 찾게 됐다.정답 코드apart_list = [[0 for j in range(14)] for i in range(15)]for i in range(15): apart_list[i][0] = 1for h in range(14): apart_list[0][h] = h+1for i in range(1,15): for j in range(1,14): apart_list[i][j] = apart_list[i][j - 1] + apart_list[i - 1][j]t = int(input())for i in range(t): k = int(input()) n = int(input()) print(apart_list[k][n-1])Memo위 코드는 한 칸의 값은 바로 왼쪽과 아래쪽 값의 합과 같다는 점을 활용하여 2차원 리스트를 만들어 문제를 해결하였다.Ref.https://god-gil.tistory.com/42" }, { "title": "[Python] 백준 1924번 : 2007년", "url": "/posts/boj1924-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-27 15:04:55 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1924Solutioncode1week = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']m, d = map(int,input().split())whereis_sun = 0if m==4 or m==7: whereis_sun = 1elif m==9 or m==12: whereis_sun = 2elif m==6: whereis_sun = 3elif m==2 or m==3 or m==11: whereis_sun = 4elif m==8: whereis_sun = 5elif m==5: whereis_sun = 6what_day = week[(d + (7 - whereis_sun)) % 7]print(what_day)각 달의 일요일의 일을 7로 나눈 값을 if문으로 분류해서 리스트에서 찾았다.code2weeklist = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']daylist = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]day = 0 #1월부터 해당 월까지의 누적 일수m, d = map(int,input().split())for i in range(m-1): day += daylist[i] #누적 일수를 구함day = (day + d) % 7 #1월 1일부터 해당 날짜까지의 일수를 7로 나눔 print(weeklist[day])1과 달리 각 달을 리스트에 저장하게 되면 조건문을 길게 적지 않고 효율적으로 짤 수 있다.Ref.https://gabii.tistory.com/entry/BaekJoonPython3-백준-1924번-2007년" }, { "title": "[Python] 백준 2869번 : 달팽이는 올라가고 싶다", "url": "/posts/boj2869-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-27 00:39:07 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2869Solution오답 코드 (시간초과)a,b,v = map(int, input().split())day = 1snail_height = 0while 1: snail_height+=a if v &lt;= snail_height: break snail_height-=b day+=1print(day)이 코드는 1일차부터 하루씩 늘려나가면서 찾는 방법인데, 낮은 숫자가 입력되었을 때는 정상 출력되지만 day의 값이 크게 증가하게 되면 찾는 시간이 너무 오래걸리게 된다.정답 코드from math import ceila, b, v = map(int, input().split())day = ceil((v-b) / (a-b)) # 실수를 ceil함수를 사용하여 올림print(day)Memo위에는 시간초과가 나지 않는 코드이다. 수식의 의미는 낮에 a만큼 올라가고 밤에 b만큼 올라온다는 의미의 식인 v = a * day + (-b) * (day-1)를 좌변에 day만 남기고 정리한 것이다. 값을 올림한 이유는 day의 값이 소수형태로 나온다는 의미는 하루가 더 필요한 것이기 때문이다.Ref.https://stultus.tistory.com/entry/Python-백준-2869-달팽이는-올라가고-싶다https://yoonsang-it.tistory.com/9" }, { "title": "[Python] 백준 1929번 : 소수 구하기", "url": "/posts/boj1929-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-26 19:31:05 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1929Solution오답 코드1def is_sosu(n): for i in range(2,n): if n % i == 0: return 0 return 1m, n = map(int, input().split())for i in range(m, n+1): if is_sosu(i) and i &gt; 1: print(i)위 코드를 제출하니 바로 시간초과가 났다. 이 문제를 해결하기 위해 예전에 풀었던 문제에서 소수판별하는 범위를 n^0.5로 해서 해결했던 것을 떠올려 적용했다. 또한 입력, 출력을 받는 방법을 input(), print()대신 stdin.readline().split(), stdout.write()으로 바꿨다.정답 코드1from sys import stdin, stdoutdef is_sosu(n): for i in range(2,int(n**0.5)+1): if n % i == 0: return 0 return 1m, n = map(int, stdin.readline().split())for i in range(m, n+1): if is_sosu(i) and i&gt;1: stdout.write(str(i)+'\\n')이렇게 제출한 뒤 정답처리가 됐지만 질문게시판을 확인해보니 에라토스테네스의 체라는 것을 활용해서도 시간초과 문제를 해결할 수 있다고 하였다.정답 코드2def prime_list(n): # 에라토스테네스의 체 초기화: n개 요소에 True 설정(소수로 간주) sieve = [True] * n # n의 최대 약수가 sqrt(n) 이하이므로 i=sqrt(n)까지 검사 m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i] == True: # i가 소수인 경우 for j in range(i+i, n, i): # i이후 i의 배수들을 False 판정 sieve[j] = False # 소수 목록 산출 return [i for i in range(2, n) if sieve[i] == True] m, n = map(int, input().split())final_list = [i for i in prime_list(n+1) if i&gt;=m]for i in final_list: print(i)Memo‘에라토스테네스의 체’라는 개념을 통해 문제를 효율적으로 해결할 수 있다.Ref.에라토스테네스의 체란에라토스테네스의 체 활용" }, { "title": "[Python] 백준 2292번 : 벌집", "url": "/posts/boj2292-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-26 18:37:09 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2292Solution오답 코드# 해당 레이어의 벌집번호의 최댓값을 구하는 함수def fibo(n): if n == 0: return 1 else: return fibo(n-1) + 6*n# 벌집이 속해있는 레이어를 구하는 함수def find_layer(n): layer = 0 if n&lt;1: return 1 while n &gt; fibo(layer): layer += 1 return layer + 1n = int(input())print(find_layer(n))위 코드는 처음 작성한 코드인데 두개의 함수를 정의한 뒤에 재귀함수 형태로 값을 찾아나가는 방식이다. 예제로 주어진 값을 포함하여 테스트케이스를 입력했을 때는 정상 작동했지만 막상 코드를 제출하니 런타임 에러 (RecursionError) 가 발생했다. 입력되는 N값의 범위가 1 ≤ N ≤ 1,000,000,000 라는 것을 놓쳐서 발생한 문제였다. 파이썬의 재귀함수 최대 깊이는 sys.getrecursionlimit()를 통해 확인해보니 1000이었는데 그 범위를 넘어서서 에러가 발생한 것이다.실제로 값을 입력해서 확인해보니 입력된 N의 값이 2979037일 때까지는 정상적으로 출력되지만 2979038이 입력됐을 때는 아래와 같은 에러메시지가 출력됐다.Traceback (most recent call last): File \"code.py\", line 16, in &lt;module&gt; print(find_layer(n)) File \"code.py\", line 11, in find_layer while n&gt;fibo(layer): File \"code.py\", line 5, in fibo return fibo(n-1) + 6*n File \"code.py\", line 5, in fibo return fibo(n-1) + 6*n File \"code.py\", line 5, in fibo return fibo(n-1) + 6*n [Previous line repeated 994 more times] File \"code.py\", line 2, in fibo if n == 0:RecursionError: maximum recursion depth exceeded in comparison정답 코드n = int(input())comb_num = 1 # 초기 벌집 개수layer = 1while n &gt; comb_num : comb_num += 6 * layer # 벌집 6의 배수로 증가 layer += 1print(layer)Memo계속 막혔던 문제여서 하단 블로거의 풀이를 본 뒤에야 해결할 수 있었다. 이 블로거는 재귀함수를 이용하여 레이어를 구하는 대신 while문에서 6 * layer만큼 벌집개수를 증가시키는 방법을 통해 문제를 해결하였다.Ref.https://ooyoung.tistory.com/82" }, { "title": "[Python] 백준 1361번 : 그룹 단어 체커", "url": "/posts/boj1361-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-25 19:59:43 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1316Solutiondef is_group_word(word): counted = [] while word: if word[0] in counted: # 제일 앞 문자가 리스트에 있는지 확인 return 0 counted.append(word[0]) # 제일 앞 문자를 리스트에 저장 word = word.lstrip(word[0]) # 앞문자와 연속되는 문자 제거 return 1res = 0n = int(input())for i in range(n): word = input() res += is_group_word(word)print(res)Memois_group_word 함수에서 처음에는 for문에 i인덱스를 통해 word를 돌았지만 lstrip을 통해 제거한 문자가 for문의 word에는 남아있는 문제가 생겨서 while문을 사용하게 되었다." }, { "title": "[Python] 백준 2941번 : 크로아티아 알파벳", "url": "/posts/boj2941-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-25 18:58:48 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2941Solutioncode1from string import ascii_lowercase# 길이가 2인 알파벳 -&gt; 1인 알파벳 순서로 저장croatian_alpha = ['c=','c-','dz=','d-','lj','nj','s=','z='] + list(ascii_lowercase)word = input()res=0for i in croatian_alpha: if i in word: res += (word.count(i)) # 입력된 단어에서 알파벳 카운팅 word = word.replace(i,'.') # 카운팅 마친 뒤 해당 알파벳을 '.'으로 변경print(res)code2croatian_alpha = ['c=', 'c-', 'dz=', 'd-', 'lj', 'nj', 's=', 'z=']word = input()for t in croatian_alpha: word = word.replace(t, '.') print(len(word))Memo이 문제를 해결하기 위해 리스트를 활용하였다. 리스트에는 길이가 2인 알파벳 부터 1인 알파벳 순으로 저장하였는데 그렇지 않으면 c나 d등의 일반 알파벳이 중복카운팅될 수 있기 때문이다.처음에는 카운팅을 마친 알파벳을 strip 함수를 통해 제거했는데 끝부분만 제거가 되었다. strip함수는 왼쪽과 오른쪽 끝부분에만 적용되는 함수이기 때문이다.따라서 replace함수를 replace(i,'') 형태로 사용하였는데 이번에 발생한 문제는 nljj가 테스트케이스로 입력되었을 경우에 결과가 3이 아닌 2가 출력되는 것이었다. 확인해보니 처음 lj를 카운트한 뒤에 제거하게 되면 nj가 남게되어 다음번 카운트때 길이가 2인 nj로 인식되어 한개로 카운트가 되어 발생한 문제였다. 이를 해결하기 위해 공백으로 바꾸는 대신 알파벳이 아닌 다른 문자로 바꾸어주었다.code2는 다른 블로거의 풀이를 보다가 알게 된 방법인데 일반 알파벳은 따로 세지 않고 바꿔준 word 문자열의 길이를 세어서 확인하는 방법이다. 개수만 세면 되는 문제이기 때문이다.Ref.https://hongku.tistory.com/255" }, { "title": "[Python] 백준 5622번 : 다이얼", "url": "/posts/boj5622-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-25 18:01:08 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/5622Solutioncode 1def dial_time(letter): if 'A'&lt;=letter&lt;='C': return 3 elif 'D'&lt;=letter&lt;='F': return 4 elif 'G'&lt;=letter&lt;='I': return 5 elif 'J'&lt;=letter&lt;='L': return 6 elif 'M'&lt;=letter&lt;='O': return 7 elif 'P'&lt;=letter&lt;='S': return 8 elif 'T'&lt;=letter&lt;='V': return 9 elif 'W'&lt;=letter&lt;='Z': return 10total_time = 0dial_word = input()for i in dial_word: total_time += dial_time(i)print(total_time)첫번째 방법은 각 문자를 if문으로 구분하여 시간을 반환하는 함수를 정의하는 것이다.code 2dial_list = ['ABC', 'DEF', 'GHI', 'JKL', 'MNO', 'PQRS', 'TUV', 'WXYZ']a = input()total_time = 0for j in a: for i in range(len(dial_list)): if j in dial_list[i]: total_time += i+3print(total_time)두번째 방법은 리스트를 활용하는 방법이다. 각 번호에 해당하는 시간이 등차수열을 이루기 때문에 효율적으로 해결이 가능하다.Ref.https://j-remind.tistory.com/76" }, { "title": "[Python] 백준 2908번 : 상수", "url": "/posts/boj2908-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-25 17:16:42 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2908Solutioncode1첫번째 방법은 리스트를 활용한 방법이다.a, b = input().split()# 리스트로 변경a_list = list(a)b_list = list(b)# 리스트 뒤집기a_list.reverse()b_list.reverse()# 리스트 -&gt; 문자열 변환a = ''.join(a_list)b = ''.join(b_list)a = int(a)b = int(b)print(max(a,b))code2두번째 방법은 문자열 슬라이싱을 이용한 방법이다.a, b = input().split()a = int(a[::-1])b = int(b[::-1])print(max(a,b))Memo첫번째 방법을 통해 문제를 해결했는데 다른 방법을 찾던 중 두번째 방법을 알게 되었다. 리스트로 변환했다가 다시 문자열로 변환하는 번거로움도 없고 간단하게 해결할 수 있다.Ref.https://blockdmask.tistory.com/581" }, { "title": "TIL 220225", "url": "/posts/til220225/", "categories": "TIL", "tags": "python", "date": "2022-02-25 17:13:45 +0900", "snippet": "Pythonjoin 함수'구분자'.join(리스트)리스트를 구분자로 구분해 문자열로 합쳐서 반환하는 함수예시)a = ['a','b','c']b = '!'.join(a)print(b)실행결과)a!b!c응용) 리스트를 문자열로 변환구분자를 비워둔 채로 사용하게 되면 리스트의 요소를 그대로 문자열로 바꿔준다.a = ['h','e','l','l','o']b = ''.join(a)print(b)실행결과)helloRefjoin 함수" }, { "title": "[Python] 백준 1157번 : 단어 공부", "url": "/posts/boj1157-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-25 14:01:26 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1157Solutionword_list = list(input().upper())# list에서의 요소를 key로, value는 0으로 하는 dictionary 정의word_count = {string : 0 for string in word_list}for i in word_list: # 빈도 카운팅 word_count[i]+=1# value가 최대인 key를 리스트에 저장mode = [k for k,v in word_count.items() if max(word_count.values()) == v]if len(mode) == 1: print(mode[0])else: # 최빈값이 여러개인 경우 print('?')Memo중복을 제거한 후에 카운트하기 위해 딕셔너리 사용함. 최대값이 여러개인 경우에 max(word_count,key=word_count.get)의 경우는 하나밖에 인식하지 못해서 위와 같이 구함.Ref.dictionary 최대값 구하는 방법" }, { "title": "[Python] 백준 1065번 : 한수", "url": "/posts/boj1065-py/", "categories": "Problem Solving, BOJ", "tags": "python, 브루트포스", "date": "2022-02-25 12:56:30 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1065Solutiondef is_hansu(number): if number &gt;= 100: #100이상일 때만 체크 a = [] while(number != 0): # 각 자릿수 분리 a.append(number % 10) number = number // 10 d = a[0] - a[1] for i in range(len(a)-1): if a[i]-a[i+1] == d: # 등차수열 체크 continue else: return 0 return 1count=0n = int(input())for i in range(1, n+1): if is_hansu(i): count+=1print(count)Memo한수인지를 체크해주는 함수를 정의하였다.체크할 정수가 두자리수 이하인 경우(1~99) 항상 한수이기 때문에 100이상부터 체크하였다. 배열에 저장한 자리수를 for문을 돌며 비교하여 한수가 맞는 경우 1을 리턴하게 하였다." }, { "title": "[Python] 백준 4344번 : 평균은 넘겠지", "url": "/posts/boj4344-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-24 22:21:44 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/4344Solution오답코드c = int(input())for i in range(c): a = list(map(int,input().split())) n = a[0] del a[0] # 학생의 수 리스트에서 제거 a.sort() # 오름차순으로 정렬 avg = sum(a)/n for j in range(n): if a[j]&gt;avg: # 평균보다 높은 경우 print('%.3f%%' %((n-j)/n*100)) # 학생의 비율 출력 break처음에 작성한 코드이다. 내가 구현한 방식은 다음과 같다. 우선 한 줄을 통째로 리스트로 받는다. 그 후 0번째 인덱스의 요소를 변수에 저장 후 리스트에서 제거한다. 이렇게 해서 성적만 남게 된 리스트를 오름차순 정렬한 후 평균과 비교하며 큰 값이 존재하면 해당 요소를 포함한 뒤의 값들을 세어 비율을 출력하는 방식이다. 하지만 이러한 방식으로 짠 코드에 예제 input을 입력했을 때 모두 정상 출력되었고 육안으로 크게 문제될 만한 부분이 없다고 생각했는데도 4번이나 오답처리가 됐다.결국 질문게시판에 질문을 올린 후에야 문제점을 찾을 수 있었다. 평균을 넘는 학생이 한명도 없는 경우(모든 학생들의 점수가 같은 경우)에는 0.000%를 출력해야 하지만 내 코드에서는 아무런 출력도 없었다. 내 코드는 평균보다 높은 학생이 최소 한명은 존재한다는 가정이 들어간 코드였기 때문이다.정답코드c = int(input())for i in range(c): a = list(map(int,input().split())) n = a[0] del a[0] # 학생의 수 리스트에서 제거 a.sort() # 오름차순으로 정렬 avg = sum(a)/n for j in range(n): if a[j]&gt;avg: # 평균보다 높은 경우 print('%.3f%%' %((n-j)/n*100)) # 학생의 비율 출력 break elif j==n-1: # 평균보다 높은 학생이 없는 경우 print(\"0.000%\")Memo위의 문제를 해결하기 위한 가장 명확한 방법은 학생의 수를 새로운 변수를 통해 카운트한 후 for문이 종료되는 시점에 print하는 것이지만 빠른 수정을 위해 for문에 elif문을 사용하여 예외처리를 하는 방법으로 해결하였다." }, { "title": "[Python] 백준 10951번 : A+B - 4", "url": "/posts/boj10951-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-24 16:52:14 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10951Solution오답코드import syswhile 1: a,b = map(int,sys.stdin.readline().split()) print(a+b)이 코드를 제출했더니 런타임오류가 발생하여 오답처리되었다. 관련 문제를 구글링해보니 입력이 없을 경우를 고려하지 않아 발생한 오류였다.정답코드import syswhile 1: try: a,b = map(int,sys.stdin.readline().split()) except: break print(a+b)Memo위와 같이 try-excpet문으로 명령행에 입력이 없을 경우 while문을 break하도록 하였다.Ref.https://www.acmicpc.net/board/view/43198" }, { "title": "[Python] 백준 15552번 : 빠른 A+B", "url": "/posts/boj15552-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-24 12:54:19 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/15552Solutioncodeimport syst = int(input())for i in range(t): a,b = map(int,sys.stdin.readline().split()) print(a+b)Memo이 문제는 기본적인 a+b를 구하는 것 같지만 시간초과까지 고려해야한다. 두번째 줄부터 들어오는 값을 input을 통해 받게 되면 시간초과가 발생하는 이유는 함수의 작동원리에 있다.input 함수는 들어온 수를 루프를 돌며 하나씩 입력받는다고 한다.(참고)반면 readline 함수를 사용하게 되면 한 줄씩 입력을 받기 때문에 이러한 문제를 해결할 수 있다.Ref.https://velog.io/@yeseolee/Python-파이썬-입력-정리sys.stdin.readline" }, { "title": "TIL 220224", "url": "/posts/til220224/", "categories": "TIL", "tags": "python", "date": "2022-02-24 12:30:32 +0900", "snippet": "Python시퀀스 객체(list, tuple 등)에서의 음수 인덱스list라는 이름의 리스트에서 list[-n]은 뒤에서 n번째 요소를 가리킨다.예) list = [1,2,3,4,5]에서 list[-1]==5, list[-5]==1예외 처리 (try-except 문)try: ...except: ...위와 같은 형태로 쓰여 try블록 안에서 오류가 발생하면 except블록을 실행한다.try: ...except 발생 오류: ...위와 같이 특정한 오류에 한해 except문을 실행시킬 수도 있다.import syswhile 1: try: a,b = map(int,sys.stdin.readline().split()) except ValueError as m: print(m) break print(a+b)이처럼 발생한 오류가 어떤 종류인지를 확인할 수도 있다. 위 코드를 실행하고 오류를 발생시키면 아래와 같은 결과가 출력된다.not enough values to unpack (expected 2, got 0)Ref.https://dojang.io/mod/page/view.php?id=2207https://velog.io/@chp0510/시퀀스-객체-정리https://wikidocs.net/30#try-except" }, { "title": "[Python] 백준 15596번 : 정수 N개의 합", "url": "/posts/boj15596-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-23 17:08:30 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/15596Solutioncodedef solve(a: list) -&gt; int: return sum(a)Memo위 코드에서 :과 -&gt;부분은 type annotation이라는 것으로 변수와 반환값의 자료형에 대해 명시적으로 알려주는 주석이다. 파이썬은 동적타입 언어이므로 자료형을 명시하지 않아도 코드를 실행할 수 있지만 개발자간의 커뮤니케이션을 위해 적는다고 한다.Ref.https://bluese05.tistory.com/78https://www.daleseo.com/python-type-annotations/" }, { "title": "[Python] 백준 4673번 : 셀프 넘버", "url": "/posts/boj4673-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2022-02-23 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/4673Solutionselfnum = set()for i in range(1, 10000): sum = i for j in str(i): sum+=int(j) selfnum.add(sum)for i in range(1, 10000): if (i not in selfnum): print(i)Memo위 문제를 해결하기 위해 중복이 허용되지 않는 자료형인 set를 활용하였다. 우선 for문을 돌며 1부터 10000까지의 수 중 셀프넘버가 아닌(더해서 만들어 낼 수 있는) 수를 selfnum 세트에 저장한다. 이후 1부터 다시 for문을 돌며 세트에 포함되지 않은 수를 출력하는 방식으로 구현하였다.Ref.https://wikidocs.net/1015https://wikidocs.net/16044" }, { "title": "[C언어] 코드업 1091 : 수 나열하기3", "url": "/posts/codeup1091-c/", "categories": "Problem Solving, CodeUp", "tags": "c", "date": "2022-02-21 23:56:13 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=1091Solution오답코드#include &lt;stdio.h&gt;int fibo(int a, int m, int d, int n){ if (n==1) return a; else return fibo(a, m, d, n-1)*m+d;}int main(){ int a, m, d, n; scanf(\"%d%d%d%d\",&amp;a,&amp;m,&amp;d,&amp;n); printf(\"%d\",fibo(a, m, d, n));}처음 이 문제를 풀었을 때는 각 변수의 조건 (a, m, d는 -50 ~ +50, n은 10이하의 자연수)을 크게 신경쓰지 않았다. 그랬더니 테스트케이스로 -50 50 -50 10이 입력되었을 때 원래 정답인 -99649234693877550이 나오는 대신 -1947299630이 나와 오답처리 되었다. 따라서 fibo함수의 반환형을 long long형으로 바꿔주었다.정답코드#include &lt;stdio.h&gt;long long fibo(int a, int m, int d, int n){ if (n==1) return a; else return fibo(a, m, d, n-1)*m+d;}int main(){ int a, m, d, n; scanf(\"%d%d%d%d\",&amp;a,&amp;m,&amp;d,&amp;n); printf(\"%lld\",fibo(a, m, d, n));}이렇게 바꾸니 정답처리가 되었다.Memo이 문제를 for문으로 처리할 수도 있었지만 함수를 따로 빼서 피보나치형태로 처리해보았다. 수열의 순서를 나타내는 n이 1일때 a를 return하는 식으로 피보나치 함수를 실행시키면 n번째 수를 구할 수 있다.for문으로 해결한다면 아래와 같이 해결할 수 있을 것이다.#include &lt;stdio.h&gt;int main(){ int a, m, d, n; long long res = 0; scanf(\"%d%d%d%d\",&amp;a, &amp;m, &amp;d, &amp;n); for (int i=0; i&lt;n; i++) res = res * m + d; printf(\"%lld\", res);}" }, { "title": "Django 웹 개발 : 게시판 만들기 (2)", "url": "/posts/django-building-board2/", "categories": "Project", "tags": "django", "date": "2022-02-21 14:34:08 +0900", "snippet": "추가할 기능 답변 페이징과 정렬 카테고리 비밀번호 찾기와 변경 프로필 최근 답변과 최근 댓글 조회 수 소셜 로그인 마크다운 에디터답변 페이징과 정렬테스트 답변 만들기py manange.py shell을 통해 장고 셸을 실행시킨다.from pybo.models import Questionfrom pybo.models import Answerfrom django.utils import timezonefor i in range(50): a = Answer(question_id=302, content='테스트 답변입니다:[%02d]' % i, create_date=timezone.now(), author_id=1) a.save()위와 같이 입력하면 테스트 답변을 얻을 수 있다. for문의 question_id에는 본인이 답변을 입력할 question에 해당하는 id를 입력하면 된다." }, { "title": "TIL 220220", "url": "/posts/til220220/", "categories": "TIL", "tags": "git", "date": "2022-02-20 19:54:20 +0900", "snippet": "Gitcommitgit commit -a -m \"example\"a 옵션을 사용하면 git add를 따로 하지 않고도 add와 commit을 동시에 진행할 수 있다." }, { "title": "Django 웹 개발 : 게시판 만들기 (1)", "url": "/posts/django-building-board1/", "categories": "Project", "tags": "django", "date": "2022-02-19 16:33:08 +0900", "snippet": "Django project 생성mkdir \"프로젝트 최상위 폴더\"cd \"프로젝트 최상위 폴더\"django-admin startproject config .Django 기능 개발 순서 템플릿에 추가 기능을 위한 링크나 버튼 추가 urls.py에 링크에 해당되는 URL 매핑을 작성 forms.py에 폼 작성 (폼이 필요없는 경우에는 생략가능) views.py 파일에 URL 매핑에 추가한 함수 작성 함수에서 사용할 템플릿 작성Refhttps://wikidocs.net/71655" }, { "title": "[C언어] 자료형 변환", "url": "/posts/type-casting/", "categories": "TIL", "tags": "c", "date": "2022-02-18 23:59:52 +0900", "snippet": "자료형 변환형 확장 (암시적 형 변환)자료형의 범위가 넓어지는 경우형 축소 (명시적 형 변환) (= 형 변환)자료형의 범위가 좁아지는 경우int를 나누어서 float형인 변수에 저장하는 코드를 컴파일하게 되면 다음과 같은 경고가 발생한다.test.c:8:14: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=] printf(\"%d MB\",memory); ~^ %f이는 정수형인 int와의 계산을 실수형인 float에 저장하기 때문에 발생하는 문제이다. 이를 무시하고 실행시키면 소수점이 무시된 채로 1.000000 MB과 같이 결과가 출력된다.이처럼 int와의 계산에서 계산결과를 소숫점이 계산된 float형으로 얻으려면 계산하는 int형의 변수 중 일부를 float형으로 변환해야 한다.float memory = (float)h*b*c*s/8/1024/1024;위 코드는 float형인 memory에 맞게 저장하기 위해 h를 float형으로 변환한 것이다.예제Ref.https://dojang.io/mod/page/view.php?id=493" }, { "title": "TIL 220216", "url": "/posts/til220216/", "categories": "TIL", "tags": "django, c", "date": "2022-02-16 22:11:12 +0900", "snippet": "DjangoHTTP MethodsHTTP 메시지 구조 시작 줄 (start-line) HTTP 헤더 (HTTP headers) 공백 (empty line) 바디(body) GETurl을 통해 데이터가 전송됨POSThttp 메시지의 body를 통해 데이터가 전송됨Cgoto문이전에 작성한 레이블로 돌아가 반복하는 명령문 int a;reload: scanf(\"%d\", &amp;a); if(a) { printf(\"%d\\n\",a); goto reload; // 위쪽의 reload 레이블로 다시 올라감 }위 코드에서 a가 0이 아닌경우 if문으로 들어가서 출력한 뒤 reload 레이블로 돌아가서 같은 동작을 a가 0이 나올 때까지 반복함예제Ref.https://www.w3schools.com/tags/ref_httpmethods.asphttps://youtu.be/ts3eGy0-SOohttps://noahlogs.tistory.com/34" }, { "title": "TIL 220215", "url": "/posts/til220215/", "categories": "TIL", "tags": "c", "date": "2022-02-15 23:51:02 +0900", "snippet": "Cswitch문각각의 케이스를 작성한 후 반드시 break를 해주어야 한다.그렇지 않으면 실행된 조건부터 아래의 조건들이 모두 실행됨.do-while문조건에 만족하지 않더라도 최소 1번은 실행되는 반복문형태초기식do // ↓ 루프 본체(loop body) 및 변화식{ 반복할 코드 변화식} while (조건식);// ↑ 루프 선언문(loop statement)예시#include &lt;stdio.h&gt;int main(){ int i = 0; do // 처음 한 번은 아래 코드가 실행됨 { printf(\"Hello, world! %d\\n\", i); // Hello, world!와 i의 값을 함께 출력 i++; // i를 1씩 증가시킴 } while (i &lt; 100); // i가 100보다 작을 때 반복. 0부터 99까지 증가하면서 100번 반복 return 0;}Refhttps://dojang.io/mod/page/view.php?id=198https://dojang.io/mod/page/view.php?id=230" }, { "title": "TIL 220214", "url": "/posts/til220214/", "categories": "TIL", "tags": "c", "date": "2022-02-15 00:09:55 +0900", "snippet": "C&amp;(Ampersand) 기호&amp; 연산자&amp; (비트 연산자 AND)비트 단위로 비교하며 대응되는 비트가 모두 1일때 1 반환&amp;&amp; (논리 연산자 AND)양쪽 모두 참일때 1 반환주소값scanf에 &amp;가 쓰이는 이유3항 연산자조건식 ? (참일 때의 값) : (거짓일 때의 값)ex) a, b 중 큰 값을 출력하는 3항 연산자 printf(\"%d\", a&gt;b ? a:b);따옴표else return \"D\";위 코드를 컴파일 도중 아래와 같은 에러가 떠서 확인해보니 char형인 A~D를 큰따옴표 처리해서 생긴 오류였다.warning: return makes integer from pointer without a cast [-Wint-conversion] else {return \"D\";}모두 작은따옴표로 바꿔주니 오류가 사라졌다.Switch 문switch(변수){ case 값1 : 실행문; break; case 값2 : 실행문; break; default : 실행문; }Refhttps://merrynewday.tistory.com/5" }, { "title": "TIL 220213", "url": "/posts/til220213/", "categories": "TIL", "tags": "c", "date": "2022-02-13 23:24:35 +0900", "snippet": "C형변환long long 형의 데이터인 a와 b를 나누어 소숫점까지 출력하기 위해서 float형으로 형변환을 함.#include &lt;stdio.h&gt;int main(void){ long long a,b; scanf(\"%lld%lld\",&amp;a, &amp;b); printf(\"%.2f\",(float)a/(float)b);}예제논리연산자참 거짓이 다를 때만 참 출력하기printf(\"%d\", (a &amp;&amp; !b)||(!a &amp;&amp; b));" }, { "title": "TIL 220212", "url": "/posts/til220212/", "categories": "TIL", "tags": "c", "date": "2022-02-12 16:52:50 +0900", "snippet": "Cfgets 함수char *fgets(char *s, int size, FILE *stream);공백 포함된 문자열을 입력받을 때 사용.size - 1개의 문자만큼 받거나, '\\n'을 입력받거나, 아니면 EOF가 입력될 때 까지 입력을 받음.예제 1예제 2data type별 범위 &amp; 서식 지정자int-2,147,483,648 ~ +2,147,483,647%d이 범위를 넘어서는 수는 다른 종류의 data type을 통해 처리해야 함.unsigned int0 ~ 4,294,967,295%ulong-2,147,483,648 ~ +2,147,483,647long long-9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807%lldfloat±3.4 x 10-38 ~ ±3.4 x 1038%fdouble±1.7 x 10-308 ~ ±1.7 x 10308%lf형식 바꾸어 출력하기진수 변환10진수를 나타내는 %d 대신 %o (8진수), %x (16진수) 등을 사용#include &lt;stdio.h&gt;int main(void){ int n; scanf(\"%d\",&amp;n); printf(\"%o\",n); return 0;}위는 10진수로 입력된 정수를 8진수로 바꿔 출력하는 코드문자-정수 변환 (ASCII코드)#include &lt;stdio.h&gt;int main(void){ char c; scanf(\"%c\",&amp;c); printf(\"%d\",c); return 0;}위는 입력된 문자를 ASCII코드 상의 정수로 바꿔 출력하는 코드문자열 출력(printf)문자열 출력: printf(\"%s\",str)문자 출력: printf(\"%c\",word)Ref.https://docs.microsoft.com/ko-kr/cpp/cpp/data-type-ranges?view=msvc-170https://shaeod.tistory.com/283https://dojang.io/mod/page/view.php?id=736" }, { "title": "fgets함수가 입력을 받지 않음", "url": "/posts/fgets-input-issue/", "categories": "Problem Solving, etc_PS", "tags": "c, issue", "date": "2022-02-12 00:00:00 +0900", "snippet": " scanf와 fgets를 동시에 사용할 때 fgets가 입력을 받지 않는 문제를 다룸Issue여러 줄의 입력을 받을 때 앞에서 scanf()를 통해 입력을 받으면 뒤에 fgets()로 입력을 받지 않고 함수가 바로 종료되는 문제가 발생.#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Person { char name[20]; int age; char address[100];};int main(void){ struct Person p1; printf(\"이름을 입력하세요: \"); scanf(\"%s\",p1.name); printf(\"나이를 입력하세요: \"); scanf(\"%d\",&amp;p1.age); printf(\"주소를 입력하세요: \"); fgets(p1.address, 50, stdin); printf(\"이름: %s\\n\", p1.name); printf(\"나이: %d\\n\", p1.age); printf(\"주소: %s\\n\", p1.address); }위 코드를 실행시키면 주소를 입력받을 것이라는 예상과 달리 아래처럼 주소를 입력하라고만 출력되고 바로 아래와 같이 결과가 출력된다.이름을 입력하세요: 홍길동나이를 입력하세요: 23주소를 입력하세요: 이름: 홍길동나이: 23주소: Cause이 링크에서 확인해보니 fgets 함수는 입력의 끝을 인식하는데 scanf에서 입력한 개행이 버퍼에 남아서 fgets가 끝으로 인식해 함수를 종료시킨다는 것이었다.Solution위 문제와 관련하여 한 블로그에서 그 해결방법들을 제시해두었는데 본인은 scanf()와 fgets() 사이에 getchar()를 써서 남아있는 개행문자를 빼주었다. 그랬더니 그 후론 정상적으로 입력을 받게 되었다.#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Person { char name[20]; int age; char address[100];};int main(void){ struct Person p1; printf(\"이름을 입력하세요: \"); scanf(\"%s\",p1.name); printf(\"나이를 입력하세요: \"); scanf(\"%d\",&amp;p1.age); getchar(); // 추가한 부분 printf(\"주소를 입력하세요: \"); fgets(p1.address, 50, stdin); printf(\"이름: %s\\n\", p1.name); printf(\"나이: %d\\n\", p1.age); printf(\"주소: %s\\n\", p1.address); }위 코드를 실행한 결과는 아래와 같다이름을 입력하세요: 홍길동나이를 입력하세요: 23주소를 입력하세요: 서울시 송파구 잠실동이름: 홍길동나이: 23주소: 서울시 송파구 잠실동" }, { "title": "WSL2 종료 후 Vmmem이 Windows의 메모리를 차지하는 이슈", "url": "/posts/wsl2-memory-issue/", "categories": "Project", "tags": "wsl2, issue", "date": "2022-02-11 19:59:49 +0900", "snippet": "IssueWSL2를 통해 우분투 환경에서 작업을 하고 난 뒤 프로그램을 종료했는데 윈도우 상에서 작업 관리자를 실행했을 때 다음과 같이 Vmmem이 상당한 메모리를 차지하는 경우가 발생했다.해당 프로그램을 종료하려고 시도해도 아래와 같이 에러창이 뜨면서 종료가 되지 않는다.해당 이슈를 구글링 해보니 아직까지 해결되지 않은 문제인 듯 하다. 임시적인 해결방법은 윈도우 상에 wsl2가 차지하는 메모리의 양을 할당하는 것과 WSL2를 종료시키는 것 두 가지가 있는 것으로 보인다.Solution1. .wslconfig 파일 생성 (최초 1회만)undefined윈도우 상에서 CMD를 실행한 후, C:\\Users\\Username 경로에 copy con .wslconfig와 같이 입력하여 .wslconfig라는 이름의 파일을 생성한다.[wsl2]memory=3GBswap=0파일 내부에 위와 같은 내용(memory의 값은 자신의 메모리 상황에 맞게 입력하면 됨)을 입력한 후 Ctrl+C를 눌러 저장한다.2. wsl 2 종료wsl -l --running를 입력해서 아래와 같이 현재 자신이 사용중인 Ubuntu의 배포판을 확인한다.C:\\Users\\Username\\&gt;wsl -l --runningLinux용 Windows 하위 시스템 배포:Ubuntu-18.04(기본값)bash가 종료된 상태에서 자신의 우분투 버전을 다음과 같은 형태로 입력하여 wsl2를 종료한다.wsl -t Ubuntu-18.04undefined그럼 위와 같이 문제가 해결된 것을 확인할 수 있다.Referencehttps://meaownworld.tistory.com/160https://github.com/microsoft/WSL/issues/4166" }, { "title": "[Python] 코드업 6098 : 성실한 개미", "url": "/posts/codeup6098-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-11 17:45:36 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6098Solution오답 코드course = []for i in range(10): course.append(list(map(int, input().split())))course[1][1] = 9x, y = 1, 1while not(course[x][y+1] == 1 and course[x+1][y] == 1): if course[x][y+1] == 0: y += 1 else: x += 1 if course[x][y] == 2: course[x][y] = 9 break course[x][y] = 9for i in range(10): for j in range(10): print(course[i][j], end=' ') print()위 코드를 실행하니 문제에 주어진 예시는 정상출력됐는데,1 1 1 1 1 1 1 1 1 11 0 0 1 0 0 0 0 0 11 0 0 1 0 0 0 0 0 11 0 0 1 0 0 0 0 0 11 0 0 1 0 0 0 0 0 11 0 0 1 0 0 1 0 0 11 0 0 0 0 0 1 0 0 11 0 0 0 0 0 1 0 0 11 0 0 0 0 0 0 2 0 11 1 1 1 1 1 1 1 1 1위와 같은 테스트케이스가 입력됐을 때는 다음과 같은 에러 메시지가 출력됐다.Traceback (most recent call last): File \"code.py\", line 7, in &lt;module&gt; while not(course[x][y+1] == 1 and course[x+1][y] == 1):IndexError: list index out of range알고보니 개미가 길을 따라 가다가 먹이가 바로 아래에 있으면 while-else에 들어가서 아래로 이동한 뒤 정상적으로 종료되지만, 먹이가 바로 오른쪽에 있는 경우 while-if에 들어가야하지만 들어가지 못한다. 조건을 0(길이 비어있는 경우)만 설정하고 2(길에 먹이가 있는 경우)는 설정하지 않았기 때문이었다.따라서 오른쪽이 아닌 아래로 내려가게 되고 제일 밑줄로 이동한 경우 while문의 course[x+1][y]는 리스트에서 존재하지 않는 인덱스이므로 위와 같은 에러가 발생한 것이다.이 문제를 해결하기 위해 코드를 다음과 같이 수정하였다.정답 코드course = []for i in range(10): course.append(list(map(int, input().split())))course[1][1] = 9 # 시작지점을 9로 변경x, y = 1, 1while not(course[x][y+1] == 1 and course[x+1][y] == 1): if course[x][y+1] == 0 or course[x][y+1] == 2: # 추가한 조건(오른쪽에 먹이가 있는 경우) y += 1 else: x += 1 if course[x][y] == 2: # 먹이를 발견한 경우 course[x][y] = 9 break course[x][y] = 9# 결과 출력for i in range(10): for j in range(10): print(course[i][j], end=' ') print()Memo위 코드는 개미가 오른쪽과 아래가 벽이 아닌 경우 이동하면서 각 좌표에서의 리스트의 값을 9로 변경하는 과정을 구현한 것이다. while문을 돌면서 개미가 먹이를 발견하게 되거나 막다른 곳에 도달하게 되면 반복문이 종료되어 결과를 출력한다." }, { "title": "[Python] 코드업 : 6097 : 설탕과자 뽑기", "url": "/posts/codeup6097-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-11 17:12:51 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6097Solutiongame_board = list()h, w = map(int, input().split())# 2차원 리스트 초기화for i in range(h): tmp = [] for j in range(w): tmp.append(0) game_board.append(tmp)n = int(input())for i in range(n): l,d,x,y = map(int, input().split()) x -= 1 y -= 1 if d == 0: # 가로로 놓인 경우 for i in range(l): game_board[x][y+i] = 1 elif d == 1: # 세로로 놓인 경우 for i in range(l): game_board[x+i][y] = 1# 결과 출력for i in range(h): for j in range(w): print(game_board[i][j], end=' ') print()Memo리스트 game_board의 요소를 전부 0으로 초기화 한 후 d가 0과 1일때로 나누어 값을 1로 변경해주었다.Ref.https://juun42.tistory.com/14" }, { "title": "[Python] 코드업 6096 : 바둑알 십자 뒤집기", "url": "/posts/codeup6096-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-11 16:31:17 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6096Solving우선 한 줄로 들어온 값을 리스트 안에 리스트의 형태로 어떻게 저장할 지 고민했었는데 첫번째는 go[i][1], ... , go[i][19] = map(int, input().split())과 같이 모든 변수를 써서 저장하는거였고 다른 하나는 go[1] = list(map(int, input().split()))를 활용하는 것이었다. 1번 방법은 너무 번잡해서 2번을 사용했는데 왜인지 아래와 같은 에러가 발생했다.Traceback (most recent call last): File \"code.py\", line 8, in &lt;module&gt; go[i] = list(map(int,input().split()))IndexError: list assignment index out of range그래서 append를 사용해 리스트를 저장하여 문제를 해결하였다.오답 코드def turn(a): return int(not a)go = [0]for i in range(1,20): go.append(list(map(int,input().split())))n = int(input())for _ in range(n): x, y = map(int,input().split()) for j in range(1,20) : go[j][y] = turn(go[j][y]) go[x][j] = turn(go[x][j])for i in range(1,20): for j in range(1,20): print(go[i][j], end=' ') print()위와 같이 코드를 작성하니 입력된 좌표의 가로의 값을 변경하면서 다음과 같은 에러가 발생했다.Traceback (most recent call last): File \"code.py\", line 15, in &lt;module&gt; go[x][j] = turn(go[x][j])IndexError: list index out of range해당 파일을 디버깅을 해보니 한 줄의 숫자가 입력되면서 인덱싱이 0부터 부여되는데에 반해 문제에서는 좌표가 1부터 시작하기 때문에 go[x][19]가 존재하지 않아 발생하는 문제였다. 위 문제를 해결하기 위해서는 입력된 좌표를 변경하여 처리하거나 입력할때마다 첫 값을 0으로 입력하는 방법이 있을 것 같다.정답 코드# 0과 1을 맞바꾸는 함수def turn(a): return int(not a)go = []# 2차원 리스트 초기화for i in range(19): go.append(list(map(int,input().split())))n = int(input())for _ in range(n): x, y = map(int,input().split()) # x, y 좌표를 인덱스화 하기 위해 값 변경 x -= 1 y -= 1 # 좌표의 값 변경 for j in range(19) : go[j][y] = turn(go[j][y]) go[x][j] = turn(go[x][j])# 결과 출력for i in range(19): for j in range(19): print(go[i][j], end=' ') print()위 문제를 해결하기 위해 입력된 좌표를 각각 -1을 하였더니 오류가 해결되었다.Memo우선 입력된 줄을 for문을 돌며 리스트 go 안에 넣어 2차원 list로 만들었다. 그 후 입력된 좌표에 맞춰서 for문을 돌면서 위에서 정의한 turn함수를 활용해 go의 가로줄과 세로줄 모두 0은 1로, 1은 0으로 바꿔주었다. 마지막으로 완성된 go 리스트를 for문을 돌며 출력하였다." }, { "title": "TIL 220211", "url": "/posts/til220211/", "categories": "TIL", "tags": "c", "date": "2022-02-11 16:08:34 +0900", "snippet": "Cprintf 함수특수문자 출력특수문자를 출력하기 위해 백슬래시를 무조건 붙여야 하는줄 알고있었는데 알고보니 모든 특수문자가 아닌 아래와 같은 몇가지 특수문자에만 붙이면 되는거였다. 출력할 문자 명칭 작성법 ’ apostrophe ' ” quotation mark \" % percent sign %% \\ backslash \\\\ 자릿수 맞춰 출력 소숫점 n자리까지 출력 (n+1자리에서 반올림)printf(\"%.nf\",a)ex) 소숫점 2자리까지 출력 printf(\"%.2f\",a) 자릿수 맞추기 일반적인 케이스 \"%d\" n자리수 만큼 공백으로 채우기 \"%nd\" n자리수 만큼 0으로 채우기 \"%0nd\" ex) 연/월/일 yyyy-mm-dd 형식에 맞추어 출력 printf(\"%04d.%02d.%02d\", y, m, d);scanf함수공백으로 분리된 변수 두개를 동시에 받아 저장할 때는 scanf(\"%d %d\", &amp;a, &amp;b);로 작성하는게 맞는 것 같아보이지만 scanf(\"%d%d\", &amp;a, &amp;b);와 같이 붙여서 작성해도 같은 방식으로 변수를 받는다.Ref.https://starrykss.tistory.com/996" }, { "title": "개인 프로젝트 계획", "url": "/posts/project-plan/", "categories": "Project", "tags": "개발, 계획", "date": "2022-02-10 16:14:19 +0900", "snippet": "💡ProjectsBeginner Password Generator Tic-Tac-Toe Build a website with flask, django Web Scraper with beautiful soup, selenium Choose your own Text Adventure GameIntermediate 2D Games with Python Microcontroller App with Raspberry Pi Sudoku solver Algorithm Visualizer Project SchedulerAdvanced Chess/Physics/Game Engine e.g. Golf game with physics Build an Interpreter Machine Learning or AI project Microcontroller project, e.g. security system Make your own API web projectReference15 Programming Project Ideas - From Beginner to Advanced (Tech With Tim)" }, { "title": "TIL 220209", "url": "/posts/til220209/", "categories": "TIL", "tags": "python", "date": "2022-02-09 20:15:09 +0900", "snippet": "Pythoncount 메서드.count(self, x, __start, __end)활용예시num = [1,2,3,3]res = num.count(3)print(res)실행결과22차원 list리스트 안에 리스트를 요소로 받는 형태[[1,2],[3,4]]비슷하게 리스트 안에 튜플, 튜플 안에 리스트를 넣을 수도 있음" }, { "title": "[Python] 코드업 6095 : 바둑판에 흰 돌 놓기", "url": "/posts/codeup6095-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-09 17:58:44 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6095Solutionn = int(input())white_coord = []for i in range(n): white_coord.append(tuple(map(int,input().split())))for i in range(1,20): for j in range(1,20): if (i, j) in white_coord: print('1', end = ' ') else: print('0', end = ' ') print()Memo위 문제를 풀기 위해 리스트 안에 튜플 형태의 좌표를 저장하는 방식을 사용했다. 그 후 for문을 돌며 각 좌표가 리스트에 포함되어 있는지의 여부를 체크한 후 결과를 출력하였다." }, { "title": "[Python] 코드업 6092 : 이상한 출석 번호 부르기1", "url": "/posts/codeup6092-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-09 15:58:04 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6092Solutionn = int(input())num = list(map(int,input().split()))for i in range(1, 24): print(num.count(i), end=' ')Memocount 메서드를 사용하지 않고 문제를 해결하려면 빈 리스트를 만들고 새로운 for문으로 확인해가며 요소를 바꿔주면 될 것이다." }, { "title": "[Python] 코드업 6091 : 함께 문제 푸는 날", "url": "/posts/codeup6091-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-09 15:39:12 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6091Solutiona, b, c = map(int,input().split())lcm = max(a, b, c)while not(lcm % a == 0 and lcm % b == 0 and lcm % c == 0): lcm += 1print(lcm)Memo변수 lcm을 a,b,c의 최댓값부터 시작해서 1씩 더해가며 공배수가 되는지를 체크한다. 공배수가 되면 while문을 빠져나와 출력되므로 해당 수는 최소공배수가 된다." }, { "title": "[Python] 코드업 6082 : 3 6 9 게임의 왕이 되자", "url": "/posts/codeup6082-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-09 12:25:50 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6082Solutionn = int(input())for i in range(1,n+1): if (i%10 == 3) or (i%10 == 6) or (i%10 == 9): print('X', end=' ') else: print(i, end=' ')Memo처음 문제를 풀었을 때는 369게임을 3의 배수로 구했다가 오답처리됐다. 이 문제는 입력되는 정수의 조건이 29이하의 양의 정수이기 때문에 1의자리가 3, 6, 9 중 하나인지만 판단하면 된다. 나는 이 조건들을 or로 묶어주었다.입력되는 정수가 30이상이라면 자리수별로 판별을 해야할 것이다." }, { "title": "TIL 220208", "url": "/posts/til220208/", "categories": "TIL", "tags": "python, c", "date": "2022-02-08 18:32:52 +0900", "snippet": "Python비트 연산자AND 연산a &amp; b비트 단위로 둘다 1이면 1, 아닐때 0 반환.OR 연산a | b비트 단위로 둘중 하나라도 1이면 1, 아니면 0 반환.XOR 연산a ^ b비트 단위로 두개가 다르면 1, 같다면 0 반환삼항 연산자print(\"True는 참\" if True else \"True는 거짓\")참일 때 값, if 조건, else 거짓일 때 값a,b = map(int,input().split())print(a if a &gt; b else b)입력받은 두 수중 큰 값을 출력하는 코드C메모리 할당은 언제하는지? 갑자기 많은 메모리를 필요로 하는 경우 변수나 함수가 범위를 벗어나도 메모리에 남아있게 하고싶을 경우 효율적인 리소스 관리를 위해https://jhnyang.tistory.com/330" }, { "title": "[Python] 코드업 6066 : 정수 3개 입력받아 짝/홀 출력하기", "url": "/posts/codeup6066-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-08 17:35:59 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6066Solutionarr = map(int,input().split())for i in arr: print(\"even\" if i % 2 == 0 else \"odd\")Memo입력값을 리스트로 받아서 for문을 통해 하나씩 불러온 후 삼항연산자를 사용하여 출력함." }, { "title": "VSCode (Visual Studio Code) 단축키 (macOS)", "url": "/posts/vscode-shortcut/", "categories": "Tips", "tags": "단축키, vscode", "date": "2022-02-08 00:00:00 +0900", "snippet": "PdfGeneral undo/redo cmd + Z / cmd + shift + Z 터미널 실행 ctrl + ` 화면 분할 cmd + \\ 화면 정리 cmd + B 새 창 열기 cmd + shift + NEditingbasic tab 들여쓰기 shift + tab 현재 행 삭제 cmd + shift + K 매칭 브라켓으로 이동 cmd + shift + \\advanced 자동 줄정리 cmd + K + F 함수/변수명 일괄 변경 cmd+F2, (검토 후 적용)F2 글자가 포함된 부분 전체변경 cmd + shift + L 현재 행 이동 option + ↑/↓ 현재 행 복제 option + shift + ↑/↓ 해당 줄 한번에 잘라내기/복사 (커서만 위치한 상태로)cmd + X/Cblocked line 블럭 한번에 묶기 ( 또는 \" 한줄 주석 처리 cmd + / 여러줄 주석 처리 option + shift + A 블럭 열모드 (시작줄 커서 상태에서) option + shift + (끝줄 드래그)Debugging Breakpoint 전환 F9 시작, 계속 F5 스텝 들어가기, 나가기 F11 / shift + F11 다음으로 F10 멈추기 shift + F5 호버 보기 cmd + K, cmd + IRef.https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-referencehttps://jhnyang.tistory.com/408https://velog.io/@gillog/IDE-VSCode-Mac-OS-단축키-정리" }, { "title": "[Python] 코드업 6044 : 정수 2개 입력받아 자동 계산하기", "url": "/posts/codeup6044-py/", "categories": "Problem Solving, CodeUp", "tags": "python", "date": "2022-02-07 15:54:34 +0900", "snippet": "Problemhttps://codeup.kr/problem.php?id=6044Solutiona,b = map(int, input().split())add = a+bsub = a-bmul = a*bquo = a//bmod = a%bdiv = format(a/b, \".2f\")print(add, sub, mul, quo, mod, div, sep='\\n')" }, { "title": "TIL 220207", "url": "/posts/til220207/", "categories": "TIL", "tags": "python, cs", "date": "2022-02-07 00:00:00 +0900", "snippet": "Pythonsplit 함수특정한 구분자로 구분되어 입력된 값을 나누어 저장할때 사용a, b = input().split()map 함수리스트 형태의 요소를 한번에 형변환할 때 사용a, b = map(int, input().split())문자열 인덱싱/슬라이싱str = \"korea\"print(str[1:4])str[a:b]는 문자열의 a번 인덱스부터 b-1번 인덱스까지를 의미하므로 위 코드를 실행시키면 1번인덱스인 o부터 3번 인덱스인 e까지인 ore가 출력된다.https://wikidocs.net/2838진수 변환입력a = int(input(),16) 16진수로 입력받음codeprint(\"%d\", %a) # 10진수 출력print(\"%x\", %a) # 16진수 출력print(\"%X\", %a) # 16진수 대문자로 출력print(\"%o\", %a) # 8진수 출력print(\"%O\", %a) # 8진수 대문자로 출력유니코드 변환ord() : 문자를 유니코드 상의 정수로 변환chr() : 정수를 유니코드 문자로 변환소숫점 반올림format(a, \".2f\") : 소숫점 이하 2번째 자리까지 반올림format(a, \".3f\") : 소숫점 이하 3번째 자리까지 반올림비트 연산자비트 시프트n &lt;&lt; k : n을 왼쪽으로 k칸씩 이동 → n x 2kn &gt;&gt; k n: 을 오른쪽으로 k칸씩 이동 → n x 2-kn &lt;&lt; 1 : n x 2112 &lt;&lt; 2 : 12의 4배이므로 4812 &gt;&gt; 2 : 12의 1/4배이므로 3~ (tilde) 연산비트 단위로 True/False를 맞바꾸는 연산~n = -n - 1-n = ~n + 12진수 음수표기 방법첫번째 방법2진수의 제일 끝 자리를 부호용으로 정한 표기법두번째 방법 : 1의 보수2진수 양수의 각 비트를 반대로 바꿈.ex) -5를 표현하기 위해 5인 0101을 1010으로 바꿈.양수와 음수를 계산할 때 원래의 값에서 1이 작게 나오는 문제 발생.최종 방법 : 2의 보수1의 보수의 문제를 해결하기 위해 1의 보수로 변환 후 1을 더함.Ref.Twos complement: Negative numbers in binary (Ben Eater)관련 예제" }, { "title": "코딩테스트 합격을 위한 로드맵", "url": "/posts/ps-guideline/", "categories": "Problem Solving, etc_PS", "tags": "계획, ps", "date": "2022-02-06 16:16:56 +0900", "snippet": "방법1. 기본 문법 공부2. 기초 알고리즘 문제코드업: 기초100제 C언어 Python 3. 백준 알고리즘 문제 그리디 알고리즘 기초 동적 프로그래밍 탐색 알고리즘 (이분, 그래프, DFS, BFS 등)유형별 50문제씩 4. 기출 문제프로그래머스 (카카오)난이도 코드포스 블루레벨 삼성 역량테스트 B형추천 언어 C++ PythonRef.대기업 IT직군 코딩테스트 합격을 위한 현실적이고 직관적인 공부 순서" }, { "title": "[C언어] 백준 1003번 : 피보나치 함수", "url": "/posts/boj1003-c/", "categories": "Problem Solving, BOJ", "tags": "c, dp", "date": "2022-02-06 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1003Solution오답 코드 1#include &lt;stdio.h&gt;int count0 = 0;int count1 = 0;int fibonacci(int n) { if (n == 0) { count0++; return 0; } else if (n == 1) { count1++; return 1; } else { return fibonacci(n-1) + fibonacci(n-2); }}int main(void){ int t; scanf(\"%d\", &amp;t); int n[t]; for (int i = 0; i&lt;t; i++) { scanf(\"%d\", &amp;n[i]); } for (int i = 0; i&lt;t; i++) { fibonacci(n[i]); printf(\"%d %d\\n\", count0, count1); }}위와 같이 코드를 짜니 입력을 “3 0 0 0”으로 했을 때 이전에 사용된 변수의 값이 계속 더해져서 결과가 나왔다. 이에 초기화가 필요하다고 판단하여 아래와 같이 for문 안에 변수초기화를 넣었다.오답 코드 2#include &lt;stdio.h&gt;int count0;int count1;int fibonacci(int n) { if (n == 0) { count0++; return 0; } else if (n == 1) { count1++; return 1; } else { return fibonacci(n-1) + fibonacci(n-2); }}int main(void){ int t; scanf(\"%d\", &amp;t); int n[t]; for (int i = 0; i&lt;t; i++) { scanf(\"%d\", &amp;n[i]); } for (int i = 0; i&lt;t; i++) { count0 = 0; count1 = 0; fibonacci(n[i]); printf(\"%d %d\\n\", count0, count1); }}하지만 위 코드는 결과값은 제대로 나오지만 시간초과로 오답처리됐다.오답 코드 3#include&lt;stdio.h&gt;int count0;int count1;int fibo(int n){ if (n == 0) { count0++; return 0; } else if (n == 1) { count1++; return 1; } else { return fibo(n-1) + fibo(n-2); }}int main(void){ int t; int sum0; int sum1; scanf(\"%d\", &amp;t); int n[t]; for (int i = 0; i&lt;t; i++) { scanf(\"%d\", &amp;n[i]); } for (int i = 0; i&lt;t; i++) { if (n[i] == 0) { sum0 = 1; sum1 = 0; } else if (n[i] == 1) { sum0 = 0; sum1 = 1; } else if (n[i] == 2) { sum0 = 1; sum1 = 1; } else if (n[i]&gt;2) { sum0=0; sum1=0; count0=0; count1=0; fibo(n[i]-2); sum0 += count0*2; sum1 += count1*2; count0=0; count1=0; fibo(n[i]-3); sum0 += count0; sum1 += count1; } printf(\"%d %d\\n\", sum0, sum1); }}위 코드는 시간초과를 피하기 위해 규칙성을 이용하였다. f(4)를 구하기 위해 f(3)과 f(2)를 구해야 하는데 f(2)는 f(3)에서도 구하게 된다. 따라서 f(4)의 결과는 f(2)의 결과 x 2 + f(1)의 결과이며 이를 다시 정리하면 f(n)의 결과 = f(n-2) 결과 x 2 + f(n-3)의 결과로 나타낼 수 있다. 하지만 위 코드도 시간초과가 걸리게 됐다.정답 코드#include &lt;stdio.h&gt;int main() { int T; int N; int fibonacci[42][2]; //fibonacci[a][b]에서 a는 함수의 입력값 // b는 0또는 1이 출력되는 횟수.\t//a가 0과 1일때의 배열의 요소를 초기화 fibonacci[0][0] = 1; fibonacci[0][1] = 0; fibonacci[1][0] = 0; fibonacci[1][1] = 1;\t//b가 0과 1일때를 나눠서 계산 for (int i = 2; i &lt; 42; ++i) { fibonacci[i][0] = fibonacci[i - 1][0] + fibonacci[i - 2][0]; fibonacci[i][1] = fibonacci[i - 1][1] + fibonacci[i - 2][1]; } scanf(\"%d\", &amp;T); int n[T]; for (int i = 0; i&lt;T; i++) { scanf(\"%d\", &amp;n[i]); } for (int i = 0; i &lt; T; i++) { printf(\"%d %d\\n\", fibonacci[n[i]][0], fibonacci[n[i]][1]); } return 0;}Memo한 페이지를 확인해보니 시간초과를 해결하기 위해 2차원 배열을 활용하여 N이 40 이하일 때 0과 1일때의 케이스를 모두 저장한 뒤 입력된 값에 해당하는 결과를 출력했다. C++로 작성된 해당 코드를 C로 바꿔 제출하니 이번에는 정답처리됐다.Ref.https://beginnerdeveloper-lit.tistory.com/42https://kyurasi.tistory.com/entry/c-알고리즘-피보나치수-왜-시간초과가-뜰까" }, { "title": "WSL2에서 vscode 실행 안됨 (code 명령어)", "url": "/posts/wsl2-vscode-command-error/", "categories": "Project", "tags": "wsl2, issue, vscode", "date": "2022-02-05 23:51:03 +0900", "snippet": " WSL2에서 Ubuntu를 실행하여 code . 명령어를 입력했을 때 not found가 출력되는 문제에 관한 해결방법을 담고있음.Issue평소처럼 terminal을 실행시키고 홈 디렉토리에서 code . 명령어를 쳤는데 /mnt/c/Users/~/bin/code: not found 라는 문구가 출력됐다. 윈도우에서 직접 vscode를 실행시키니 프로그램의 문제는 아니었다.한참을 이 문제로 고생하다 구글링을 해보니 환경변수 설정이 해제되어 생긴 문제로 보였다.Solution해결방법은 의외로 간단하다. 홈디렉토리에서 .profile을 편집기로 실행시킨 후 맨 아래에 PATH=\"$/mnt/c/Users/(유저이름)/AppData/Local/Programs/Microsoft\\ VS\\ Code/bin\" 다음과 같은 환경변수를 추가하면 된다.Referencehttps://jmcunst.tistory.com/152http://blog.foundy.io/visual-studio-code-maeg-teomineoleseo-code-myeongryeongeo-path-seoljeonghagi/" }, { "title": "앞으로의 계획", "url": "/posts/future-plans/", "categories": "etc", "tags": "계획", "date": "2022-02-02 00:00:00 +0900", "snippet": " 프로그래밍, 영어, 전공에 관한 계획💻Programming프로그래밍 언어1. C / C++공부할 내용 메모리 할당 (2차원 배열 위주로) 포인터 응용 (void 포인터, 이중 포인터, 함수 포인터, 포인터 연산 등) 구조체, 공용체, 열거형 Makefile 개념 파일 입출력 가변인자 #define 상수 매크로C 언어 코딩 도장씹어먹는 C++코딩테스트 합격을 위한 로드맵2. Java Java Spring점프 투 자바Spring 개발 관련 블로그3. Python알고리즘 공부와 병행할 예정파이썬 코딩 도장점프 투 파이썬4. Etc Kotlin, Swift GoGo를 향한 여행효과적인 Go 프로그래밍주요 개념시스템 프로그래밍Computer Systems - A Programmers Perspective자료 구조운영 체제Operating System Concepts컴퓨터 구조Computer Architecture - A Quantitative Approach알고리즘데이터베이스SQL 전문가 되어보기소프트웨어 공학개발WebDjango, Flask 등의 웹 프레임워크를 활용해 서비스를 배포점프 투 장고점프 투 플라스크App🌎Language 원서 영어 신문🌳Major 그래픽 툴 Photoshop Illustrator AutoCAD Rhino SketchUp Lumion V-Ray 전공 공부 이전 강의자료 공부 관련 서적 처음 만나는 조경학 경관, 조형 &amp; 디자인 조경구조학 " }, { "title": "[42 Seoul] 라피신 4주차 & 최종 회고", "url": "/posts/piscine-w4/", "categories": "42Seoul, Piscine", "tags": "회고", "date": "2022-01-28 00:00:00 +0900", "snippet": "Final Exam10시에 시작된 시험은 무려 8시간이 지나서야 끝이 났다.앞부분 문제들은 생각보다 수월하게 풀었다. 중간중간 개념이 헷갈려서 시간쏟은 부분이 있긴 했지만..(단어 하나만 저장할 때는 작은 따옴표를 쓴다는 것 등) 하지만 9번이 넘어가면서부터 생소한 개념이었던 메모리 할당이 나오기 시작했다. 10번 ft_rrange 문제는 단순 할당이라서 man을 보면서 해결했다. 하지만 11번 ft_split 문제는 string을 char 단위로 쪼개서 2차원 배열에 저장해야하는데 2차원 메모리 할당을 어떻게 하는지부터 막혔다. 결국 계속해서 Segmentation Fault : 11가 발생해서 6시에 못푼 채로 시험을 마무리했다.부족한 부분메모리 할당 (2차원 배열)구조체 개념Makefile 개념라피신을 마무리하며4주간 아침 일찍 만원 지하철을 타고 강남역 대륭서초타워 클러스터로 갔다가 저녁 늦게 퇴근하는 삶을 살아보니 재수할때가 떠올랐다. 오랜만에 그 시절의 열정을 조금이나마 느낄 수 있어 뿌듯했다. C는 거의 기초부터 배우는 언어였기 때문에 매일 강남역을 오가는 지하철 안에서 강의를 듣는 등 뒤쳐지지 않기 위해 노력깨나 했던 것 같다. 걱정도 많이 됐지만 주변에 있는 다른 피시너들의 도움과 구글링 덕에 조금씩 해결해 나갔다. 중간 중간 문제가 잠시 막힐 때 해결 방법을 고민하는 과정도 꽤 흥미로웠다. 그리고 라피신 과정을 통해 혼자 배울때는 알기 힘들었던 점들을 상당히 많이 알게 되었다.우선 정말 모르겠으면 주변에 물어보는게 낫다는 것. 이걸 초반 2주 동안 어려워해서 시간을 조금 낭비했다.두번째는 다른사람의 코드를 보며 배우는 것이 참 많다는 것. 코드는 것이 각자의 생각의 틀에서 나오는 일종의 설계도이기 때문에 다른 사람의 코드를 보고 이해하는 과정을 거친다면 내 생각의 폭도 그만큼 넓어진다고 생각한다.마지막으로 이 분야에는 성실한 사람과 실력자가 참 많다는 점. 오전 9시에 나오며 항상 놀랐던 부분은 미리 도착해서 공부중인 사람들이 생각보다 많았고 그중 상당수는 클러스터가 문을 닫는 오후 10시까지 계속 있었다는 점이다. Rush를 진행하면서 어떻게 해결할 지 감도 안잡히는 문제들을 척척 해결하는 피시너들도 대단했다. 동시에 내가 이러한 실력차를 따라잡기 위해 들여야 할 노력이 만만치 않다는 점도 깨닫곤 했다.혼자 공부할 때는 미처 파악하지 못했던 이러한 점들을 알게 된 것만으로도 이번 경험이 헛되지는 않았다고 생각한다." }, { "title": "[42 Seoul] 라피신 3주차", "url": "/posts/piscine-w3/", "categories": "42Seoul, Piscine", "tags": "회고", "date": "2022-01-21 00:00:00 +0900", "snippet": "Exam 02저번 시험에서 접속방법까지는 시도해봤지만 깃에 올리는건 처음이라 걱정이 됐었다. 거의 맨땅에 헤딩하는 식으로 폴더를 만들고 문제를 올렸는데 정상적으로 채점이 돼서 다행이었다. 문제는 2문제밖에 풀지 못했다. 0번 문제는 명령인자로 들어온 문자열이 3가지 조건(①’a’가 포함된 경우, ②’a’가 없는 경우, ③인자가 1개가 아닌 경우)일 때 ‘a’를 출력하고 개행문자를 쓰는거였다.(./a.out cat -e 를 실행시키면 a$ 가 출력될 수 있도록) 하지만 argc와 argv를 rush때 잠깐 써본 것 빼곤 실제로 사용해 본 적이 없어서 계속 오류가 났다. 그래서 조건을 다시 살펴보니 인자의 입력여부, ‘a’의 포함여부에 상관없이, 즉, 모든 경우에 a$가 출력되면 되는 문제였다. 하지만 또 문제가 생겼는데 개행문자를 어떻게 출력하느냐였다. 파이썬에서는 \\n을 썼던 기억이 있는데 이상하게 계속 오류가 났다.(다음날 다시 해보니 그땐 잘 됐다..) 그래서 하는 수 없이 man ascii를 찾아서 엔터가 있을법한 번호인 0~32를 전부 출력해보기로 했다. 그 결과 10이 ascii코드로 엔터에 해당한다는 사실을 알게됐다. 1번 문제는 main함수에서 주어진 문제열을 거꾸로 출력하는 문제였다. 이 문제는 며칠 전에 c01을 하면서 비슷한 문제가 있어서 그 코드를응용해서 작성했다.(문자열을 while문으로 받아서 길이(n) 체크 → n부터 0까지 출력) 하지만 이상하게 처음에 실행하자 “Bus Error : 10”이라는 에러메시지가 출력되거나, 에러가 안뜨더라도 “abc”를 문자열로 주면 “^@cba”가 출력됐다. 주석처리를 해가며 디버깅을 해봤더니 문제열의 길이를 재는 while문에서 오류가 발생했다. 문자을의 끝을 널문자로 체크하는거였는데 오류가 생기자 그냥 문자열을 ascii코드 상의 문자에 해당되는지 체크하기로 했다.while (str[i] &gt; 31 &amp;&amp; str[i] &lt; 127)다행히 이렇게 하니 오류 없이 정상적으로 작동해서 success를 받았다.exam 끝나고 안 사실인데 exam에서는 norminette 체크를 안해도 된다고 한다. 이거 때문에 시간 좀 썼고 2번 문제를 포기했는데 늦게 안 것이 아쉬웠다. 또 내가 오랫동안 씨름한 문자열의 길이체크에서 ‘\\0’ 대신 ‘\\n’을 썼다는 사실을 알게 됐다. 정확하게 알지 않은 상태에서 시험을 보니 평소 보이던 것 마저 안보이게 된 것 같다.공부할 부분-main 함수에서 명령인자를 받는 방법과 그 인자(argc, argv)를 다른함수로 가져와 변수로써 사용하는 방법-./a.out “example” 일때 argc는 1? 2?→argc는 실행파일까지 카운트 하므로 argv[0]은 실행파일이, argv[1]은 example이 되므로 2.-문자열을 받아서 반환한 함수의 형태가 왜 char function(str) 형태인지-Bus Error : 10 의미-문자열을 받아 끝을 판단할 때 str[i] != ‘\\n’이 안된 이유→ null 문자: ‘\\0’ 개행 문자: ‘\\n’-문자열을 수정하는 방법→ 인덱스 형태로 초기화하면 됨.-vim 사용법: 한줄 삭제, 빠르게 이동, 복붙→ esc를 누른 뒤 커서를 위치시키고 dd를 누르면 해당 줄이 지워짐.Referencehttps://dojang.io/mod/page/view.php?id=330" }, { "title": "[C언어] 함수 : 선언, 정의, 호출", "url": "/posts/c-function-declare/", "categories": "TIL", "tags": "c", "date": "2022-01-20 00:00:00 +0900", "snippet": "함수의 선언 (프로토타입)컴퓨터는 왼쪽-&gt; 오른쪽, 위-&gt;아래 방향으로 코드를 읽음.따라서 아래에 정의된 함수를 위에서 사용할 때는 현재 함수 전에 프로토타입을 선언해야함.#include&lt;stdio.h&gt;int main(void){ int a = 10; int b = 20; test(a, b); //인자 a, b}void test(int c, int d) //매개변수 c, d{ printf(\"%d, %d\", c, d);}위의 코드처럼 test함수 아래에 main함수가 나오는 형태가 아닌 main함수가 위에 오고 test함수를 호출하는 경우에는 아래와 같은 에러 메시지가 뜨는데 이는 프로토타입이 선언되지 않았기 때문.함수의 정의처음 함수를 공부하니 매개변수와 인자, 인수의 개념이 모호해서 혼용함. 그래서 자세히 찾아보니 아래와 같은 차이가 있었음.매개변수(parameter), 인자함수를 정의할 때 앞으로 들어올 인자의 형태. 변수.인수(argument)함수를 호출할 때 넣는 값. 이 값이 해당 함수에 전달됨.#include&lt;stdio.h&gt;void test(int c, int d) //매개변수 c, d{ printf(\"%d, %d\", c, d);}int main(void){ int a = 10; int b = 20; test(a, b); //인자 a, b}함수의 호출특정 함수를 사용하기 위함.*주의* 함수를 호출할 때 함수이름 앞에 반환형(void 등)을 붙이지 않기!예시)void test(a, b);Ref.https://www.tcpschool.com/javascript/js_function_parameterArgument" }, { "title": "라피신 Rush 01", "url": "/posts/piscine-rush01/", "categories": "42Seoul, Piscine", "tags": "c", "date": "2022-01-20 00:00:00 +0900", "snippet": "Problem네 방향에서 바라볼 때의 보이는 건물의 개수가 주어질 때 가능한 건물들의 형태를 구하는 문제   4 3 2 1   4 1 2 3 4 1 3 2 3 4 1 2 2 3 4 1 2 2 1 4 1 2 3 2   1 2 2 2   Solution 실행파일 옵션으로 입력된 값(argv)을 하나의 배열에 저장한다. 4x4의 케이스(건물의 형태)를 저장할 틀을 5x5로 저장한다. row 0과 column 0은 값이 들어오지 않는다고 가정함. (xy좌표축 처럼 직관적으로 사용하기 위해.) 1row부터 각 column에 해당하는 칸에 들어갈 숫자를 1부터 4까지 넣어가며 중복 검사(작은 row, 작은 column과 비교) 유효성 검사(각 방향에서의 숫자와 보이는 숫자가 일치하는지 비교) 후에 모든 검사를 통과하면 출력한다.탐색 방법: 깊이 우선 탐색Defense1시에 평가를 시작하자 마자 평가자분이 해당 파일을 실행시켰는데 error가 출력됐다. 예외 체크도 하기 전에 error가 떠서 다들 당황했었는데 알고보니 bad option에 해당하는 값을 입력해서 생긴 문제였다.바로 제대로 코드를 살펴보며 질문을 했는데 argv를 받을 때 형태(“숫자+스페이스+숫자+···+숫자”)의 형태가 맞는지 체크하는 부분이 빠졌다고 지적을 받았다. 또 전역변수를 사용한 부분에 대해 지적받았다. 하지만 다행히 이 부분들은 토론 끝에 다음에 더욱 주의를 기울이는걸로 하고 제대로 점수를 받을 수 있었다.전역변수를 사용하지 않고 문제를 해결하려면 구조체를 사용하거나 포인터를 사용해 넘겨주면 된다고 한다.etc토요일에 만나서 반나절을 고심한 끝에 세운 해결책은 다음과 같았다.1~4의 정수로 이루어질 수 있는 모든 4x4의 케이스를 구하는 함수를 짠 후에 차례대로 중복검사와 유효성검사를 실행하여 맞는 케이스를 찾아내는 것이었다.하지만 이렇게 세운 전략대로 코드를 짤 수가 없었다. 이후에 한 팀원이 다른 전략을 찾아서 코드를 완성할 수 있었다." }, { "title": "TIL 220119", "url": "/posts/til220119/", "categories": "TIL", "tags": "algorithm, c", "date": "2022-01-19 00:00:00 +0900", "snippet": " 42서울 rush 과제를 해결하며 배운 내용깊이 우선 탐색 (DFS, Depth-First Search)DFS ↔ 너비우선탐색(BFS, Breadth-First Search)루트 노드(or 임의의 노드)에서 시작해서 해당 분기를 완전히 탐색하고 다음 분기로 넘어가는 방법순서a-b-ga-b-ha-c-ia-c-j · · ·증감 연산자전위(prefix) 연산자b = ++ a증감 연산자를 변수 앞에 사용한 것동작 방식 a가 1 증가. 증가된 a값이 b에 할당됨. 후위(postfix) 연산자 b = a ++증감 연산자를 변수 뒤에 사용한 것 동작 방식 현재 a의 값이 b에 할당됨. a가 1 증가.메모리 할당(malloc)메모리를 할당하는 것기본형태포인터 = malloc(크기)void *malloc(size_t_Size);활용#include &lt;stdlib.h&gt; // malloc, free 함수가 선언된 헤더int *numPtr2; // int형 포인터 선언numPtr2 = malloc(sizeof(int)); // int의 크기 4바이트만큼 동적 메모리 할당free(numPtr2); // 동적으로 할당한 메모리 해제malloc으로 할당한 메모리를 free하지 않으면 메모리 누수 발생기타0 : False0이 아닌 모든 값 : True" }, { "title": "[C언어] 포인터", "url": "/posts/c-pointer/", "categories": "TIL", "tags": "c", "date": "2022-01-17 00:00:00 +0900", "snippet": "포인터의 개념기본 형태int *a;int형 포인터를 a로 선언한다는 뜻*(asterisk)의 활용 포인터를 선언 해당 주소의 값에 접근 ← 중요!예시#include&lt;stdio.h&gt;int main (void){ int a = 42;\t\t//변수 선언, 초기화 int* ptr;\t\t//int형을 가르키는 포인터 p 선언 ptr = &amp;a;\t\t//포인터 p에 a의 주소를 저장 printf(\"Integer* size : %d\", sizeof(int*)); printf(\"Float* size : %d\", sizeof(float*)); printf(\"Char* size : %d\", sizeof(char*));/* 출력결과&gt;&gt;Char* size : 8Integer* size : 8Integer* size : 8*///자료형에 상관없이 모든 포인터의 크기는 8바이트 printf(\"value of 'ptr' is %d \", *ptr);/* 출력결과&gt;&gt;value of 'ptr' is 42*///ptr 앞에 * 붙여서 값을 가져옴 printf(\"address of 'a' is %x\\n\", &amp;a); printf(\"address of 'a' is %x \", ptr);/* 출력결과&gt;&gt;address of 'a' is ff000bc4address of 'a' is ff000bc4*///ptr이 a의 주소를 가르키기 때문에 &amp;a(a의 주소)를 쓰는것과 같은 의미 return 0;}활용포인터를 쓰지 않는 경우#include &lt;stdio.h&gt;void add(int a, int b){ a++; b++;}int main(){ int a = 1; int b = 1; add(a, b); printf(\"a: %d, b: %d\",a,b); return 0;}위와 같은 코드를 실행시키면 다음과 같은 결과를 출력한다. a: 1, b: 1add함수에 a와 b 변수를 인자로 넘겼지만 main함수에서의 a,b와 add함수의 a,b는 별개로 인식되기 때문이다.포인터를 쓰는 경우#include &lt;stdio.h&gt;void add(int *a, int *b){ (*a)++; (*b)++;}int main(){ int a = 1; int b = 1; add(&amp;a, &amp;b); printf(\"a: %d, b: %d\",a,b); return 0;}이번에는 다음과 같이 add 함수를 호출할 때 a와 b의 주소값을 인자로 넘겼다. a: 2, b: 2add 함수는 매개변수로 포인터를 받기 때문에 포인터 각각을 역참조하여 더하게 되면 그 결과가 main함수의 각 변수에 반영됨을 알 수 있다.Referencehttps://youtu.be/A7C9-Ea_zBQhttps://dojang.io/mod/page/view.php?id=275" }, { "title": "[C언어] 전처리기", "url": "/posts/c-preprocessor/", "categories": "TIL", "tags": "c", "date": "2022-01-16 00:00:00 +0900", "snippet": "전처리기 (Preprocessor)전처리기는 번역의 첫 번째 단계의 일부로 소스 파일의 텍스트를 조작하는 텍스트 프로세서이다. 전처리는 소스 텍스트를 구문 분석하지 않지만 매크로 호출을 찾기 위해 토큰으로 나눈다. 비록 컴파일러가 일반적으로 첫 번째 패스에서 전처리를 호출하지만, 전처리는 컴파일 없이 텍스트를 처리하기 위해 별도로 호출될 수도 있다.전처리기 지시문 (Preprocessor directives)#define 및 #ifdef와 같은 전처리기 지시어는 일반적으로 소스 프로그램을 다른 실행 환경에서 쉽게 변경하고 컴파일할 수 있도록 하기 위해 사용된다. 소스 파일의 지시어는 전처리기에게 특정 작업을 수행하도록 지시한다.예를 들어, 프리프로세서는 텍스트의 토큰을 바꾸거나, 다른 파일의 내용을 원본 파일에 삽입하거나, 텍스트 섹션을 제거하여 파일의 일부를 컴파일하지 못하도록 할 수 있다. 전처리 라인은 매크로 확장 전에 인식되고 수행된다. 따라서 매크로가 전처리기 명령처럼 보이는 것으로 확장되면 전처리기에서 인식되지 않는다.전처리기 문은 이스케이프 시퀀스가 지원되지 않는다는 점을 제외하고 소스 파일 문과 동일한 문자 집합을 사용한다. 전처리기 문에 사용되는 문자 집합은 실행 문자 집합과 동일하다. 전처리기는 음수 문자 값도 인식한다.전처리기가 인식하는 지시문의 종류#define#elif#else#endif#error#if#ifdef#ifndef#import#include#line#import#include#line#pragma#undef#using#define 지시문(#define directive)#define은 식별자 또는 매개 변수화된 식별자와 토큰 문자열의 연결인 매크로를 생성한다.매크로가 정의된 후 컴파일러는 소스 파일에서 식별자가 나타날 때마다 토큰 문자열을 대체할 수 있다.syntax#define identifier token-stringopt#define identifier ( identifieropt, ... , identifieropt ) token-stringopt#include 지시문(#include directive)지시문이 나타나는 지점에 지정된 파일의 내용을 포함하도록 전처리에 지시한다.syntax#include \" path-spec \"#include &lt; path-spec &gt;Reference전처리기#define 지시문#include 지시문" }, { "title": "[C언어] 배열", "url": "/posts/c-array/", "categories": "TIL", "tags": "c", "date": "2022-01-16 00:00:00 +0900", "snippet": " 배열의 기본 개념개념같은 자료형의 변수를 일렬로 늘어놓은 형태배열 ≈ 포인터활용str이라는 이름의 배열이 있을때,str[0] ↔ *str이 두 표현 모두 str 배열 0번 인덱스의 주소값을 의미함.str[0]+1 ↔ str++str 배열의 1번 인덱스에 해당하는 값기타문자열에서의 쓰임문자열의 각 문자를 배열로 표현할 수 있다.““(큰따옴표)는 문자열에 사용, ‘‘(작은따옴표)는 문자에 사용Ref.https://dojang.io/mod/page/view.php?id=292" }, { "title": "[C언어] gcc 컴파일 명령어", "url": "/posts/gcc-compile-commands/", "categories": "TIL", "tags": "c, gcc", "date": "2022-01-10 00:00:00 +0900", "snippet": "gcc [filename]#기본 컴파일 명령어. 실행파일 이름은 a.out으로 생성gcc -o [output name] [filename]#실행파일 이름을 지정gcc -o [output name] [f1] [f2] [f3]#파일 여러개 하나로 컴파일gcc -Wall#모든 모호한 코드에 대해 경고" }, { "title": "Shell 명령어 정리", "url": "/posts/piscine-shell/", "categories": "42Seoul, Piscine", "tags": "shell", "date": "2022-01-08 00:00:00 +0900", "snippet": " 라피신 첫 과제인 Shell 내용 정리Shell 명령어man#명령어 별로 매뉴얼을 볼 수 있음ctrl + a/e/u#명령줄 앞/뒤 이동,삭제echo [content] &gt; [filename]#파일을 생성해서 내용을 저장함cat &gt; [filename]#파일 만들어서 바로 입력#이후 종료는 ctrl+d 사용mkdir ex{00..09}#디렉토리 한번에 생성cp -rf [original dir name]/* [new dir name]#새 디렉토리에 복붙#original 디렉토리의 하위 모든 디렉토리가 new 디렉토리 안에 복사됨.cat */*#디렉토리 내의 모든 파일 열기tar -xf [filename]#압축 해제#옵션에 v를 추가하면 결과를 출력함tar -cf [압축파일명] [내부파일명]#파일 압축#특수문자 파일명: 각 특수문자 앞에 \\ 붙여야 함chmod [per num] [filename]#권한(permission) 변경rm -rf [filename]#강제 삭제 명령어(디렉토리 삭제에 이용)ln [filename1] [filename2]#하드링크 생성ln -s [TARGET] [LINK_NAME]#심볼릭 링크 생성#!/bin/sh#스크립트 첫줄에 붙이는 이유는 해당 경로에서 bash를 실행시킨다는 의미kinit#kerberos 티켓 발급klist#kerberos 티켓 현황 표시file -m ft_magic 42f#매직파일 확인" }, { "title": "Git 기본 개념", "url": "/posts/git-tutorial/", "categories": "TIL", "tags": "git", "date": "2022-01-07 00:00:00 +0900", "snippet": "Git이란?Git은 리누스 토르발스가 개발한 분산형 버전 관리 시스템(Distributed Version Control Systems)이다.이 시스템을 통해 개발자가 중앙 서버에 접속하지 않고도 코드작업을 할 수 있다.저장소의 종류 원격 저장소(Remote Repository)파일이 원격 저장소 전용 서버에서 관리되며 여러 사람이 함께 공유하기 위한 저장소 로컬 저장소(Local Repository)내 PC에 파일이 저장되는 개인 전용 저장소로컬 저장소의 구성Git의 로컬저장소 버전관리는 아래 3가지 영역을 통해 이루어진다. Working Directory내가 작업하고 있는 프로젝트의 디렉토리 Staging Area커밋을 하기 위해 git add 명령어로 추가한 파일들이 모여있는 공간 Repository커밋들이 모여있는 저장소명령어git clone [repo url] [dirname]# 저장소 복사. 원격 저장소의 레포지토리를 로컬 저장소로 복사함.git init# git 저장소 초기화. 일반 디렉토리에 .git 디렉토리를 생성하여 깃 레포지토리로 전환함.git add [filename]# 파일 변경사항 추가. Working Directory에서 Staging Area로 변경내역을 추가함. [filename]에 * 또는 A를 입력하면 모든 파일의 변경사항이 추가됨.git commit -m \"text\"# 커밋 생성. git add를 통해 Staging Area로 넘겨준 모든 파일을 하나의 스냅샷으로 기록함.git push# 원격 저장소에 커밋 전송.git pull# 원격 저장소의 변경된 내용을 로컬 저장소로 가져옴.git rm [filename]# 로컬 저장소에 있는 파일을 삭제함. 이후에 commit을 통해 삭제내역을 반영해아함.git log# 커밋한 내역을 확인함.git status# 저장소 상태 체크. 저장소의 브랜치, 저장소 안의 변경사항 등을 확인함.git config —global —edit# 편집Git config user.name# 이름 설정git config user.email# 이메일 설정git ls-files -o -i --exclude-standard# git에서 ignore 되는 파일 찾는 명령어Ref.https://ko.wikipedia.org/wiki/분산_버전_관리https://git-scm.com/book/ko/v2/부록-C%3A-Git-명령어-스냅샷-다루기https://velog.io/@shin6403/Git-이란https://iseunghan.tistory.com/322" }, { "title": "[Python] 백준 10809번 : 알파벳 찾기", "url": "/posts/boj10809-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-09-07 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10809Solutioncodeimport stringa = input()for i in string.ascii_lowercase: print(a.find(i),end=' ')Memo문제 푸는 방법이 한참동안 떠오르지 않았다. 그래서 구글링을 해보니 파이썬 함수 중에 문자열에서 문자를 찾는 함수인 find가 있다는 것을 알았고 알파벳은 string 라이브러리를 통해 표현할 수 있다는 것 또한 알았다.이후에 알파벳을 for문으로 반복하면서 탐색하면 알파벳의 위치를 찾을 수 있다." }, { "title": "[Python] 백준 1094번 : 막대기", "url": "/posts/boj1094-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-08-25 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1094Solutionx = bin(int(input()))print(x.count(\"1\"))Memo문제에서 설명하는 과정대로 풀어내려고 했더니 너무 복잡했다. 따라서 과정을 단순화 했더니 2진수에서의 1의 개수를 구하는 것으로 정리됐다.우선 bin 함수를 사용하여 입력된 10진수를 2진수로 변환한 후 count 를 통해 1의 개수를 알아냈다." }, { "title": "[Python] 백준 11021번 : A+B - 7", "url": "/posts/boj11021-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-08-17 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11021Solution주어진 횟수를 통해 for문을 구성하였다.print문의 양식이 복잡하기 때문에 문자열 포맷팅을 활용하여 표현하였다.codea = int(input())for i in range(a): b = list(map(int, input().split())) print(\"Case #%d: %d\" %(i+1,b[0]+b[1]))" }, { "title": "[Python] 백준 1110번 : 더하기 사이클", "url": "/posts/boj1110-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-08-12 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1110Solutiona = int(input())n = 0b = ak=100while k != a: if 0&lt;b&lt;10: while b&lt;10: b*=11 k=b n+=1 elif b==0: n+=1 break else: c=b//10+b%10 k=b%10*10+c%10 b=k n+=1print(n)Memo위 문제는 주어진 조건을 읽고 해석하는 데에 많은 시간을 할애했다. 주어진 수가 10보다 작은 경우 진행되는 과정을 이해하고 나서야 제대로 코드를 작성할 수 있었다. 0이 주어질 경우는 다른 케이스와 따로 분리시켰다.맨 위에 b와 k를 구분시킨 이유는 시작하자마자 while문에 걸려서 프로그램이 종료되는 일을 방지하기 위해서인데, 변수를 추가하지 않고도 while문에 n과 관련된 조건을 추가시킨다면 해결될 것 같다." }, { "title": "[Python] 백준 11050번 : 이항 계수 1", "url": "/posts/boj11050-py/", "categories": "", "tags": "algorithm, boj, python", "date": "2021-07-26 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11050Solutionmath 모듈을 import 해서 해결했다.codeimport matha = list(map(int,input().split()))n = a[0]k = a[1]cal = math.factorial(n)/(math.factorial(n-k)*math.factorial(k))print(int(cal))" }, { "title": "[Python] 백준 10952번 : A+B - 5", "url": "/posts/boj10952-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-26 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10952Solutionwhile문을 사용해서 계속 입력받음.문제의 조건인 입력값 0 0 일 때 프로그램을 종료시키는 부분은 if문에 적용함.codewhile True: a = list(map(int,input().split())) if a[0]==a[1]==0: break else: print(a[0]+a[1])" }, { "title": "[Python] 백준 1010번 : 다리 놓기", "url": "/posts/boj1010-py/", "categories": "Problem Solving, BOJ", "tags": "python, dp", "date": "2021-07-26 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1010Solutionimport matht = int(input())for i in range(t): a = list(map(int,input().split())) k = a[0] n = a[1] cal = math.factorial(n)/(math.factorial(n-k)*math.factorial(k)) print(int(cal))Memo문제를 살펴보면 다리의 개수는 N개로 고정되어 있고 동쪽에서 사이트가 N개 정해지면 연결되는 경우는 서쪽의 순서로 고정된다. 따라서 M개 중 N개를 택하는 경우의 수(mCn)가 된다." }, { "title": "[Python] 백준 8958번 : OX퀴즈", "url": "/posts/boj8958-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-25 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/8958Solution처음에 입력받은 값 5는 for문을 반복하는 횟수로 사용했다.다음으로 입력받은 OX문자열은 X를 기준으로 split해서 리스트로 만들었다. 그렇게 되면 OOXXOXXOOO를 입력하면 리스트 a의 값은 ['OO', '', 'O', '', 'OOO']이 된다. 이때 점수가 산정되는 방식을 살펴보면 OO-&gt; 1+2=3점, O-&gt; 1점, OOO-&gt; 1+2+3=6점으로, O의 개수가 n개라고 할 때 1부터 n까지의 자연수의 합으로 나타난다. 따라서 등차수열의 합 공식을 사용하여 리스트의 각 요소에 해당하는 점수를 n*(n+1)/2로 나타낼 수 있다. 이 값을 더해나가면 해당 입력값에 해당하는 출력값인 점수를 얻을 수 있다.codeitr = int(input())for _ in range(itr): qw = 0 a = input().split('X') for i in a: if 'O' in i: n = i.count('O') qw+=n*(n+1)/2 print(int(qw))" }, { "title": "[Python] 백준 1978번 : 소수찾기", "url": "/posts/boj1978-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-22 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1978Solutionqwe=input()a = list(map(int,input().split()))count=0def prime_number(number): if number != 1: for f in range(2, number): if number % f == 0: return False else: return False return Truefor i in a: if prime_number(i)!=False: count+=1print(count)Memofor문과 count변수를 사용하는 것 까지는 진행됐는데 소수를 판별하는 부분은 해결하지 못함.아래 사이트에서 소수를 판별하는 코드를 활용해서 완성함.판별을 소수가 아닌 것을 찾아내는 방식으로 해야함.Ref.https://mathcoding.tistory.com/19" }, { "title": "[Python] 백준 2588번 : 곱셈", "url": "/posts/boj2588-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-14 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2588Solutioncode1a = int(input())b = int(input())print(a*(b%10))print(a*(b%100-b%10)//10)print(a*(b-b%100)//100)print(a*b)자리수 별로 나눠서 계산하는 방법이 직접 계산으로 구하는 방법밖에 떠오르지 않았다.제출하고 다른 사람들의 코드를 보다가 문자열을 활용하여 자리수의 수를 구한 코드를 봤다.code2a = int(input())b = input()print(a*int(b[2]))print(a*int(b[1]))print(a*int(b[0]))print(a*int(b))위 코드를 보면 line2는 1과 달리 input으로 입력받은 수에 대해 형변환을 바로 하지 않는다. 이는 line4에서 자리수를 구할때 문자열인 점을 활용하기 위해서이다." }, { "title": "[Python] 백준 11720번 : 숫자의 합", "url": "/posts/boj11720-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-11 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11720Solutioncodea = int(input())b = map(int,input())sum = 0for i in b: sum+=iprint(sum)Memo이해되지 않는 부분이 몇 가지 있다. line2를 b = map(int,input().split())로 하는 것과의 차이 b = list(map(int,input())와 결괏값이 같게 나오는 이유 위 코드에서 b를 출력해보면 &lt;map object at 0x000001A046F4D148&gt;가 출력된다. 이 상태에서 for문을 for i in range(a)와 sum+=b[i]로 작성하면 TypeError: 'map' object is not subscriptable 의 오류가 나오지만 위 코드는 이러한 오류가 발생하지 않는 이유" }, { "title": "[Python] 백준 2577번 : 숫자의 개수", "url": "/posts/boj2577-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-10 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2577Solutioncount함수를 활용해서 문자열 안의 숫자 여부를 카운팅 했다.mul = 1for _ in range(3): mul*=int(input())mul = str(mul)for i in range(10): print(mul.count(str(i)))" }, { "title": "[Python] 백준 2884번 : 알람 시계", "url": "/posts/boj2884-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-08 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2884Solutionh,m = map(int, input().split())if m&gt;=45: print(h,m-45)else: if h!=0: print(h-1,m+15) else: print(23,m+15)Memo조건문을 활용해 H와 M이 범위 밖으로 나가는 것을 방지한다." }, { "title": "[Python] 백준 10871번 : X보다 작은 수", "url": "/posts/boj10871-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-07-02 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10871Solutioncode1list = input().split()n = int(list[0])x = int(list[1])c = []a = input().split()for i in a: if int(i)&lt;x: c.append(int(i))for i in c: print(i,end=' ')위 코드를 map함수를 사용하여 간결하게 만들 수 있다.출력값도 별도의 리스트를 만들어 출력하지 않고 비교할때마다 출력시킬 수 있다.code2n, x = map(int, input().split())a = map(int, input().split())c = []for i in a: if i&lt;x: print(i, end=' ')위 코드의 의문점은 n이 주어진 이유와 활용법(Java 등의 언어에서 배열의 크기를 할당하기 위해서?),그리고 end=’ ‘를 통해 공백을 만들면 마지막 출력값인 3 뒤에도 공백이 생길텐데 문제되지 않는 이유이다." }, { "title": "[Python] 백준 11726번 : 2×n 타일링", "url": "/posts/boj11726-py/", "categories": "Problem Solving, BOJ", "tags": "python, dp", "date": "2021-06-29 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/11726Solutionimport mathsol=0x = int(input())for n in range(0,x+1): while (x-n)%2==0: y = (x-n)//2 sol += math.factorial(n+y)//(math.factorial(n)*math.factorial(y)) breakprint(sol%10007)Memo1x2 타일을 a, 2x1 타일을 b라 할 때, b의 개수별로 케이스를 나눠서 경우의 수를 구하였다.각 경우의 수는 ‘같은 것이 있는 순열’의 공식을 활용하였다." }, { "title": "[Python] 백준 8393번 : 합", "url": "/posts/boj8393-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-06-28 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/8393Solutioncode1n = int(input())sum = 0def fsum(): global sum for i in range(n+1): sum+=i return sumprint(fsum())for루프를 도는 함수를 정의해서 합을 구해나갔다.code2n = int(input())print((n**2+n)//2)Memo정답자 코드를 살피던 중 수열의 합 공식을 활용해서 구한 인상적인 코드가 있었다.이 방법을 사용하면 9줄에 달하는 코드를 2줄로 줄일 수 있었다.print 부분에서 / 대신 //를 사용한 것은 float형이 아닌 int형으로 구하기 위함인 것 같다." }, { "title": "[Python][Java] 백준 10998번 : AxB", "url": "/posts/boj10998-py/", "categories": "Problem Solving, BOJ", "tags": "python, java", "date": "2021-05-10 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10998Solutioncode1(python)a, b = input().split()a = int(a)b = int(b)print(a*b)code2(python)a, b = map(int,input().split())print(a*b)code3(java)import java.util.*;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\t\t\tint a,b;\t\ta = sc.nextInt();\t\tb = sc.nextInt();\t\tSystem.out.println(a*b);\t}}Memo2)의 코드는 (1)의 코드에서 중복되는 부분인 line 2,3을 1과 통합한 것이다.이 문제를 해결하기 위해선 입력된 문자열을 list로 나누는 함수인 split에 대해 알아야 한다.또한 map 함수를 사용해 str으로 받은 list를 int로 변환해야 한다.Ref.https://wikidocs.net/13#splithttps://wikidocs.net/32#map" }, { "title": "[Java] 백준 1000번 : A+B", "url": "/posts/boj1000-java/", "categories": "Problem Solving, BOJ", "tags": "java", "date": "2021-04-15 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1000Solutionimport java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner scan = new Scanner(System.in);\t\tint a = scan.nextInt();\t\tint b = scan.nextInt();\t\tSystem.out.println(a+b);\t}}MemoScanner 클래스를 통해 사용자로부터 입력을 받는다.Python에서는 입력(1 2)받은 후 split함수를 사용하여 두개의 변수로 나누는 작업이 필요했지만Java에서는 nextInt를 사용하면 변수 각각을 따로 저장할 수 있다." }, { "title": "[Python] 백준 10430번 : 나머지", "url": "/posts/boj10430-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-03-23 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10430Solutioninput을 통해 문자열을 입력받은 후 split함수를 사용해서 list형태로 변환했다.str형인 A, B, C 각각을 int형으로 변환한 후 계산하여 출력.codeA, B, C = input().split()A = int(A)B = int(B)C = int(C)print((A+B)%C)print(((A%C) + (B%C))%C)print((A*B)%C)print(((A%C) * (B%C))%C)" }, { "title": "[Python] 백준 1920번 : 수 찾기", "url": "/posts/boj1920-py/", "categories": "Problem Solving, BOJ", "tags": "python, 자료구조, 이분탐색", "date": "2021-02-10 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/1920Solution오답 코드 1def binary(a, b): left , right = 0, y - 1 while left &lt;= right: middle = (left + right) // 2 if b == a[middle]: return 1 elif b &gt; a[middle]: left = middle + 1 else: right = middle - 1 return 0x = int(input())a = list(map(int, input().split()))a.sort()y = int(input())b = list(map(int, input().split()))for i in range(y): print(binary(a, b[i]))위 코드를 제출하면 런타임 에러가 뜬다.오답 코드 2import sysdef binary(a, b): left , right = 0, y - 1 while left &lt;= right: middle = (left + right) // 2 if b == a[middle]: return 1 elif b &gt; a[middle]: left = middle + 1 else: right = middle - 1 return 0x = int(input())a = list(map(int, sys.stdin.readline().split()))a.sort()y = int(input())b = list(map(int, sys.stdin.readline().split()))for i in range(y): print(binary(a, b[i]))input() 부분을 sys.stdin.readline()으로 바꿨는데 같은 문제가 발생했다.정답 코드x = int(input())a = list(map(int, input().split()))a.sort()y = int(input())b = list(map(int, input().split()))for i in b: left = 0 right = x - 1 while(left &lt;= right): mid = (right+left) // 2 if a[mid] &lt; i: left = mid + 1 elif a[mid] &gt; i: right = mid - 1 elif a[mid] == i: print(1) break else: print(0) break if left &gt; right: print(0) break1,2 처럼 함수를 따로 정의하지 않았다." }, { "title": "[Python] 백준 2750번 : 수 정렬하기", "url": "/posts/boj-2750-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-02-04 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2750Solution정답 코드1N = int(input())numbers = []for i in range(N) : numbers.append(int(input()))for i in range(1, len(numbers)) : while (i&gt;0) &amp; (numbers[i] &lt; numbers[i-1]) : numbers[i], numbers[i-1] = numbers[i-1], numbers[i] i -= 1 for n in numbers : print(n)line1과 line5의 int(input())은 다르다.오답 코드N = int(input())n = []for i in range(N) : n.append(int(input()))for i in range(N-1) : for k in range(i+1,N) : if n[i] &gt; n[k] : n[i] , n[k] = n[k] , n[i] k -= 1 else : continue for n in n: print(n)위 코드는 bubble sort 방식으로 정렬하는 것을 의사코드로 만들고 나서 실제 코드로 변환한 것인데, 551324를 입력하면 51324를 출력했다.디버깅을 해보니 for i in range(N-1):루프에서 k에 -1을 적용해도 다음 반복때 2가 증가한다는 사실을 알게됐다.정답 코드2N = int(input())n = []for i in range(N) : n.append(int(input()))n = sorted(n)for i in range(N): print(n[i])위 코드의 중간부분을 한줄로 줄였다." }, { "title": "[Python] 백준 2438번 : 별 찍기 - 1", "url": "/posts/boj2438-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-02-01 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2438Solutionn = int(input())for i in range(n): i += 1 print(\"*\" * i)" }, { "title": "[Python] 백준 10869번 : 사칙연산", "url": "/posts/boj10869-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-02-01 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/10869Solutioncodea, b = map(int,input().split())print(a+b, a-b, a*b, a//b, a%b,sep='\\n')Memoline2에서는 각각의 계산을 따로 출력하는 대신 sep=’\\n’을 활용하여 한번의 print로 처리하였다." }, { "title": "[Python] 백준 1008번 : A/B", "url": "/posts/boj1008-py/", "categories": "Problem Solving, BOJ", "tags": "python", "date": "2021-02-01 00:00:00 +0900", "snippet": "Problemhttp://www.acmicpc.net/problem/1008Solutiona, b = map(int,input().split())print(a/b)Memo제출 결과는 정답 처리 되었지만, 문제의 조건인 “실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다.”가 포함된 이유는 이해하지 못하였다.조건의 의미는 소숫점 9번째 자리까지 값이 같아야 한다는 것인데 코드의 결과값이 16번째 자리까지 출력되므로 추가적인 코드 없이도 조건을 충족시키기 때문이다.추가다른 블로그의 해결방법을 보니 문제의 조건이 주어진 이유가 컴퓨터의 [라운드오프 에러] (http://www.ktword.co.kr/abbr_view.php?m_temp1=5052)와 관련있다고 한다.내 컴퓨터에서는 10/3를 계산했을 때 3.3333333333333335 라는 값이 출력되었다." }, { "title": "[Python] 백준 2839번 : 설탕배달", "url": "/posts/boj2839-py/", "categories": "Problem Solving, BOJ", "tags": "python, dp, greedy", "date": "2021-01-29 00:00:00 +0900", "snippet": "Problemhttps://www.acmicpc.net/problem/2839Solution오답코드N = int(input())a = N // 5b = N % 5if b &lt; 3 : if b == 0 : print(a) elif b == 1 : print(a+1) else : print(-1) else : if b == 3 : print(a+1) else : if a == 0 : print(-1) else : print(a+2)설탕의 무게를 5로 나누었을 때의 나머지를 기준으로 분류를 했는데 입출력 값은 맞게 나오지만 오답처리되었다.정답코드sugar = int(input())bag = 0while sugar &gt;= 0 : if sugar % 5 == 0 : bag += (sugar // 5) print(bag) break sugar -= 3 bag += 1else : print(-1)" } ]
